
================================================================================
GAME GENERATION: tiktactoe - 2025-08-09 13:07:10.523781
================================================================================
FULL CLAUDE GENERATED CODE:
----------------------------------------
```
<div style="text-align: center; padding: 20px;">
  <h3>üéÆ Tic Tac Toe</h3>
  <canvas id="game_tiktactoe_canvas" width="400" height="300" style="border: 2px solid #333; background: #fff; cursor: pointer;"></canvas>
  <div style="margin: 10px 0;">
    <strong>Current Player: <span id="game_tiktactoe_player">X</span></strong>
  </div>
  <div style="font-size: 12px; color: #666;">
    Controls: Click on squares to place X or O
  </div>
</div>
<script>
const tiktactoe_canvas = document.getElementById('game_tiktactoe_canvas');
const tiktactoe_ctx = tiktactoe_canvas.getContext('2d');
const tiktactoe_playerSpan = document.getElementById('game_tiktactoe_player');

let tiktactoe_board = [['', '', ''], ['', '', ''], ['', '', '']];
let tiktactoe_currentPlayer = 'X';
let tiktactoe_gameOver = false;

function tiktactoe_drawBoard() {
  tiktactoe_ctx.clearRect(0, 0, 400, 300);
  
  // Draw grid lines
  tiktactoe_ctx.strokeStyle = '#333';
  tiktactoe_ctx.lineWidth = 3;
  
  // Vertical lines
  tiktactoe_ctx.beginPath();
  tiktactoe_ctx.moveTo(133, 0);
  tiktactoe_ctx.lineTo(133, 300);
  tiktactoe_ctx.moveTo(267, 0);
  tiktactoe_ctx.lineTo(267, 300);
  tiktactoe_ctx.stroke();
  
  // Horizontal lines
  tiktactoe_ctx.beginPath();
  tiktactoe_ctx.moveTo(0, 100);
  tiktactoe_ctx.lineTo(400, 100);
  tiktactoe_ctx.moveTo(0, 200);
  tiktactoe_ctx.lineTo(400, 200);
  tiktactoe_ctx.stroke();
  
  // Draw X's and O's
  tiktactoe_ctx.font = '60px Arial';
  tiktactoe_ctx.textAlign = 'center';
  tiktactoe_ctx.textBaseline = 'middle';
  
  for (let row = 0; row < 3; row++) {
    for (let col = 0; col < 3; col++) {
      if (tiktactoe_board[row][col] === 'X') {
        tiktactoe_ctx.fillStyle = '#e74c3c';
        tiktactoe_ctx.fillText('X', col * 133 + 66, row * 100 + 50);
      } else if (tiktactoe_board[row][col] === 'O') {
        tiktactoe_ctx.fillStyle = '#3498db';
        tiktactoe_ctx.fillText('O', col * 133 + 66, row * 100 + 50);
      }
    }
  }
}

function tiktactoe_checkWinner() {
  // Check rows
  for (let row = 0; row < 3; row++) {
    if (tiktactoe_board[row][0] && tiktactoe_board[row][0] === tiktactoe_board[row][1] && tiktactoe_board[row][1] === tiktactoe_board[row][2]) {
      return tiktactoe_board[row][0];
    }
  }
  
  // Check columns
  for (let col = 0; col < 3; col++) {
    if (tiktactoe_board[0][col] && tiktactoe_board[0][col] === tiktactoe_board[1][col] && tiktactoe_board[1][col] === tiktactoe_board[2][col]) {
      return tiktactoe_board[0][col];
    }
  }
  
  // Check diagonals
  if (tiktactoe_board[0][0] && tiktactoe_board[0][0] === tiktactoe_board[1][1] && tiktactoe_board[1][1] === tiktactoe_board[2][2]) {
    return tiktactoe_board[0][0];
  }
  if (tiktactoe_board[0][2] && tiktactoe_board[0][2] === tiktactoe_board[1][1] && tiktactoe_board[1][1] === tiktactoe_board[2][0]) {
    return tiktactoe_board[0][2];
  }
  
  // Check for tie
  let isFull = true;
  for (let row = 0; row < 3; row++) {
    for (let col = 0; col < 3; col++) {
      if (tiktactoe_board[row][col] === '') {
        isFull = false;
        break;
      }
    }
  }
  
  return isFull ? 'tie' : null;
}

function tiktactoe_resetGame() {
  tiktactoe_board = [['', '', ''], ['', '', ''], ['', '', '']];
  tiktactoe_currentPlayer = 'X';
  tiktactoe_gameOver = false;
  tiktactoe_playerSpan.textContent = 'X';
  tiktactoe_drawBoard();
}

tiktactoe_canvas.addEventListener('click', function(e) {
  if (tiktactoe_gameOver) {
    tiktactoe_resetGame();
    return;
  }
  
  const rect = tiktactoe_canvas.getBoundingClientRect();
  const x = e.clientX - rect.left;
  const y = e.clientY - rect.top;
  
  const col = Math.floor(x / 133);
  const row = Math.floor(y / 100);
  
  if (row >= 0 && row < 3 && col >= 0 && col < 3 && tiktactoe_board[row][col] === '') {
    tiktactoe_board[row][col] = tiktactoe_currentPlayer;
    
    const winner = tiktactoe_checkWinner();
    if (winner) {
      tiktactoe_gameOver = true;
      if (winner === 'tie') {
        tiktactoe_playerSpan.textContent = "It's a Tie! Click to restart";
      } else {
        tiktactoe_playerSpan.textContent = winner + " Wins! Click to restart";
      }
    } else {
      tiktactoe_currentPlayer = tiktactoe_currentPlayer === 'X' ? 'O' : 'X';
      tiktactoe_playerSpan.textContent = tiktactoe_currentPlayer;
    }
    
    tiktactoe_drawBoard();
  }
});

tiktactoe_drawBoard();
</script>
```
----------------------------------------

MORPH BEFORE/AFTER COMPARISON:
----------------------------------------
BEFORE (GameZone.js):
import React from 'react';

const GameZone = ({ currentGame }) => {
  // Simple HTML content zone - perfect for Morph apply!
  // Just put your HTML game content here and it will render
  // this is the html content that will be rendered in the game zone ONLY CHANGE THIS ZONE
  // MORPH: ONLY replace the content between these backticks - keep everything else the same
  const htmlContent = `
    <div style="text-align: center; padding: 20px;">
      <h2>üéÆ HTML Game Zone</h2>
      <p>This is where your HTML5 Canvas games will appear!</p>
      <div style="background: linear-gradient(45deg, #ff6b6b, #4ecdc4); padding: 20px; border-radius: 10px; color: white; margin: 20px 0;">
        <strong>Perfect for Morph Apply!</strong><br/>
        Just replace the htmlContent variable above with your generated HTML5 game code
      </div>
      <div style="border: 2px dashed #ccc; padding: 40px; margin: 20px 0; border-radius: 8px;">
        <p style="color: #666; font-style: italic;">
          üéØ Game content will render here<br/>
          üìù Use Morph to apply HTML5 Canvas games directly<br/>
          üöÄ No complex React components needed!
        </p>
      </div>
      <p style="font-size: 12px; color: #888;">
        Current game: ${currentGame || 'None selected'}
      </p>
    </div>
  `;

  return (
    <div className="game-zone">
      <div className="game-content">
        <div dangerouslySetInnerHTML={{ __html: htmlContent }} />
      </div>
    </div>
  );
};

export default GameZone;

AFTER (GameZone.js):
import React from 'react';

const GameZone = ({ currentGame }) => {
  // Simple HTML content zone - perfect for Morph apply!
  // Just put your HTML game content here and it will render
  // this is the html content that will be rendered in the game zone ONLY CHANGE THIS ZONE
  // MORPH: ONLY replace the content between these backticks - keep everything else the same
  const htmlContent = `
<div style="text-align: center; padding: 20px;">
  <h3>üéÆ Tic Tac Toe</h3>
  <canvas id="game_tiktactoe_canvas" width="400" height="300" style="border: 2px solid #333; background: #fff; cursor: pointer;"></canvas>
  <div style="margin: 10px 0;">
    <strong>Current Player: <span id="game_tiktactoe_player">X</span></strong>
  </div>
  <div style="font-size: 12px; color: #666;">
    Controls: Click on squares to place X or O
  </div>
</div>
<script>
const tiktactoe_canvas = document.getElementById('game_tiktactoe_canvas');
const tiktactoe_ctx = tiktactoe_canvas.getContext('2d');
const tiktactoe_playerSpan = document.getElementById('game_tiktactoe_player');

let tiktactoe_board = [['', '', ''], ['', '', ''], ['', '', '']];
let tiktactoe_currentPlayer = 'X';
let tiktactoe_gameOver = false;

function tiktactoe_drawBoard() {
  tiktactoe_ctx.clearRect(0, 0, 400, 300);
  
  // Draw grid lines
  tiktactoe_ctx.strokeStyle = '#333';
  tiktactoe_ctx.lineWidth = 3;
  
  // Vertical lines
  tiktactoe_ctx.beginPath();
  tiktactoe_ctx.moveTo(133, 0);
  tiktactoe_ctx.lineTo(133, 300);
  tiktactoe_ctx.moveTo(267, 0);
  tiktactoe_ctx.lineTo(267, 300);
  tiktactoe_ctx.stroke();
  
  // Horizontal lines
  tiktactoe_ctx.beginPath();
  tiktactoe_ctx.moveTo(0, 100);
  tiktactoe_ctx.lineTo(400, 100);
  tiktactoe_ctx.moveTo(0, 200);
  tiktactoe_ctx.lineTo(400, 200);
  tiktactoe_ctx.stroke();
  
  // Draw X's and O's
  tiktactoe_ctx.font = '60px Arial';
  tiktactoe_ctx.textAlign = 'center';
  tiktactoe_ctx.textBaseline = 'middle';
  
  for (let row = 0; row < 3; row++) {
    for (let col = 0; col < 3; col++) {
      if (tiktactoe_board[row][col] === 'X') {
        tiktactoe_ctx.fillStyle = '#e74c3c';
        tiktactoe_ctx.fillText('X', col * 133 + 66, row * 100 + 50);
      } else if (tiktactoe_board[row][col] === 'O') {
        tiktactoe_ctx.fillStyle = '#3498db';
        tiktactoe_ctx.fillText('O', col * 133 + 66, row * 100 + 50);
      }
    }
  }
}

function tiktactoe_checkWinner() {
  // Check rows
  for (let row = 0; row < 3; row++) {
    if (tiktactoe_board[row][0] && tiktactoe_board[row][0] === tiktactoe_board[row][1] && tiktactoe_board[row][1] === tiktactoe_board[row][2]) {
      return tiktactoe_board[row][0];
    }
  }
  
  // Check columns
  for (let col = 0; col < 3; col++) {
    if (tiktactoe_board[0][col] && tiktactoe_board[0][col] === tiktactoe_board[1][col] && tiktactoe_board[1][col] === tiktactoe_board[2][col]) {
      return tiktactoe_board[0][col];
    }
  }
  
  // Check diagonals
  if (tiktactoe_board[0][0] && tiktactoe_board[0][0] === tiktactoe_board[1][1] && tiktactoe_board[1][1] === tiktactoe_board[2][2]) {
    return tiktactoe_board[0][0];
  }
  if (tiktactoe_board[0][2] && tiktactoe_board[0][2] === tiktactoe_board[1][1] && tiktactoe_board[1][1] === tiktactoe_board[2][0]) {
    return tiktactoe_board[0][2];
  }
  
  // Check for tie
  let isFull = true;
  for (let row = 0; row < 3; row++) {
    for (let col = 0; col < 3; col++) {
      if (tiktactoe_board[row][col] === '') {
        isFull = false;
        break;
      }
    }
  }
  
  return isFull ? 'tie' : null;
}

function tiktactoe_resetGame() {
  tiktactoe_board = [['', '', ''], ['', '', ''], ['', '', '']];
  tiktactoe_currentPlayer = 'X';
  tiktactoe_gameOver = false;
  tiktactoe_playerSpan.textContent = 'X';
  tiktactoe_drawBoard();
}

tiktactoe_canvas.addEventListener('click', function(e) {
  if (tiktactoe_gameOver) {
    tiktactoe_resetGame();
    return;
  }
  
  const rect = tiktactoe_canvas.getBoundingClientRect();
  const x = e.clientX - rect.left;
  const y = e.clientY - rect.top;
  
  const col = Math.floor(x / 133);
  const row = Math.floor(y / 100);
  
  if (row >= 0 && row < 3 && col >= 0 && col < 3 && tiktactoe_board[row][col] === '') {
    tiktactoe_board[row][col] = tiktactoe_currentPlayer;
    
    const winner = tiktactoe_checkWinner();
    if (winner) {
      tiktactoe_gameOver = true;
      if (winner === 'tie') {
        tiktactoe_playerSpan.textContent = "It's a Tie! Click to restart";
      } else {
        tiktactoe_playerSpan.textContent = winner + " Wins! Click to restart";
      }
    } else {
      tiktactoe_currentPlayer = tiktactoe_currentPlayer === 'X' ? 'O' : 'X';
      tiktactoe_playerSpan.textContent = tiktactoe_currentPlayer;
    }
    
    tiktactoe_drawBoard();
  }
});

tiktactoe_drawBoard();
</script>
`;

  return (
    <div className="game-zone">
      <div className="game-content">
        <div dangerouslySetInnerHTML={{ __html: htmlContent }} />
      </div>
    </div>
  );
};

export default GameZone;

================================================================================


================================================================================
GAME GENERATION: tik tak toe - 2025-08-09 13:18:54.732414
================================================================================
FULL CLAUDE GENERATED CODE:
----------------------------------------
```javascript
import React, { useState } from 'react';

const GameZone = ({ currentGame }) => {
  const [board, setBoard] = useState(Array(9).fill(null));
  const [isXNext, setIsXNext] = useState(true);
  const [winner, setWinner] = useState(null);

  const checkWinner = (squares) => {
    const lines = [
      [0, 1, 2],
      [3, 4, 5],
      [6, 7, 8],
      [0, 3, 6],
      [1, 4, 7],
      [2, 5, 8],
      [0, 4, 8],
      [2, 4, 6],
    ];
    for (let i = 0; i < lines.length; i++) {
      const [a, b, c] = lines[i];
      if (squares[a] && squares[a] === squares[b] && squares[a] === squares[c]) {
        return squares[a];
      }
    }
    return null;
  };

  const handleClick = (index) => {
    if (board[index] || winner) return;
    
    const newBoard = [...board];
    newBoard[index] = isXNext ? 'X' : 'O';
    setBoard(newBoard);
    
    const gameWinner = checkWinner(newBoard);
    if (gameWinner) {
      setWinner(gameWinner);
    } else {
      setIsXNext(!isXNext);
    }
  };

  const resetGame = () => {
    setBoard(Array(9).fill(null));
    setIsXNext(true);
    setWinner(null);
  };

  const isDraw = !winner && board.every(square => square !== null);

  const renderSquare = (index) => (
    <button
      key={index}
      onClick={() => handleClick(index)}
      style={{
        width: '80px',
        height: '80px',
        fontSize: '24px',
        fontWeight: 'bold',
        border: '2px solid #333',
        backgroundColor: '#fff',
        cursor: 'pointer',
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'center'
      }}
    >
      {board[index]}
    </button>
  );

  return (
    <div style={{
      display: 'flex',
      flexDirection: 'column',
      alignItems: 'center',
      padding: '20px',
      fontFamily: 'Arial, sans-serif'
    }}>
      <h2 style={{ marginBottom: '20px' }}>Tic Tac Toe</h2>
      
      <div style={{
        display: 'grid',
        gridTemplate: 'repeat(3, 80px) / repeat(3, 80px)',
        gap: '2px',
        marginBottom: '20px',
        border: '2px solid #333'
      }}>
        {Array(9).fill(null).map((_, index) => renderSquare(index))}
      </div>

      <div style={{ textAlign: 'center', marginBottom: '20px' }}>
        {winner ? (
          <h3 style={{ color: 'green' }}>Winner: {winner}!</h3>
        ) : isDraw ? (
          <h3 style={{ color: 'orange' }}>It's a Draw!</h3>
        ) : (
          <h3>Next Player: {isXNext ? 'X' : 'O'}</h3>
        )}
      </div>

      <button
        onClick={resetGame}
        style={{
          padding: '10px 20px',
          fontSize: '16px',
          backgroundColor: '#007bff',
          color: 'white',
          border: 'none',
          borderRadius: '5px',
          cursor: 'pointer'
        }}
      >
        Reset Game
      </button>
    </div>
  );
};

export default GameZone;
```
----------------------------------------


================================================================================
GAME GENERATION: car game - 2025-08-09 13:26:47.780186
================================================================================
FULL CLAUDE GENERATED CODE:
----------------------------------------
import React, { useState, useEffect, useRef, useCallback } from 'react';

const GameZone = ({ currentGame }) => {
  const canvasRef = useRef(null);
  const [gameState, setGameState] = useState('playing');
  const [score, setScore] = useState(0);
  const [car, setCar] = useState({ x: 175, y: 250, width: 50, height: 30 });
  const [obstacles, setObstacles] = useState([]);
  const [keys, setKeys] = useState({});

  const gameWidth = 400;
  const gameHeight = 300;
  const carSpeed = 5;
  const obstacleSpeed = 3;

  const resetGame = useCallback(() => {
    setCar({ x: 175, y: 250, width: 50, height: 30 });
    setObstacles([]);
    setScore(0);
    setGameState('playing');
  }, []);

  const checkCollision = (rect1, rect2) => {
    return rect1.x < rect2.x + rect2.width &&
           rect1.x + rect1.width > rect2.x &&
           rect1.y < rect2.y + rect2.height &&
           rect1.y + rect1.height > rect2.y;
  };

  const gameLoop = useCallback(() => {
    if (gameState !== 'playing') return;

    setCar(prevCar => {
      let newX = prevCar.x;
      if (keys['ArrowLeft'] && newX > 0) newX -= carSpeed;
      if (keys['ArrowRight'] && newX < gameWidth - prevCar.width) newX += carSpeed;
      return { ...prevCar, x: newX };
    });

    setObstacles(prevObstacles => {
      let newObstacles = prevObstacles.map(obs => ({
        ...obs,
        y: obs.y + obstacleSpeed
      })).filter(obs => obs.y < gameHeight);

      if (Math.random() < 0.02) {
        newObstacles.push({
          x: Math.random() * (gameWidth - 40),
          y: -30,
          width: 40,
          height: 30
        });
      }

      return newObstacles;
    });

    setScore(prevScore => prevScore + 1);
  }, [gameState, keys]);

  useEffect(() => {
    const handleKeyDown = (e) => {
      setKeys(prev => ({ ...prev, [e.key]: true }));
    };

    const handleKeyUp = (e) => {
      setKeys(prev => ({ ...prev, [e.key]: false }));
    };

    window.addEventListener('keydown', handleKeyDown);
    window.addEventListener('keyup', handleKeyUp);

    return () => {
      window.removeEventListener('keydown', handleKeyDown);
      window.removeEventListener('keyup', handleKeyUp);
    };
  }, []);

  useEffect(() => {
    const interval = setInterval(gameLoop, 50);
    return () => clearInterval(interval);
  }, [gameLoop]);

  useEffect(() => {
    obstacles.forEach(obstacle => {
      if (checkCollision(car, obstacle)) {
        setGameState('gameOver');
      }
    });
  }, [car, obstacles]);

  useEffect(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;

    const ctx = canvas.getContext('2d');
    ctx.clearRect(0, 0, gameWidth, gameHeight);

    ctx.fillStyle = '#333';
    ctx.fillRect(0, 0, gameWidth, gameHeight);

    for (let i = 0; i < gameWidth; i += 40) {
      ctx.fillStyle = '#666';
      ctx.fillRect(i + 18, 0, 4, gameHeight);
    }

    ctx.fillStyle = '#00ff00';
    ctx.fillRect(car.x, car.y, car.width, car.height);

    ctx.fillStyle = '#ff0000';
    obstacles.forEach(obstacle => {
      ctx.fillRect(obstacle.x, obstacle.y, obstacle.width, obstacle.height);
    });
  });

  return (
    <div style={{ 
      display: 'flex', 
      flexDirection: 'column', 
      alignItems: 'center', 
      padding: '20px',
      fontFamily: 'Arial, sans-serif'
    }}>
      <h2 style={{ margin: '0 0 10px 0' }}>Simple Car Game</h2>
      <div style={{ marginBottom: '10px' }}>
        Score: {score} | Status: {gameState}
      </div>
      
      <canvas
        ref={canvasRef}
        width={gameWidth}
        height={gameHeight}
        style={{
          border: '2px solid #000',
          backgroundColor: '#333'
        }}
      />
      
      <div style={{ marginTop: '15px' }}>
        <button 
          onClick={resetGame}
          style={{
            padding: '10px 20px',
            fontSize: '16px',
            backgroundColor: '#4CAF50',
            color: 'white',
            border: 'none',
            borderRadius: '5px',
            cursor: 'pointer',
            marginRight: '10px'
          }}
        >
          {gameState === 'gameOver' ? 'Play Again' : 'Restart'}
        </button>
      </div>
      
      <div style={{ 
        marginTop: '15px', 
        textAlign: 'center',
        fontSize: '14px',
        color: '#666'
      }}>
        Use arrow keys to move left and right<br/>
        Avoid the red obstacles!
      </div>
      
      {gameState === 'gameOver' && (
        <div style={{
          marginTop: '15px',
          padding: '10px',
          backgroundColor: '#ffebee',
          border: '1px solid #f44336',
          borderRadius: '5px',
          color: '#d32f2f',
          fontWeight: 'bold'
        }}>
          Game Over! Final Score: {score}
        </div>
      )}
    </div>
  );
};

export default GameZone;
----------------------------------------


================================================================================
GAME GENERATION: pacman - 2025-08-09 13:28:01.148852
================================================================================
FULL CLAUDE GENERATED CODE:
----------------------------------------
import React, { useState, useEffect, useCallback } from 'react';

const GameZone = ({ currentGame }) => {
  const GRID_SIZE = 20;
  const ROWS = 15;
  const COLS = 20;
  
  const initialMaze = [
    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
    [1,2,2,2,2,2,2,2,2,1,1,2,2,2,2,2,2,2,2,1],
    [1,2,1,1,2,1,1,1,2,1,1,2,1,1,1,2,1,1,2,1],
    [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1],
    [1,2,1,1,2,1,2,1,1,1,1,1,1,2,1,2,1,1,2,1],
    [1,2,2,2,2,1,2,2,2,1,1,2,2,2,1,2,2,2,2,1],
    [1,1,1,1,2,1,1,1,0,1,1,0,1,1,1,2,1,1,1,1],
    [0,0,0,1,2,1,0,0,0,0,0,0,0,0,1,2,1,0,0,0],
    [1,1,1,1,2,1,0,1,1,0,0,1,1,0,1,2,1,1,1,1],
    [1,2,2,2,2,2,0,1,0,0,0,0,1,0,2,2,2,2,2,1],
    [1,2,1,1,2,1,0,1,1,1,1,1,1,0,1,2,1,1,2,1],
    [1,2,2,2,2,1,2,2,2,1,1,2,2,2,1,2,2,2,2,1],
    [1,1,1,2,2,2,2,1,2,1,1,2,1,2,2,2,2,1,1,1],
    [1,2,2,2,2,2,2,1,2,2,2,2,1,2,2,2,2,2,2,1],
    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
  ];

  const [maze, setMaze] = useState(initialMaze);
  const [pacmanPos, setPacmanPos] = useState({ x: 1, y: 1 });
  const [ghosts, setGhosts] = useState([
    { x: 9, y: 8, color: 'red' },
    { x: 10, y: 8, color: 'pink' }
  ]);
  const [score, setScore] = useState(0);
  const [gameOver, setGameOver] = useState(false);
  const [direction, setDirection] = useState({ x: 0, y: 0 });

  const isValidMove = (x, y) => {
    return x >= 0 && x < COLS && y >= 0 && y < ROWS && maze[y][x] !== 1;
  };

  const moveGhosts = useCallback(() => {
    setGhosts(prevGhosts => 
      prevGhosts.map(ghost => {
        const directions = [
          { x: 0, y: -1 },
          { x: 0, y: 1 },
          { x: -1, y: 0 },
          { x: 1, y: 0 }
        ];
        
        const validMoves = directions.filter(dir => 
          isValidMove(ghost.x + dir.x, ghost.y + dir.y)
        );
        
        if (validMoves.length > 0) {
          const randomMove = validMoves[Math.floor(Math.random() * validMoves.length)];
          return {
            ...ghost,
            x: ghost.x + randomMove.x,
            y: ghost.y + randomMove.y
          };
        }
        return ghost;
      })
    );
  }, [maze]);

  const checkCollision = useCallback(() => {
    const collision = ghosts.some(ghost => 
      ghost.x === pacmanPos.x && ghost.y === pacmanPos.y
    );
    if (collision) {
      setGameOver(true);
    }
  }, [ghosts, pacmanPos]);

  const movePacman = useCallback(() => {
    if (direction.x === 0 && direction.y === 0) return;
    
    const newX = pacmanPos.x + direction.x;
    const newY = pacmanPos.y + direction.y;
    
    if (isValidMove(newX, newY)) {
      setPacmanPos({ x: newX, y: newY });
      
      if (maze[newY][newX] === 2) {
        setScore(prev => prev + 10);
        setMaze(prev => {
          const newMaze = [...prev];
          newMaze[newY] = [...newMaze[newY]];
          newMaze[newY][newX] = 0;
          return newMaze;
        });
      }
    }
  }, [direction, pacmanPos, maze]);

  useEffect(() => {
    const handleKeyPress = (e) => {
      if (gameOver) return;
      
      switch(e.key) {
        case 'ArrowUp':
          setDirection({ x: 0, y: -1 });
          break;
        case 'ArrowDown':
          setDirection({ x: 0, y: 1 });
          break;
        case 'ArrowLeft':
          setDirection({ x: -1, y: 0 });
          break;
        case 'ArrowRight':
          setDirection({ x: 1, y: 0 });
          break;
        default:
          break;
      }
    };

    window.addEventListener('keydown', handleKeyPress);
    return () => window.removeEventListener('keydown', handleKeyPress);
  }, [gameOver]);

  useEffect(() => {
    if (gameOver) return;
    
    const gameLoop = setInterval(() => {
      movePacman();
      moveGhosts();
    }, 200);

    return () => clearInterval(gameLoop);
  }, [movePacman, moveGhosts, gameOver]);

  useEffect(() => {
    checkCollision();
  }, [checkCollision]);

  const resetGame = () => {
    setMaze(initialMaze);
    setPacmanPos({ x: 1, y: 1 });
    setGhosts([
      { x: 9, y: 8, color: 'red' },
      { x: 10, y: 8, color: 'pink' }
    ]);
    setScore(0);
    setGameOver(false);
    setDirection({ x: 0, y: 0 });
  };

  const getCellContent = (x, y) => {
    if (pacmanPos.x === x && pacmanPos.y === y) {
      return 'üü°';
    }
    
    const ghost = ghosts.find(g => g.x === x && g.y === y);
    if (ghost) {
      return ghost.color === 'red' ? 'üëª' : 'üëπ';
    }
    
    switch(maze[y][
----------------------------------------


================================================================================
GAME GENERATION: shooter game - 2025-08-09 13:31:51.192977
================================================================================
FULL CLAUDE GENERATED CODE:
----------------------------------------
import React, { useState, useEffect, useCallback } from 'react';

const GameZone = ({ currentGame }) => {
  const [player, setPlayer] = useState({ x: 200, y: 250 });
  const [bullets, setBullets] = useState([]);
  const [enemies, setEnemies] = useState([]);
  const [score, setScore] = useState(0);
  const [gameRunning, setGameRunning] = useState(false);
  const [keys, setKeys] = useState({});

  const gameWidth = 400;
  const gameHeight = 300;

  const startGame = () => {
    setPlayer({ x: 200, y: 250 });
    setBullets([]);
    setEnemies([]);
    setScore(0);
    setGameRunning(true);
  };

  const resetGame = () => {
    setGameRunning(false);
    setPlayer({ x: 200, y: 250 });
    setBullets([]);
    setEnemies([]);
    setScore(0);
  };

  const handleKeyDown = useCallback((e) => {
    setKeys(prev => ({ ...prev, [e.key]: true }));
    if (e.key === ' ') {
      e.preventDefault();
      if (gameRunning) {
        setBullets(prev => [...prev, { x: player.x, y: player.y - 10, id: Date.now() }]);
      }
    }
  }, [gameRunning, player.x, player.y]);

  const handleKeyUp = useCallback((e) => {
    setKeys(prev => ({ ...prev, [e.key]: false }));
  }, []);

  useEffect(() => {
    window.addEventListener('keydown', handleKeyDown);
    window.addEventListener('keyup', handleKeyUp);
    return () => {
      window.removeEventListener('keydown', handleKeyDown);
      window.removeEventListener('keyup', handleKeyUp);
    };
  }, [handleKeyDown, handleKeyUp]);

  useEffect(() => {
    if (!gameRunning) return;

    const gameLoop = setInterval(() => {
      setPlayer(prev => {
        let newX = prev.x;
        if (keys['ArrowLeft'] && newX > 0) newX -= 5;
        if (keys['ArrowRight'] && newX < gameWidth - 20) newX += 5;
        return { ...prev, x: newX };
      });

      setBullets(prev => prev
        .map(bullet => ({ ...bullet, y: bullet.y - 8 }))
        .filter(bullet => bullet.y > 0)
      );

      setEnemies(prev => {
        let newEnemies = prev
          .map(enemy => ({ ...enemy, y: enemy.y + 2 }))
          .filter(enemy => enemy.y < gameHeight);
        
        if (Math.random() < 0.02) {
          newEnemies.push({
            x: Math.random() * (gameWidth - 20),
            y: 0,
            id: Date.now()
          });
        }
        
        return newEnemies;
      });

      setBullets(prevBullets => {
        setEnemies(prevEnemies => {
          let newEnemies = [...prevEnemies];
          let newBullets = [...prevBullets];
          
          prevBullets.forEach(bullet => {
            const hitEnemyIndex = newEnemies.findIndex(enemy => 
              bullet.x < enemy.x + 20 && bullet.x + 5 > enemy.x &&
              bullet.y < enemy.y + 20 && bullet.y + 5 > enemy.y
            );
            
            if (hitEnemyIndex !== -1) {
              newEnemies.splice(hitEnemyIndex, 1);
              newBullets = newBullets.filter(b => b.id !== bullet.id);
              setScore(prev => prev + 10);
            }
          });
          
          const playerHit = newEnemies.some(enemy =>
            player.x < enemy.x + 20 && player.x + 20 > enemy.x &&
            player.y < enemy.y + 20 && player.y + 20 > enemy.y
          );
          
          if (playerHit) {
            setGameRunning(false);
          }
          
          return newEnemies;
        });
        
        return prevBullets;
      });
    }, 50);

    return () => clearInterval(gameLoop);
  }, [gameRunning, keys, player.x, player.y]);

  return (
    <div style={{ textAlign: 'center', padding: '20px' }}>
      <h2>Shooter Game</h2>
      <div style={{ marginBottom: '10px' }}>
        <span>Score: {score}</span>
        <button onClick={startGame} style={{ marginLeft: '20px', marginRight: '10px' }}>
          Start
        </button>
        <button onClick={resetGame}>Reset</button>
      </div>
      
      <div style={{
        width: `${gameWidth}px`,
        height: `${gameHeight}px`,
        border: '2px solid #333',
        position: 'relative',
        backgroundColor: '#001122',
        margin: '0 auto',
        overflow: 'hidden'
      }}>
        <div style={{
          position: 'absolute',
          left: `${player.x}px`,
          top: `${player.y}px`,
          width: '20px',
          height: '20px',
          backgroundColor: '#00ff00',
          borderRadius: '3px'
        }} />
        
        {bullets.map(bullet => (
          <div key={bullet.id} style={{
            position: 'absolute',
            left: `${bullet.x}px`,
            top: `${bullet.y}px`,
            width: '5px',
            height: '10px',
            backgroundColor: '#ffff00',
            borderRadius: '2px'
          }} />
        ))}
        
        {enemies.map(enemy => (
          <div key={enemy.id} style={{
            position: 'absolute',
            left: `${enemy.x}px`,
            top: `${enemy.y}px`,
            width: '20px',
            height: '20px',
            backgroundColor: '#ff0000',
            borderRadius: '3px'
          }} />
        ))}
        
        {!gameRunning && (
          <div style={{
            position: 'absolute',
            top: '50%',
            left: '50%',
            transform: 'translate(-50%, -50%)',
            color: 'white',
            fontSize: '18px',
            fontWeight: 'bold'
          }}>
            {score > 0 ? `Game Over! Final Score: ${score}` : 'Press Start to Play'}
          </div>
        )}
      </div>
      
      <div style={{ marginTop: '10px', fontSize: '14px' }}>
        Use ‚Üê ‚Üí arrows to move, SPACE to shoot
      </div>
    </div>
  );
};

export default GameZone;
----------------------------------------


================================================================================
GAME GENERATION: chess - 2025-08-09 13:33:32.818454
================================================================================
FULL CLAUDE GENERATED CODE:
----------------------------------------
import React, { useState, useRef, useEffect } from 'react';

const GameZone = ({ currentGame }) => {
  const initialBoard = [
    ['r', 'n', 'b', 'q', 'k', 'b', 'n', 'r'],
    ['p', 'p', 'p', 'p', 'p', 'p', 'p', 'p'],
    [null, null, null, null, null, null, null, null],
    [null, null, null, null, null, null, null, null],
    [null, null, null, null, null, null, null, null],
    [null, null, null, null, null, null, null, null],
    ['P', 'P', 'P', 'P', 'P', 'P', 'P', 'P'],
    ['R', 'N', 'B', 'Q', 'K', 'B', 'N', 'R']
  ];

  const [board, setBoard] = useState(initialBoard);
  const [selectedSquare, setSelectedSquare] = useState(null);
  const [currentPlayer, setCurrentPlayer] = useState('white');
  const [gameStatus, setGameStatus] = useState('playing');

  const pieceSymbols = {
    'K': '‚ôî', 'Q': '‚ôï', 'R': '‚ôñ', 'B': '‚ôó', 'N': '‚ôò', 'P': '‚ôô',
    'k': '‚ôö', 'q': '‚ôõ', 'r': '‚ôú', 'b': '‚ôù', 'n': '‚ôû', 'p': '‚ôü'
  };

  const isWhitePiece = (piece) => piece && piece === piece.toUpperCase();
  const isBlackPiece = (piece) => piece && piece === piece.toLowerCase();

  const isValidMove = (fromRow, fromCol, toRow, toCol, piece) => {
    if (toRow < 0 || toRow > 7 || toCol < 0 || toCol > 7) return false;
    
    const targetPiece = board[toRow][toCol];
    if (targetPiece && 
        ((isWhitePiece(piece) && isWhitePiece(targetPiece)) ||
         (isBlackPiece(piece) && isBlackPiece(targetPiece)))) {
      return false;
    }

    const rowDiff = Math.abs(toRow - fromRow);
    const colDiff = Math.abs(toCol - fromCol);

    switch (piece.toLowerCase()) {
      case 'p':
        const direction = isWhitePiece(piece) ? -1 : 1;
        const startRow = isWhitePiece(piece) ? 6 : 1;
        
        if (toCol === fromCol) {
          if (toRow === fromRow + direction && !targetPiece) return true;
          if (fromRow === startRow && toRow === fromRow + 2 * direction && !targetPiece) return true;
        } else if (Math.abs(toCol - fromCol) === 1 && toRow === fromRow + direction && targetPiece) {
          return true;
        }
        return false;

      case 'r':
        if (fromRow === toRow || fromCol === toCol) {
          const stepRow = fromRow === toRow ? 0 : (toRow > fromRow ? 1 : -1);
          const stepCol = fromCol === toCol ? 0 : (toCol > fromCol ? 1 : -1);
          for (let i = 1; i < Math.max(rowDiff, colDiff); i++) {
            if (board[fromRow + i * stepRow][fromCol + i * stepCol]) return false;
          }
          return true;
        }
        return false;

      case 'n':
        return (rowDiff === 2 && colDiff === 1) || (rowDiff === 1 && colDiff === 2);

      case 'b':
        if (rowDiff === colDiff) {
          const stepRow = toRow > fromRow ? 1 : -1;
          const stepCol = toCol > fromCol ? 1 : -1;
          for (let i = 1; i < rowDiff; i++) {
            if (board[fromRow + i * stepRow][fromCol + i * stepCol]) return false;
          }
          return true;
        }
        return false;

      case 'q':
        if (fromRow === toRow || fromCol === toCol || rowDiff === colDiff) {
          const stepRow = fromRow === toRow ? 0 : (toRow > fromRow ? 1 : -1);
          const stepCol = fromCol === toCol ? 0 : (toCol > fromCol ? 1 : -1);
          for (let i = 1; i < Math.max(rowDiff, colDiff); i++) {
            if (board[fromRow + i * stepRow][fromCol + i * stepCol]) return false;
          }
          return true;
        }
        return false;

      case 'k':
        return rowDiff <= 1 && colDiff <= 1 && (rowDiff + colDiff > 0);

      default:
        return false;
    }
  };

  const handleSquareClick = (row, col) => {
    if (gameStatus !== 'playing') return;

    if (selectedSquare) {
      const [fromRow, fromCol] = selectedSquare;
      const piece = board[fromRow][fromCol];
      
      if (row === fromRow && col === fromCol) {
        setSelectedSquare(null);
        return;
      }

      if (piece && 
          ((currentPlayer === 'white' && isWhitePiece(piece)) ||
           (currentPlayer === 'black' && isBlackPiece(piece))) &&
          isValidMove(fromRow, fromCol, row, col, piece)) {
        
        const newBoard = board.map(r => [...r]);
        const capturedPiece = newBoard[row][col];
        newBoard[row][col] = piece;
        newBoard[fromRow][fromCol] = null;
        
        setBoard(newBoard);
        setSelectedSquare(null);
        setCurrentPlayer(currentPlayer === 'white' ? 'black' : 'white');

        if (capturedPiece && capturedPiece.toLowerCase() === 'k') {
          setGameStatus(`${currentPlayer} wins!`);
        }
      } else {
        setSelectedSquare(null);
      }
    } else {
      const piece = board[row][col];
      if (piece && 
          ((currentPlayer === 'white' && isWhitePiece(piece)) ||
           (currentPlayer === 'black' && isBlackPiece(piece)))) {
        setSelectedSquare([row, col]);
      }
    }
  };

  const resetGame = () => {
    setBoard(initialBoard.map(row => [...row]));
    setSelectedSquare(null);
    setCurrentPlayer('white');
    setGameStatus('playing');
  };

  return (
    <div style={{ 
      display: 'flex', 
      flexDirection: 'column', 
      alignItems: 'center', 
      padding: '20px',
      fontFamily: 'Arial, sans-serif'
    }}>
      <h2 style={{ margin: '0 0 10px 0', color: '#333' }}>Chess Game</h2>
      
      <div style={{ 
        marginBottom: '10px', 
        fontSize: '16px',
        fontWeight: 'bold'
      }}>
        {gameStatus === 'playing' ? `Current Player: ${currentPlayer}` : gameStatus}
      </div>

      <div style={{
        display: 'grid',
        gridTemplate
----------------------------------------


================================================================================
GAME GENERATION: flappy bird - 2025-08-09 13:34:58.374086
================================================================================
FULL CLAUDE GENERATED CODE:
----------------------------------------
import React, { useState, useEffect, useRef, useCallback } from 'react';

const GameZone = ({ currentGame }) => {
  const canvasRef = useRef(null);
  const gameLoopRef = useRef(null);
  const [score, setScore] = useState(0);
  const [gameState, setGameState] = useState('waiting');
  const [bird, setBird] = useState({ y: 150, velocity: 0 });
  const [pipes, setPipes] = useState([]);

  const CANVAS_WIDTH = 400;
  const CANVAS_HEIGHT = 300;
  const BIRD_SIZE = 20;
  const PIPE_WIDTH = 50;
  const PIPE_GAP = 100;
  const GRAVITY = 0.5;
  const JUMP_STRENGTH = -8;
  const PIPE_SPEED = 2;

  const resetGame = useCallback(() => {
    setBird({ y: 150, velocity: 0 });
    setPipes([]);
    setScore(0);
    setGameState('waiting');
  }, []);

  const startGame = useCallback(() => {
    setGameState('playing');
    setBird(prev => ({ ...prev, velocity: JUMP_STRENGTH }));
  }, []);

  const jump = useCallback(() => {
    if (gameState === 'playing') {
      setBird(prev => ({ ...prev, velocity: JUMP_STRENGTH }));
    } else if (gameState === 'waiting') {
      startGame();
    }
  }, [gameState, startGame]);

  const checkCollision = useCallback((birdY, pipes) => {
    if (birdY < 0 || birdY + BIRD_SIZE > CANVAS_HEIGHT) {
      return true;
    }

    const birdX = 50;
    for (let pipe of pipes) {
      if (birdX + BIRD_SIZE > pipe.x && birdX < pipe.x + PIPE_WIDTH) {
        if (birdY < pipe.topHeight || birdY + BIRD_SIZE > pipe.topHeight + PIPE_GAP) {
          return true;
        }
      }
    }
    return false;
  }, []);

  const updateGame = useCallback(() => {
    if (gameState !== 'playing') return;

    setBird(prev => {
      const newY = prev.y + prev.velocity;
      const newVelocity = prev.velocity + GRAVITY;
      return { y: newY, velocity: newVelocity };
    });

    setPipes(prev => {
      let newPipes = prev.map(pipe => ({ ...pipe, x: pipe.x - PIPE_SPEED }))
                        .filter(pipe => pipe.x + PIPE_WIDTH > 0);

      if (newPipes.length === 0 || newPipes[newPipes.length - 1].x < CANVAS_WIDTH - 200) {
        const topHeight = Math.random() * (CANVAS_HEIGHT - PIPE_GAP - 40) + 20;
        newPipes.push({
          x: CANVAS_WIDTH,
          topHeight: topHeight,
          scored: false
        });
      }

      newPipes.forEach(pipe => {
        if (!pipe.scored && pipe.x + PIPE_WIDTH < 50) {
          pipe.scored = true;
          setScore(s => s + 1);
        }
      });

      return newPipes;
    });
  }, [gameState]);

  useEffect(() => {
    const handleKeyPress = (e) => {
      if (e.code === 'Space') {
        e.preventDefault();
        jump();
      }
    };

    window.addEventListener('keydown', handleKeyPress);
    return () => window.removeEventListener('keydown', handleKeyPress);
  }, [jump]);

  useEffect(() => {
    if (gameState === 'playing') {
      if (checkCollision(bird.y, pipes)) {
        setGameState('gameOver');
        return;
      }
    }
  }, [bird.y, pipes, gameState, checkCollision]);

  useEffect(() => {
    if (gameState === 'playing') {
      gameLoopRef.current = setInterval(updateGame, 16);
    } else {
      if (gameLoopRef.current) {
        clearInterval(gameLoopRef.current);
      }
    }

    return () => {
      if (gameLoopRef.current) {
        clearInterval(gameLoopRef.current);
      }
    };
  }, [gameState, updateGame]);

  useEffect(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;

    const ctx = canvas.getContext('2d');
    ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

    ctx.fillStyle = '#87CEEB';
    ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

    pipes.forEach(pipe => {
      ctx.fillStyle = '#32CD32';
      ctx.fillRect(pipe.x, 0, PIPE_WIDTH, pipe.topHeight);
      ctx.fillRect(pipe.x, pipe.topHeight + PIPE_GAP, PIPE_WIDTH, CANVAS_HEIGHT - pipe.topHeight - PIPE_GAP);
    });

    ctx.fillStyle = '#FFD700';
    ctx.fillRect(50 - BIRD_SIZE/2, bird.y, BIRD_SIZE, BIRD_SIZE);

    ctx.fillStyle = '#000';
    ctx.font = '20px Arial';
    ctx.fillText(`Score: ${score}`, 10, 30);

    if (gameState === 'waiting') {
      ctx.fillStyle = 'rgba(0,0,0,0.7)';
      ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
      ctx.fillStyle = '#FFF';
      ctx.font = '24px Arial';
      ctx.textAlign = 'center';
      ctx.fillText('Click or Press Space to Start', CANVAS_WIDTH/2, CANVAS_HEIGHT/2);
      ctx.textAlign = 'left';
    }

    if (gameState === 'gameOver') {
      ctx.fillStyle = 'rgba(255,0,0,0.7)';
      ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
      ctx.fillStyle = '#FFF';
      ctx.font = '24px Arial';
      ctx.textAlign = 'center';
      ctx.fillText('Game Over!', CANVAS_WIDTH/2, CANVAS_HEIGHT/2 - 20);
      ctx.fillText(`Final Score: ${score}`, CANVAS_WIDTH/2, CANVAS_HEIGHT/2 + 20);
      ctx.textAlign = 'left';
    }
  }, [bird, pipes, score, gameState]);

  return (
    <div style={{ 
      display: 'flex', 
      flexDirection: 'column', 
      alignItems: 'center', 
      padding: '20px',
      fontFamily: 'Arial, sans-serif'
    }}>
      <h2 style={{ margin: '0 0 20px 0', color: '#333' }}>Flappy Bird</h2>
      
      <canvas
        ref={canvasRef}
        width={CANVAS_WIDTH}
        height={CANVAS_HEIGHT}
        onClick={jump}
        style={{ 
          border: '2px solid #333',
          cursor: 'pointer',
          display: 'block'
        }}
      />
      
      <div style={{ marginTop: '20px' }}>
        <button
          onClick={resetGame}
          style={{
            padding: '10px 20px',
            fontSize: '16px',
            backgroundColor: '#4CAF50',
            color: 'white',
            border: 'none',
            borderRadius: '5px',
            cursor: 'pointer',
            marginRight: '10px'
          }}
----------------------------------------


================================================================================
GAME GENERATION: pacmanbutmakethespacebarbarelymakeujump - 2025-08-09 13:46:31.135871
================================================================================
FULL CLAUDE GENERATED CODE:
----------------------------------------
import React, { useState, useEffect, useRef, useCallback } from 'react';

const GameZone = ({ currentGame }) => {
  const canvasRef = useRef(null);
  const [gameState, setGameState] = useState('playing');
  const [score, setScore] = useState(0);
  const [player, setPlayer] = useState({ x: 50, y: 250, velY: 0, onGround: true });
  const [dots, setDots] = useState([]);
  const [ghosts, setGhosts] = useState([]);

  const initializeGame = useCallback(() => {
    const newDots = [];
    for (let i = 0; i < 20; i++) {
      newDots.push({
        x: 100 + i * 15,
        y: 260,
        collected: false
      });
    }
    
    const newGhosts = [
      { x: 200, y: 240, dx: 1 },
      { x: 300, y: 240, dx: -1 }
    ];

    setDots(newDots);
    setGhosts(newGhosts);
    setPlayer({ x: 50, y: 250, velY: 0, onGround: true });
    setScore(0);
    setGameState('playing');
  }, []);

  useEffect(() => {
    initializeGame();
  }, [initializeGame]);

  useEffect(() => {
    const handleKeyPress = (e) => {
      if (e.code === 'Space' && player.onGround) {
        e.preventDefault();
        setPlayer(prev => ({ ...prev, velY: -8, onGround: false }));
      }
    };

    window.addEventListener('keydown', handleKeyPress);
    return () => window.removeEventListener('keydown', handleKeyPress);
  }, [player.onGround]);

  useEffect(() => {
    if (gameState !== 'playing') return;

    const gameLoop = setInterval(() => {
      setPlayer(prev => {
        let newY = prev.y + prev.velY;
        let newVelY = prev.velY + 0.5;
        let newOnGround = prev.onGround;

        if (newY >= 250) {
          newY = 250;
          newVelY = 0;
          newOnGround = true;
        } else {
          newOnGround = false;
        }

        return { ...prev, y: newY, velY: newVelY, onGround: newOnGround };
      });

      setGhosts(prev => prev.map(ghost => {
        let newX = ghost.x + ghost.dx;
        let newDx = ghost.dx;

        if (newX <= 80 || newX >= 350) {
          newDx = -ghost.dx;
          newX = ghost.x + newDx;
        }

        return { ...ghost, x: newX, dx: newDx };
      }));

      setDots(prev => {
        const newDots = prev.map(dot => {
          if (!dot.collected && 
              Math.abs(dot.x - player.x) < 15 && 
              Math.abs(dot.y - player.y) < 15) {
            setScore(s => s + 10);
            return { ...dot, collected: true };
          }
          return dot;
        });
        return newDots;
      });

      ghosts.forEach(ghost => {
        if (Math.abs(ghost.x - player.x) < 20 && Math.abs(ghost.y - player.y) < 20) {
          setGameState('gameOver');
        }
      });

      if (dots.every(dot => dot.collected)) {
        setGameState('won');
      }
    }, 16);

    return () => clearInterval(gameLoop);
  }, [gameState, player, ghosts, dots]);

  useEffect(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;

    const ctx = canvas.getContext('2d');
    ctx.clearRect(0, 0, 400, 300);

    ctx.fillStyle = '#000';
    ctx.fillRect(0, 0, 400, 300);

    ctx.fillStyle = '#0f0';
    ctx.fillRect(0, 270, 400, 30);

    ctx.fillStyle = '#ff0';
    ctx.beginPath();
    ctx.arc(player.x, player.y, 10, 0.2 * Math.PI, 1.8 * Math.PI);
    ctx.lineTo(player.x, player.y);
    ctx.fill();

    dots.forEach(dot => {
      if (!dot.collected) {
        ctx.fillStyle = '#ff0';
        ctx.beginPath();
        ctx.arc(dot.x, dot.y, 3, 0, 2 * Math.PI);
        ctx.fill();
      }
    });

    ghosts.forEach(ghost => {
      ctx.fillStyle = '#f0f';
      ctx.fillRect(ghost.x - 10, ghost.y - 10, 20, 20);
      ctx.fillStyle = '#fff';
      ctx.fillRect(ghost.x - 6, ghost.y - 8, 4, 4);
      ctx.fillRect(ghost.x + 2, ghost.y - 8, 4, 4);
    });
  }, [player, dots, ghosts]);

  return (
    <div style={{ display: 'flex', flexDirection: 'column', alignItems: 'center', padding: '20px' }}>
      <h2 style={{ margin: '0 0 10px 0', color: '#333' }}>Pac-Jump</h2>
      <div style={{ marginBottom: '10px', fontSize: '18px', fontWeight: 'bold' }}>
        Score: {score}
      </div>
      <canvas
        ref={canvasRef}
        width={400}
        height={300}
        style={{ border: '2px solid #333', backgroundColor: '#000' }}
      />
      <div style={{ marginTop: '10px', textAlign: 'center' }}>
        <div style={{ marginBottom: '10px', fontSize: '14px' }}>
          Press SPACEBAR to barely jump! Collect dots, avoid ghosts!
        </div>
        {gameState === 'gameOver' && (
          <div style={{ color: 'red', fontWeight: 'bold', marginBottom: '10px' }}>
            Game Over! Ghost got you!
          </div>
        )}
        {gameState === 'won' && (
          <div style={{ color: 'green', fontWeight: 'bold', marginBottom: '10px' }}>
            You Won! All dots collected!
          </div>
        )}
        <button
          onClick={initializeGame}
          style={{
            padding: '10px 20px',
            fontSize: '16px',
            backgroundColor: '#4CAF50',
            color: 'white',
            border: 'none',
            borderRadius: '5px',
            cursor: 'pointer'
          }}
        >
          {gameState === 'playing' ? 'Restart' : 'Play Again'}
        </button>
      </div>
    </div>
  );
};

export default GameZone;
----------------------------------------

