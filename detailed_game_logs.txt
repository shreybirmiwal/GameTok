
================================================================================
GAME GENERATION: tiktactoe - 2025-08-09 13:07:10.523781
================================================================================
FULL CLAUDE GENERATED CODE:
----------------------------------------
```
<div style="text-align: center; padding: 20px;">
  <h3>üéÆ Tic Tac Toe</h3>
  <canvas id="game_tiktactoe_canvas" width="400" height="300" style="border: 2px solid #333; background: #fff; cursor: pointer;"></canvas>
  <div style="margin: 10px 0;">
    <strong>Current Player: <span id="game_tiktactoe_player">X</span></strong>
  </div>
  <div style="font-size: 12px; color: #666;">
    Controls: Click on squares to place X or O
  </div>
</div>
<script>
const tiktactoe_canvas = document.getElementById('game_tiktactoe_canvas');
const tiktactoe_ctx = tiktactoe_canvas.getContext('2d');
const tiktactoe_playerSpan = document.getElementById('game_tiktactoe_player');

let tiktactoe_board = [['', '', ''], ['', '', ''], ['', '', '']];
let tiktactoe_currentPlayer = 'X';
let tiktactoe_gameOver = false;

function tiktactoe_drawBoard() {
  tiktactoe_ctx.clearRect(0, 0, 400, 300);
  
  // Draw grid lines
  tiktactoe_ctx.strokeStyle = '#333';
  tiktactoe_ctx.lineWidth = 3;
  
  // Vertical lines
  tiktactoe_ctx.beginPath();
  tiktactoe_ctx.moveTo(133, 0);
  tiktactoe_ctx.lineTo(133, 300);
  tiktactoe_ctx.moveTo(267, 0);
  tiktactoe_ctx.lineTo(267, 300);
  tiktactoe_ctx.stroke();
  
  // Horizontal lines
  tiktactoe_ctx.beginPath();
  tiktactoe_ctx.moveTo(0, 100);
  tiktactoe_ctx.lineTo(400, 100);
  tiktactoe_ctx.moveTo(0, 200);
  tiktactoe_ctx.lineTo(400, 200);
  tiktactoe_ctx.stroke();
  
  // Draw X's and O's
  tiktactoe_ctx.font = '60px Arial';
  tiktactoe_ctx.textAlign = 'center';
  tiktactoe_ctx.textBaseline = 'middle';
  
  for (let row = 0; row < 3; row++) {
    for (let col = 0; col < 3; col++) {
      if (tiktactoe_board[row][col] === 'X') {
        tiktactoe_ctx.fillStyle = '#e74c3c';
        tiktactoe_ctx.fillText('X', col * 133 + 66, row * 100 + 50);
      } else if (tiktactoe_board[row][col] === 'O') {
        tiktactoe_ctx.fillStyle = '#3498db';
        tiktactoe_ctx.fillText('O', col * 133 + 66, row * 100 + 50);
      }
    }
  }
}

function tiktactoe_checkWinner() {
  // Check rows
  for (let row = 0; row < 3; row++) {
    if (tiktactoe_board[row][0] && tiktactoe_board[row][0] === tiktactoe_board[row][1] && tiktactoe_board[row][1] === tiktactoe_board[row][2]) {
      return tiktactoe_board[row][0];
    }
  }
  
  // Check columns
  for (let col = 0; col < 3; col++) {
    if (tiktactoe_board[0][col] && tiktactoe_board[0][col] === tiktactoe_board[1][col] && tiktactoe_board[1][col] === tiktactoe_board[2][col]) {
      return tiktactoe_board[0][col];
    }
  }
  
  // Check diagonals
  if (tiktactoe_board[0][0] && tiktactoe_board[0][0] === tiktactoe_board[1][1] && tiktactoe_board[1][1] === tiktactoe_board[2][2]) {
    return tiktactoe_board[0][0];
  }
  if (tiktactoe_board[0][2] && tiktactoe_board[0][2] === tiktactoe_board[1][1] && tiktactoe_board[1][1] === tiktactoe_board[2][0]) {
    return tiktactoe_board[0][2];
  }
  
  // Check for tie
  let isFull = true;
  for (let row = 0; row < 3; row++) {
    for (let col = 0; col < 3; col++) {
      if (tiktactoe_board[row][col] === '') {
        isFull = false;
        break;
      }
    }
  }
  
  return isFull ? 'tie' : null;
}

function tiktactoe_resetGame() {
  tiktactoe_board = [['', '', ''], ['', '', ''], ['', '', '']];
  tiktactoe_currentPlayer = 'X';
  tiktactoe_gameOver = false;
  tiktactoe_playerSpan.textContent = 'X';
  tiktactoe_drawBoard();
}

tiktactoe_canvas.addEventListener('click', function(e) {
  if (tiktactoe_gameOver) {
    tiktactoe_resetGame();
    return;
  }
  
  const rect = tiktactoe_canvas.getBoundingClientRect();
  const x = e.clientX - rect.left;
  const y = e.clientY - rect.top;
  
  const col = Math.floor(x / 133);
  const row = Math.floor(y / 100);
  
  if (row >= 0 && row < 3 && col >= 0 && col < 3 && tiktactoe_board[row][col] === '') {
    tiktactoe_board[row][col] = tiktactoe_currentPlayer;
    
    const winner = tiktactoe_checkWinner();
    if (winner) {
      tiktactoe_gameOver = true;
      if (winner === 'tie') {
        tiktactoe_playerSpan.textContent = "It's a Tie! Click to restart";
      } else {
        tiktactoe_playerSpan.textContent = winner + " Wins! Click to restart";
      }
    } else {
      tiktactoe_currentPlayer = tiktactoe_currentPlayer === 'X' ? 'O' : 'X';
      tiktactoe_playerSpan.textContent = tiktactoe_currentPlayer;
    }
    
    tiktactoe_drawBoard();
  }
});

tiktactoe_drawBoard();
</script>
```
----------------------------------------

MORPH BEFORE/AFTER COMPARISON:
----------------------------------------
BEFORE (GameZone.js):
import React from 'react';

const GameZone = ({ currentGame }) => {
  // Simple HTML content zone - perfect for Morph apply!
  // Just put your HTML game content here and it will render
  // this is the html content that will be rendered in the game zone ONLY CHANGE THIS ZONE
  // MORPH: ONLY replace the content between these backticks - keep everything else the same
  const htmlContent = `
    <div style="text-align: center; padding: 20px;">
      <h2>üéÆ HTML Game Zone</h2>
      <p>This is where your HTML5 Canvas games will appear!</p>
      <div style="background: linear-gradient(45deg, #ff6b6b, #4ecdc4); padding: 20px; border-radius: 10px; color: white; margin: 20px 0;">
        <strong>Perfect for Morph Apply!</strong><br/>
        Just replace the htmlContent variable above with your generated HTML5 game code
      </div>
      <div style="border: 2px dashed #ccc; padding: 40px; margin: 20px 0; border-radius: 8px;">
        <p style="color: #666; font-style: italic;">
          üéØ Game content will render here<br/>
          üìù Use Morph to apply HTML5 Canvas games directly<br/>
          üöÄ No complex React components needed!
        </p>
      </div>
      <p style="font-size: 12px; color: #888;">
        Current game: ${currentGame || 'None selected'}
      </p>
    </div>
  `;

  return (
    <div className="game-zone">
      <div className="game-content">
        <div dangerouslySetInnerHTML={{ __html: htmlContent }} />
      </div>
    </div>
  );
};

export default GameZone;

AFTER (GameZone.js):
import React from 'react';

const GameZone = ({ currentGame }) => {
  // Simple HTML content zone - perfect for Morph apply!
  // Just put your HTML game content here and it will render
  // this is the html content that will be rendered in the game zone ONLY CHANGE THIS ZONE
  // MORPH: ONLY replace the content between these backticks - keep everything else the same
  const htmlContent = `
<div style="text-align: center; padding: 20px;">
  <h3>üéÆ Tic Tac Toe</h3>
  <canvas id="game_tiktactoe_canvas" width="400" height="300" style="border: 2px solid #333; background: #fff; cursor: pointer;"></canvas>
  <div style="margin: 10px 0;">
    <strong>Current Player: <span id="game_tiktactoe_player">X</span></strong>
  </div>
  <div style="font-size: 12px; color: #666;">
    Controls: Click on squares to place X or O
  </div>
</div>
<script>
const tiktactoe_canvas = document.getElementById('game_tiktactoe_canvas');
const tiktactoe_ctx = tiktactoe_canvas.getContext('2d');
const tiktactoe_playerSpan = document.getElementById('game_tiktactoe_player');

let tiktactoe_board = [['', '', ''], ['', '', ''], ['', '', '']];
let tiktactoe_currentPlayer = 'X';
let tiktactoe_gameOver = false;

function tiktactoe_drawBoard() {
  tiktactoe_ctx.clearRect(0, 0, 400, 300);
  
  // Draw grid lines
  tiktactoe_ctx.strokeStyle = '#333';
  tiktactoe_ctx.lineWidth = 3;
  
  // Vertical lines
  tiktactoe_ctx.beginPath();
  tiktactoe_ctx.moveTo(133, 0);
  tiktactoe_ctx.lineTo(133, 300);
  tiktactoe_ctx.moveTo(267, 0);
  tiktactoe_ctx.lineTo(267, 300);
  tiktactoe_ctx.stroke();
  
  // Horizontal lines
  tiktactoe_ctx.beginPath();
  tiktactoe_ctx.moveTo(0, 100);
  tiktactoe_ctx.lineTo(400, 100);
  tiktactoe_ctx.moveTo(0, 200);
  tiktactoe_ctx.lineTo(400, 200);
  tiktactoe_ctx.stroke();
  
  // Draw X's and O's
  tiktactoe_ctx.font = '60px Arial';
  tiktactoe_ctx.textAlign = 'center';
  tiktactoe_ctx.textBaseline = 'middle';
  
  for (let row = 0; row < 3; row++) {
    for (let col = 0; col < 3; col++) {
      if (tiktactoe_board[row][col] === 'X') {
        tiktactoe_ctx.fillStyle = '#e74c3c';
        tiktactoe_ctx.fillText('X', col * 133 + 66, row * 100 + 50);
      } else if (tiktactoe_board[row][col] === 'O') {
        tiktactoe_ctx.fillStyle = '#3498db';
        tiktactoe_ctx.fillText('O', col * 133 + 66, row * 100 + 50);
      }
    }
  }
}

function tiktactoe_checkWinner() {
  // Check rows
  for (let row = 0; row < 3; row++) {
    if (tiktactoe_board[row][0] && tiktactoe_board[row][0] === tiktactoe_board[row][1] && tiktactoe_board[row][1] === tiktactoe_board[row][2]) {
      return tiktactoe_board[row][0];
    }
  }
  
  // Check columns
  for (let col = 0; col < 3; col++) {
    if (tiktactoe_board[0][col] && tiktactoe_board[0][col] === tiktactoe_board[1][col] && tiktactoe_board[1][col] === tiktactoe_board[2][col]) {
      return tiktactoe_board[0][col];
    }
  }
  
  // Check diagonals
  if (tiktactoe_board[0][0] && tiktactoe_board[0][0] === tiktactoe_board[1][1] && tiktactoe_board[1][1] === tiktactoe_board[2][2]) {
    return tiktactoe_board[0][0];
  }
  if (tiktactoe_board[0][2] && tiktactoe_board[0][2] === tiktactoe_board[1][1] && tiktactoe_board[1][1] === tiktactoe_board[2][0]) {
    return tiktactoe_board[0][2];
  }
  
  // Check for tie
  let isFull = true;
  for (let row = 0; row < 3; row++) {
    for (let col = 0; col < 3; col++) {
      if (tiktactoe_board[row][col] === '') {
        isFull = false;
        break;
      }
    }
  }
  
  return isFull ? 'tie' : null;
}

function tiktactoe_resetGame() {
  tiktactoe_board = [['', '', ''], ['', '', ''], ['', '', '']];
  tiktactoe_currentPlayer = 'X';
  tiktactoe_gameOver = false;
  tiktactoe_playerSpan.textContent = 'X';
  tiktactoe_drawBoard();
}

tiktactoe_canvas.addEventListener('click', function(e) {
  if (tiktactoe_gameOver) {
    tiktactoe_resetGame();
    return;
  }
  
  const rect = tiktactoe_canvas.getBoundingClientRect();
  const x = e.clientX - rect.left;
  const y = e.clientY - rect.top;
  
  const col = Math.floor(x / 133);
  const row = Math.floor(y / 100);
  
  if (row >= 0 && row < 3 && col >= 0 && col < 3 && tiktactoe_board[row][col] === '') {
    tiktactoe_board[row][col] = tiktactoe_currentPlayer;
    
    const winner = tiktactoe_checkWinner();
    if (winner) {
      tiktactoe_gameOver = true;
      if (winner === 'tie') {
        tiktactoe_playerSpan.textContent = "It's a Tie! Click to restart";
      } else {
        tiktactoe_playerSpan.textContent = winner + " Wins! Click to restart";
      }
    } else {
      tiktactoe_currentPlayer = tiktactoe_currentPlayer === 'X' ? 'O' : 'X';
      tiktactoe_playerSpan.textContent = tiktactoe_currentPlayer;
    }
    
    tiktactoe_drawBoard();
  }
});

tiktactoe_drawBoard();
</script>
`;

  return (
    <div className="game-zone">
      <div className="game-content">
        <div dangerouslySetInnerHTML={{ __html: htmlContent }} />
      </div>
    </div>
  );
};

export default GameZone;

================================================================================


================================================================================
GAME GENERATION: tik tak toe - 2025-08-09 13:18:54.732414
================================================================================
FULL CLAUDE GENERATED CODE:
----------------------------------------
```javascript
import React, { useState } from 'react';

const GameZone = ({ currentGame }) => {
  const [board, setBoard] = useState(Array(9).fill(null));
  const [isXNext, setIsXNext] = useState(true);
  const [winner, setWinner] = useState(null);

  const checkWinner = (squares) => {
    const lines = [
      [0, 1, 2],
      [3, 4, 5],
      [6, 7, 8],
      [0, 3, 6],
      [1, 4, 7],
      [2, 5, 8],
      [0, 4, 8],
      [2, 4, 6],
    ];
    for (let i = 0; i < lines.length; i++) {
      const [a, b, c] = lines[i];
      if (squares[a] && squares[a] === squares[b] && squares[a] === squares[c]) {
        return squares[a];
      }
    }
    return null;
  };

  const handleClick = (index) => {
    if (board[index] || winner) return;
    
    const newBoard = [...board];
    newBoard[index] = isXNext ? 'X' : 'O';
    setBoard(newBoard);
    
    const gameWinner = checkWinner(newBoard);
    if (gameWinner) {
      setWinner(gameWinner);
    } else {
      setIsXNext(!isXNext);
    }
  };

  const resetGame = () => {
    setBoard(Array(9).fill(null));
    setIsXNext(true);
    setWinner(null);
  };

  const isDraw = !winner && board.every(square => square !== null);

  const renderSquare = (index) => (
    <button
      key={index}
      onClick={() => handleClick(index)}
      style={{
        width: '80px',
        height: '80px',
        fontSize: '24px',
        fontWeight: 'bold',
        border: '2px solid #333',
        backgroundColor: '#fff',
        cursor: 'pointer',
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'center'
      }}
    >
      {board[index]}
    </button>
  );

  return (
    <div style={{
      display: 'flex',
      flexDirection: 'column',
      alignItems: 'center',
      padding: '20px',
      fontFamily: 'Arial, sans-serif'
    }}>
      <h2 style={{ marginBottom: '20px' }}>Tic Tac Toe</h2>
      
      <div style={{
        display: 'grid',
        gridTemplate: 'repeat(3, 80px) / repeat(3, 80px)',
        gap: '2px',
        marginBottom: '20px',
        border: '2px solid #333'
      }}>
        {Array(9).fill(null).map((_, index) => renderSquare(index))}
      </div>

      <div style={{ textAlign: 'center', marginBottom: '20px' }}>
        {winner ? (
          <h3 style={{ color: 'green' }}>Winner: {winner}!</h3>
        ) : isDraw ? (
          <h3 style={{ color: 'orange' }}>It's a Draw!</h3>
        ) : (
          <h3>Next Player: {isXNext ? 'X' : 'O'}</h3>
        )}
      </div>

      <button
        onClick={resetGame}
        style={{
          padding: '10px 20px',
          fontSize: '16px',
          backgroundColor: '#007bff',
          color: 'white',
          border: 'none',
          borderRadius: '5px',
          cursor: 'pointer'
        }}
      >
        Reset Game
      </button>
    </div>
  );
};

export default GameZone;
```
----------------------------------------


================================================================================
GAME GENERATION: car game - 2025-08-09 13:26:47.780186
================================================================================
FULL CLAUDE GENERATED CODE:
----------------------------------------
import React, { useState, useEffect, useRef, useCallback } from 'react';

const GameZone = ({ currentGame }) => {
  const canvasRef = useRef(null);
  const [gameState, setGameState] = useState('playing');
  const [score, setScore] = useState(0);
  const [car, setCar] = useState({ x: 175, y: 250, width: 50, height: 30 });
  const [obstacles, setObstacles] = useState([]);
  const [keys, setKeys] = useState({});

  const gameWidth = 400;
  const gameHeight = 300;
  const carSpeed = 5;
  const obstacleSpeed = 3;

  const resetGame = useCallback(() => {
    setCar({ x: 175, y: 250, width: 50, height: 30 });
    setObstacles([]);
    setScore(0);
    setGameState('playing');
  }, []);

  const checkCollision = (rect1, rect2) => {
    return rect1.x < rect2.x + rect2.width &&
           rect1.x + rect1.width > rect2.x &&
           rect1.y < rect2.y + rect2.height &&
           rect1.y + rect1.height > rect2.y;
  };

  const gameLoop = useCallback(() => {
    if (gameState !== 'playing') return;

    setCar(prevCar => {
      let newX = prevCar.x;
      if (keys['ArrowLeft'] && newX > 0) newX -= carSpeed;
      if (keys['ArrowRight'] && newX < gameWidth - prevCar.width) newX += carSpeed;
      return { ...prevCar, x: newX };
    });

    setObstacles(prevObstacles => {
      let newObstacles = prevObstacles.map(obs => ({
        ...obs,
        y: obs.y + obstacleSpeed
      })).filter(obs => obs.y < gameHeight);

      if (Math.random() < 0.02) {
        newObstacles.push({
          x: Math.random() * (gameWidth - 40),
          y: -30,
          width: 40,
          height: 30
        });
      }

      return newObstacles;
    });

    setScore(prevScore => prevScore + 1);
  }, [gameState, keys]);

  useEffect(() => {
    const handleKeyDown = (e) => {
      setKeys(prev => ({ ...prev, [e.key]: true }));
    };

    const handleKeyUp = (e) => {
      setKeys(prev => ({ ...prev, [e.key]: false }));
    };

    window.addEventListener('keydown', handleKeyDown);
    window.addEventListener('keyup', handleKeyUp);

    return () => {
      window.removeEventListener('keydown', handleKeyDown);
      window.removeEventListener('keyup', handleKeyUp);
    };
  }, []);

  useEffect(() => {
    const interval = setInterval(gameLoop, 50);
    return () => clearInterval(interval);
  }, [gameLoop]);

  useEffect(() => {
    obstacles.forEach(obstacle => {
      if (checkCollision(car, obstacle)) {
        setGameState('gameOver');
      }
    });
  }, [car, obstacles]);

  useEffect(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;

    const ctx = canvas.getContext('2d');
    ctx.clearRect(0, 0, gameWidth, gameHeight);

    ctx.fillStyle = '#333';
    ctx.fillRect(0, 0, gameWidth, gameHeight);

    for (let i = 0; i < gameWidth; i += 40) {
      ctx.fillStyle = '#666';
      ctx.fillRect(i + 18, 0, 4, gameHeight);
    }

    ctx.fillStyle = '#00ff00';
    ctx.fillRect(car.x, car.y, car.width, car.height);

    ctx.fillStyle = '#ff0000';
    obstacles.forEach(obstacle => {
      ctx.fillRect(obstacle.x, obstacle.y, obstacle.width, obstacle.height);
    });
  });

  return (
    <div style={{ 
      display: 'flex', 
      flexDirection: 'column', 
      alignItems: 'center', 
      padding: '20px',
      fontFamily: 'Arial, sans-serif'
    }}>
      <h2 style={{ margin: '0 0 10px 0' }}>Simple Car Game</h2>
      <div style={{ marginBottom: '10px' }}>
        Score: {score} | Status: {gameState}
      </div>
      
      <canvas
        ref={canvasRef}
        width={gameWidth}
        height={gameHeight}
        style={{
          border: '2px solid #000',
          backgroundColor: '#333'
        }}
      />
      
      <div style={{ marginTop: '15px' }}>
        <button 
          onClick={resetGame}
          style={{
            padding: '10px 20px',
            fontSize: '16px',
            backgroundColor: '#4CAF50',
            color: 'white',
            border: 'none',
            borderRadius: '5px',
            cursor: 'pointer',
            marginRight: '10px'
          }}
        >
          {gameState === 'gameOver' ? 'Play Again' : 'Restart'}
        </button>
      </div>
      
      <div style={{ 
        marginTop: '15px', 
        textAlign: 'center',
        fontSize: '14px',
        color: '#666'
      }}>
        Use arrow keys to move left and right<br/>
        Avoid the red obstacles!
      </div>
      
      {gameState === 'gameOver' && (
        <div style={{
          marginTop: '15px',
          padding: '10px',
          backgroundColor: '#ffebee',
          border: '1px solid #f44336',
          borderRadius: '5px',
          color: '#d32f2f',
          fontWeight: 'bold'
        }}>
          Game Over! Final Score: {score}
        </div>
      )}
    </div>
  );
};

export default GameZone;
----------------------------------------


================================================================================
GAME GENERATION: pacman - 2025-08-09 13:28:01.148852
================================================================================
FULL CLAUDE GENERATED CODE:
----------------------------------------
import React, { useState, useEffect, useCallback } from 'react';

const GameZone = ({ currentGame }) => {
  const GRID_SIZE = 20;
  const ROWS = 15;
  const COLS = 20;
  
  const initialMaze = [
    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
    [1,2,2,2,2,2,2,2,2,1,1,2,2,2,2,2,2,2,2,1],
    [1,2,1,1,2,1,1,1,2,1,1,2,1,1,1,2,1,1,2,1],
    [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1],
    [1,2,1,1,2,1,2,1,1,1,1,1,1,2,1,2,1,1,2,1],
    [1,2,2,2,2,1,2,2,2,1,1,2,2,2,1,2,2,2,2,1],
    [1,1,1,1,2,1,1,1,0,1,1,0,1,1,1,2,1,1,1,1],
    [0,0,0,1,2,1,0,0,0,0,0,0,0,0,1,2,1,0,0,0],
    [1,1,1,1,2,1,0,1,1,0,0,1,1,0,1,2,1,1,1,1],
    [1,2,2,2,2,2,0,1,0,0,0,0,1,0,2,2,2,2,2,1],
    [1,2,1,1,2,1,0,1,1,1,1,1,1,0,1,2,1,1,2,1],
    [1,2,2,2,2,1,2,2,2,1,1,2,2,2,1,2,2,2,2,1],
    [1,1,1,2,2,2,2,1,2,1,1,2,1,2,2,2,2,1,1,1],
    [1,2,2,2,2,2,2,1,2,2,2,2,1,2,2,2,2,2,2,1],
    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
  ];

  const [maze, setMaze] = useState(initialMaze);
  const [pacmanPos, setPacmanPos] = useState({ x: 1, y: 1 });
  const [ghosts, setGhosts] = useState([
    { x: 9, y: 8, color: 'red' },
    { x: 10, y: 8, color: 'pink' }
  ]);
  const [score, setScore] = useState(0);
  const [gameOver, setGameOver] = useState(false);
  const [direction, setDirection] = useState({ x: 0, y: 0 });

  const isValidMove = (x, y) => {
    return x >= 0 && x < COLS && y >= 0 && y < ROWS && maze[y][x] !== 1;
  };

  const moveGhosts = useCallback(() => {
    setGhosts(prevGhosts => 
      prevGhosts.map(ghost => {
        const directions = [
          { x: 0, y: -1 },
          { x: 0, y: 1 },
          { x: -1, y: 0 },
          { x: 1, y: 0 }
        ];
        
        const validMoves = directions.filter(dir => 
          isValidMove(ghost.x + dir.x, ghost.y + dir.y)
        );
        
        if (validMoves.length > 0) {
          const randomMove = validMoves[Math.floor(Math.random() * validMoves.length)];
          return {
            ...ghost,
            x: ghost.x + randomMove.x,
            y: ghost.y + randomMove.y
          };
        }
        return ghost;
      })
    );
  }, [maze]);

  const checkCollision = useCallback(() => {
    const collision = ghosts.some(ghost => 
      ghost.x === pacmanPos.x && ghost.y === pacmanPos.y
    );
    if (collision) {
      setGameOver(true);
    }
  }, [ghosts, pacmanPos]);

  const movePacman = useCallback(() => {
    if (direction.x === 0 && direction.y === 0) return;
    
    const newX = pacmanPos.x + direction.x;
    const newY = pacmanPos.y + direction.y;
    
    if (isValidMove(newX, newY)) {
      setPacmanPos({ x: newX, y: newY });
      
      if (maze[newY][newX] === 2) {
        setScore(prev => prev + 10);
        setMaze(prev => {
          const newMaze = [...prev];
          newMaze[newY] = [...newMaze[newY]];
          newMaze[newY][newX] = 0;
          return newMaze;
        });
      }
    }
  }, [direction, pacmanPos, maze]);

  useEffect(() => {
    const handleKeyPress = (e) => {
      if (gameOver) return;
      
      switch(e.key) {
        case 'ArrowUp':
          setDirection({ x: 0, y: -1 });
          break;
        case 'ArrowDown':
          setDirection({ x: 0, y: 1 });
          break;
        case 'ArrowLeft':
          setDirection({ x: -1, y: 0 });
          break;
        case 'ArrowRight':
          setDirection({ x: 1, y: 0 });
          break;
        default:
          break;
      }
    };

    window.addEventListener('keydown', handleKeyPress);
    return () => window.removeEventListener('keydown', handleKeyPress);
  }, [gameOver]);

  useEffect(() => {
    if (gameOver) return;
    
    const gameLoop = setInterval(() => {
      movePacman();
      moveGhosts();
    }, 200);

    return () => clearInterval(gameLoop);
  }, [movePacman, moveGhosts, gameOver]);

  useEffect(() => {
    checkCollision();
  }, [checkCollision]);

  const resetGame = () => {
    setMaze(initialMaze);
    setPacmanPos({ x: 1, y: 1 });
    setGhosts([
      { x: 9, y: 8, color: 'red' },
      { x: 10, y: 8, color: 'pink' }
    ]);
    setScore(0);
    setGameOver(false);
    setDirection({ x: 0, y: 0 });
  };

  const getCellContent = (x, y) => {
    if (pacmanPos.x === x && pacmanPos.y === y) {
      return 'üü°';
    }
    
    const ghost = ghosts.find(g => g.x === x && g.y === y);
    if (ghost) {
      return ghost.color === 'red' ? 'üëª' : 'üëπ';
    }
    
    switch(maze[y][
----------------------------------------

