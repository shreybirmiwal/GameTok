
================================================================================
GAME GENERATION: tiktactoe - 2025-08-09 13:07:10.523781
================================================================================
FULL CLAUDE GENERATED CODE:
----------------------------------------
```
<div style="text-align: center; padding: 20px;">
  <h3>üéÆ Tic Tac Toe</h3>
  <canvas id="game_tiktactoe_canvas" width="400" height="300" style="border: 2px solid #333; background: #fff; cursor: pointer;"></canvas>
  <div style="margin: 10px 0;">
    <strong>Current Player: <span id="game_tiktactoe_player">X</span></strong>
  </div>
  <div style="font-size: 12px; color: #666;">
    Controls: Click on squares to place X or O
  </div>
</div>
<script>
const tiktactoe_canvas = document.getElementById('game_tiktactoe_canvas');
const tiktactoe_ctx = tiktactoe_canvas.getContext('2d');
const tiktactoe_playerSpan = document.getElementById('game_tiktactoe_player');

let tiktactoe_board = [['', '', ''], ['', '', ''], ['', '', '']];
let tiktactoe_currentPlayer = 'X';
let tiktactoe_gameOver = false;

function tiktactoe_drawBoard() {
  tiktactoe_ctx.clearRect(0, 0, 400, 300);
  
  // Draw grid lines
  tiktactoe_ctx.strokeStyle = '#333';
  tiktactoe_ctx.lineWidth = 3;
  
  // Vertical lines
  tiktactoe_ctx.beginPath();
  tiktactoe_ctx.moveTo(133, 0);
  tiktactoe_ctx.lineTo(133, 300);
  tiktactoe_ctx.moveTo(267, 0);
  tiktactoe_ctx.lineTo(267, 300);
  tiktactoe_ctx.stroke();
  
  // Horizontal lines
  tiktactoe_ctx.beginPath();
  tiktactoe_ctx.moveTo(0, 100);
  tiktactoe_ctx.lineTo(400, 100);
  tiktactoe_ctx.moveTo(0, 200);
  tiktactoe_ctx.lineTo(400, 200);
  tiktactoe_ctx.stroke();
  
  // Draw X's and O's
  tiktactoe_ctx.font = '60px Arial';
  tiktactoe_ctx.textAlign = 'center';
  tiktactoe_ctx.textBaseline = 'middle';
  
  for (let row = 0; row < 3; row++) {
    for (let col = 0; col < 3; col++) {
      if (tiktactoe_board[row][col] === 'X') {
        tiktactoe_ctx.fillStyle = '#e74c3c';
        tiktactoe_ctx.fillText('X', col * 133 + 66, row * 100 + 50);
      } else if (tiktactoe_board[row][col] === 'O') {
        tiktactoe_ctx.fillStyle = '#3498db';
        tiktactoe_ctx.fillText('O', col * 133 + 66, row * 100 + 50);
      }
    }
  }
}

function tiktactoe_checkWinner() {
  // Check rows
  for (let row = 0; row < 3; row++) {
    if (tiktactoe_board[row][0] && tiktactoe_board[row][0] === tiktactoe_board[row][1] && tiktactoe_board[row][1] === tiktactoe_board[row][2]) {
      return tiktactoe_board[row][0];
    }
  }
  
  // Check columns
  for (let col = 0; col < 3; col++) {
    if (tiktactoe_board[0][col] && tiktactoe_board[0][col] === tiktactoe_board[1][col] && tiktactoe_board[1][col] === tiktactoe_board[2][col]) {
      return tiktactoe_board[0][col];
    }
  }
  
  // Check diagonals
  if (tiktactoe_board[0][0] && tiktactoe_board[0][0] === tiktactoe_board[1][1] && tiktactoe_board[1][1] === tiktactoe_board[2][2]) {
    return tiktactoe_board[0][0];
  }
  if (tiktactoe_board[0][2] && tiktactoe_board[0][2] === tiktactoe_board[1][1] && tiktactoe_board[1][1] === tiktactoe_board[2][0]) {
    return tiktactoe_board[0][2];
  }
  
  // Check for tie
  let isFull = true;
  for (let row = 0; row < 3; row++) {
    for (let col = 0; col < 3; col++) {
      if (tiktactoe_board[row][col] === '') {
        isFull = false;
        break;
      }
    }
  }
  
  return isFull ? 'tie' : null;
}

function tiktactoe_resetGame() {
  tiktactoe_board = [['', '', ''], ['', '', ''], ['', '', '']];
  tiktactoe_currentPlayer = 'X';
  tiktactoe_gameOver = false;
  tiktactoe_playerSpan.textContent = 'X';
  tiktactoe_drawBoard();
}

tiktactoe_canvas.addEventListener('click', function(e) {
  if (tiktactoe_gameOver) {
    tiktactoe_resetGame();
    return;
  }
  
  const rect = tiktactoe_canvas.getBoundingClientRect();
  const x = e.clientX - rect.left;
  const y = e.clientY - rect.top;
  
  const col = Math.floor(x / 133);
  const row = Math.floor(y / 100);
  
  if (row >= 0 && row < 3 && col >= 0 && col < 3 && tiktactoe_board[row][col] === '') {
    tiktactoe_board[row][col] = tiktactoe_currentPlayer;
    
    const winner = tiktactoe_checkWinner();
    if (winner) {
      tiktactoe_gameOver = true;
      if (winner === 'tie') {
        tiktactoe_playerSpan.textContent = "It's a Tie! Click to restart";
      } else {
        tiktactoe_playerSpan.textContent = winner + " Wins! Click to restart";
      }
    } else {
      tiktactoe_currentPlayer = tiktactoe_currentPlayer === 'X' ? 'O' : 'X';
      tiktactoe_playerSpan.textContent = tiktactoe_currentPlayer;
    }
    
    tiktactoe_drawBoard();
  }
});

tiktactoe_drawBoard();
</script>
```
----------------------------------------

MORPH BEFORE/AFTER COMPARISON:
----------------------------------------
BEFORE (GameZone.js):
import React from 'react';

const GameZone = ({ currentGame }) => {
  // Simple HTML content zone - perfect for Morph apply!
  // Just put your HTML game content here and it will render
  // this is the html content that will be rendered in the game zone ONLY CHANGE THIS ZONE
  // MORPH: ONLY replace the content between these backticks - keep everything else the same
  const htmlContent = `
    <div style="text-align: center; padding: 20px;">
      <h2>üéÆ HTML Game Zone</h2>
      <p>This is where your HTML5 Canvas games will appear!</p>
      <div style="background: linear-gradient(45deg, #ff6b6b, #4ecdc4); padding: 20px; border-radius: 10px; color: white; margin: 20px 0;">
        <strong>Perfect for Morph Apply!</strong><br/>
        Just replace the htmlContent variable above with your generated HTML5 game code
      </div>
      <div style="border: 2px dashed #ccc; padding: 40px; margin: 20px 0; border-radius: 8px;">
        <p style="color: #666; font-style: italic;">
          üéØ Game content will render here<br/>
          üìù Use Morph to apply HTML5 Canvas games directly<br/>
          üöÄ No complex React components needed!
        </p>
      </div>
      <p style="font-size: 12px; color: #888;">
        Current game: ${currentGame || 'None selected'}
      </p>
    </div>
  `;

  return (
    <div className="game-zone">
      <div className="game-content">
        <div dangerouslySetInnerHTML={{ __html: htmlContent }} />
      </div>
    </div>
  );
};

export default GameZone;

AFTER (GameZone.js):
import React from 'react';

const GameZone = ({ currentGame }) => {
  // Simple HTML content zone - perfect for Morph apply!
  // Just put your HTML game content here and it will render
  // this is the html content that will be rendered in the game zone ONLY CHANGE THIS ZONE
  // MORPH: ONLY replace the content between these backticks - keep everything else the same
  const htmlContent = `
<div style="text-align: center; padding: 20px;">
  <h3>üéÆ Tic Tac Toe</h3>
  <canvas id="game_tiktactoe_canvas" width="400" height="300" style="border: 2px solid #333; background: #fff; cursor: pointer;"></canvas>
  <div style="margin: 10px 0;">
    <strong>Current Player: <span id="game_tiktactoe_player">X</span></strong>
  </div>
  <div style="font-size: 12px; color: #666;">
    Controls: Click on squares to place X or O
  </div>
</div>
<script>
const tiktactoe_canvas = document.getElementById('game_tiktactoe_canvas');
const tiktactoe_ctx = tiktactoe_canvas.getContext('2d');
const tiktactoe_playerSpan = document.getElementById('game_tiktactoe_player');

let tiktactoe_board = [['', '', ''], ['', '', ''], ['', '', '']];
let tiktactoe_currentPlayer = 'X';
let tiktactoe_gameOver = false;

function tiktactoe_drawBoard() {
  tiktactoe_ctx.clearRect(0, 0, 400, 300);
  
  // Draw grid lines
  tiktactoe_ctx.strokeStyle = '#333';
  tiktactoe_ctx.lineWidth = 3;
  
  // Vertical lines
  tiktactoe_ctx.beginPath();
  tiktactoe_ctx.moveTo(133, 0);
  tiktactoe_ctx.lineTo(133, 300);
  tiktactoe_ctx.moveTo(267, 0);
  tiktactoe_ctx.lineTo(267, 300);
  tiktactoe_ctx.stroke();
  
  // Horizontal lines
  tiktactoe_ctx.beginPath();
  tiktactoe_ctx.moveTo(0, 100);
  tiktactoe_ctx.lineTo(400, 100);
  tiktactoe_ctx.moveTo(0, 200);
  tiktactoe_ctx.lineTo(400, 200);
  tiktactoe_ctx.stroke();
  
  // Draw X's and O's
  tiktactoe_ctx.font = '60px Arial';
  tiktactoe_ctx.textAlign = 'center';
  tiktactoe_ctx.textBaseline = 'middle';
  
  for (let row = 0; row < 3; row++) {
    for (let col = 0; col < 3; col++) {
      if (tiktactoe_board[row][col] === 'X') {
        tiktactoe_ctx.fillStyle = '#e74c3c';
        tiktactoe_ctx.fillText('X', col * 133 + 66, row * 100 + 50);
      } else if (tiktactoe_board[row][col] === 'O') {
        tiktactoe_ctx.fillStyle = '#3498db';
        tiktactoe_ctx.fillText('O', col * 133 + 66, row * 100 + 50);
      }
    }
  }
}

function tiktactoe_checkWinner() {
  // Check rows
  for (let row = 0; row < 3; row++) {
    if (tiktactoe_board[row][0] && tiktactoe_board[row][0] === tiktactoe_board[row][1] && tiktactoe_board[row][1] === tiktactoe_board[row][2]) {
      return tiktactoe_board[row][0];
    }
  }
  
  // Check columns
  for (let col = 0; col < 3; col++) {
    if (tiktactoe_board[0][col] && tiktactoe_board[0][col] === tiktactoe_board[1][col] && tiktactoe_board[1][col] === tiktactoe_board[2][col]) {
      return tiktactoe_board[0][col];
    }
  }
  
  // Check diagonals
  if (tiktactoe_board[0][0] && tiktactoe_board[0][0] === tiktactoe_board[1][1] && tiktactoe_board[1][1] === tiktactoe_board[2][2]) {
    return tiktactoe_board[0][0];
  }
  if (tiktactoe_board[0][2] && tiktactoe_board[0][2] === tiktactoe_board[1][1] && tiktactoe_board[1][1] === tiktactoe_board[2][0]) {
    return tiktactoe_board[0][2];
  }
  
  // Check for tie
  let isFull = true;
  for (let row = 0; row < 3; row++) {
    for (let col = 0; col < 3; col++) {
      if (tiktactoe_board[row][col] === '') {
        isFull = false;
        break;
      }
    }
  }
  
  return isFull ? 'tie' : null;
}

function tiktactoe_resetGame() {
  tiktactoe_board = [['', '', ''], ['', '', ''], ['', '', '']];
  tiktactoe_currentPlayer = 'X';
  tiktactoe_gameOver = false;
  tiktactoe_playerSpan.textContent = 'X';
  tiktactoe_drawBoard();
}

tiktactoe_canvas.addEventListener('click', function(e) {
  if (tiktactoe_gameOver) {
    tiktactoe_resetGame();
    return;
  }
  
  const rect = tiktactoe_canvas.getBoundingClientRect();
  const x = e.clientX - rect.left;
  const y = e.clientY - rect.top;
  
  const col = Math.floor(x / 133);
  const row = Math.floor(y / 100);
  
  if (row >= 0 && row < 3 && col >= 0 && col < 3 && tiktactoe_board[row][col] === '') {
    tiktactoe_board[row][col] = tiktactoe_currentPlayer;
    
    const winner = tiktactoe_checkWinner();
    if (winner) {
      tiktactoe_gameOver = true;
      if (winner === 'tie') {
        tiktactoe_playerSpan.textContent = "It's a Tie! Click to restart";
      } else {
        tiktactoe_playerSpan.textContent = winner + " Wins! Click to restart";
      }
    } else {
      tiktactoe_currentPlayer = tiktactoe_currentPlayer === 'X' ? 'O' : 'X';
      tiktactoe_playerSpan.textContent = tiktactoe_currentPlayer;
    }
    
    tiktactoe_drawBoard();
  }
});

tiktactoe_drawBoard();
</script>
`;

  return (
    <div className="game-zone">
      <div className="game-content">
        <div dangerouslySetInnerHTML={{ __html: htmlContent }} />
      </div>
    </div>
  );
};

export default GameZone;

================================================================================


================================================================================
GAME GENERATION: tik tak toe - 2025-08-09 13:18:54.732414
================================================================================
FULL CLAUDE GENERATED CODE:
----------------------------------------
```javascript
import React, { useState } from 'react';

const GameZone = ({ currentGame }) => {
  const [board, setBoard] = useState(Array(9).fill(null));
  const [isXNext, setIsXNext] = useState(true);
  const [winner, setWinner] = useState(null);

  const checkWinner = (squares) => {
    const lines = [
      [0, 1, 2],
      [3, 4, 5],
      [6, 7, 8],
      [0, 3, 6],
      [1, 4, 7],
      [2, 5, 8],
      [0, 4, 8],
      [2, 4, 6],
    ];
    for (let i = 0; i < lines.length; i++) {
      const [a, b, c] = lines[i];
      if (squares[a] && squares[a] === squares[b] && squares[a] === squares[c]) {
        return squares[a];
      }
    }
    return null;
  };

  const handleClick = (index) => {
    if (board[index] || winner) return;
    
    const newBoard = [...board];
    newBoard[index] = isXNext ? 'X' : 'O';
    setBoard(newBoard);
    
    const gameWinner = checkWinner(newBoard);
    if (gameWinner) {
      setWinner(gameWinner);
    } else {
      setIsXNext(!isXNext);
    }
  };

  const resetGame = () => {
    setBoard(Array(9).fill(null));
    setIsXNext(true);
    setWinner(null);
  };

  const isDraw = !winner && board.every(square => square !== null);

  const renderSquare = (index) => (
    <button
      key={index}
      onClick={() => handleClick(index)}
      style={{
        width: '80px',
        height: '80px',
        fontSize: '24px',
        fontWeight: 'bold',
        border: '2px solid #333',
        backgroundColor: '#fff',
        cursor: 'pointer',
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'center'
      }}
    >
      {board[index]}
    </button>
  );

  return (
    <div style={{
      display: 'flex',
      flexDirection: 'column',
      alignItems: 'center',
      padding: '20px',
      fontFamily: 'Arial, sans-serif'
    }}>
      <h2 style={{ marginBottom: '20px' }}>Tic Tac Toe</h2>
      
      <div style={{
        display: 'grid',
        gridTemplate: 'repeat(3, 80px) / repeat(3, 80px)',
        gap: '2px',
        marginBottom: '20px',
        border: '2px solid #333'
      }}>
        {Array(9).fill(null).map((_, index) => renderSquare(index))}
      </div>

      <div style={{ textAlign: 'center', marginBottom: '20px' }}>
        {winner ? (
          <h3 style={{ color: 'green' }}>Winner: {winner}!</h3>
        ) : isDraw ? (
          <h3 style={{ color: 'orange' }}>It's a Draw!</h3>
        ) : (
          <h3>Next Player: {isXNext ? 'X' : 'O'}</h3>
        )}
      </div>

      <button
        onClick={resetGame}
        style={{
          padding: '10px 20px',
          fontSize: '16px',
          backgroundColor: '#007bff',
          color: 'white',
          border: 'none',
          borderRadius: '5px',
          cursor: 'pointer'
        }}
      >
        Reset Game
      </button>
    </div>
  );
};

export default GameZone;
```
----------------------------------------


================================================================================
GAME GENERATION: car game - 2025-08-09 13:26:47.780186
================================================================================
FULL CLAUDE GENERATED CODE:
----------------------------------------
import React, { useState, useEffect, useRef, useCallback } from 'react';

const GameZone = ({ currentGame }) => {
  const canvasRef = useRef(null);
  const [gameState, setGameState] = useState('playing');
  const [score, setScore] = useState(0);
  const [car, setCar] = useState({ x: 175, y: 250, width: 50, height: 30 });
  const [obstacles, setObstacles] = useState([]);
  const [keys, setKeys] = useState({});

  const gameWidth = 400;
  const gameHeight = 300;
  const carSpeed = 5;
  const obstacleSpeed = 3;

  const resetGame = useCallback(() => {
    setCar({ x: 175, y: 250, width: 50, height: 30 });
    setObstacles([]);
    setScore(0);
    setGameState('playing');
  }, []);

  const checkCollision = (rect1, rect2) => {
    return rect1.x < rect2.x + rect2.width &&
           rect1.x + rect1.width > rect2.x &&
           rect1.y < rect2.y + rect2.height &&
           rect1.y + rect1.height > rect2.y;
  };

  const gameLoop = useCallback(() => {
    if (gameState !== 'playing') return;

    setCar(prevCar => {
      let newX = prevCar.x;
      if (keys['ArrowLeft'] && newX > 0) newX -= carSpeed;
      if (keys['ArrowRight'] && newX < gameWidth - prevCar.width) newX += carSpeed;
      return { ...prevCar, x: newX };
    });

    setObstacles(prevObstacles => {
      let newObstacles = prevObstacles.map(obs => ({
        ...obs,
        y: obs.y + obstacleSpeed
      })).filter(obs => obs.y < gameHeight);

      if (Math.random() < 0.02) {
        newObstacles.push({
          x: Math.random() * (gameWidth - 40),
          y: -30,
          width: 40,
          height: 30
        });
      }

      return newObstacles;
    });

    setScore(prevScore => prevScore + 1);
  }, [gameState, keys]);

  useEffect(() => {
    const handleKeyDown = (e) => {
      setKeys(prev => ({ ...prev, [e.key]: true }));
    };

    const handleKeyUp = (e) => {
      setKeys(prev => ({ ...prev, [e.key]: false }));
    };

    window.addEventListener('keydown', handleKeyDown);
    window.addEventListener('keyup', handleKeyUp);

    return () => {
      window.removeEventListener('keydown', handleKeyDown);
      window.removeEventListener('keyup', handleKeyUp);
    };
  }, []);

  useEffect(() => {
    const interval = setInterval(gameLoop, 50);
    return () => clearInterval(interval);
  }, [gameLoop]);

  useEffect(() => {
    obstacles.forEach(obstacle => {
      if (checkCollision(car, obstacle)) {
        setGameState('gameOver');
      }
    });
  }, [car, obstacles]);

  useEffect(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;

    const ctx = canvas.getContext('2d');
    ctx.clearRect(0, 0, gameWidth, gameHeight);

    ctx.fillStyle = '#333';
    ctx.fillRect(0, 0, gameWidth, gameHeight);

    for (let i = 0; i < gameWidth; i += 40) {
      ctx.fillStyle = '#666';
      ctx.fillRect(i + 18, 0, 4, gameHeight);
    }

    ctx.fillStyle = '#00ff00';
    ctx.fillRect(car.x, car.y, car.width, car.height);

    ctx.fillStyle = '#ff0000';
    obstacles.forEach(obstacle => {
      ctx.fillRect(obstacle.x, obstacle.y, obstacle.width, obstacle.height);
    });
  });

  return (
    <div style={{ 
      display: 'flex', 
      flexDirection: 'column', 
      alignItems: 'center', 
      padding: '20px',
      fontFamily: 'Arial, sans-serif'
    }}>
      <h2 style={{ margin: '0 0 10px 0' }}>Simple Car Game</h2>
      <div style={{ marginBottom: '10px' }}>
        Score: {score} | Status: {gameState}
      </div>
      
      <canvas
        ref={canvasRef}
        width={gameWidth}
        height={gameHeight}
        style={{
          border: '2px solid #000',
          backgroundColor: '#333'
        }}
      />
      
      <div style={{ marginTop: '15px' }}>
        <button 
          onClick={resetGame}
          style={{
            padding: '10px 20px',
            fontSize: '16px',
            backgroundColor: '#4CAF50',
            color: 'white',
            border: 'none',
            borderRadius: '5px',
            cursor: 'pointer',
            marginRight: '10px'
          }}
        >
          {gameState === 'gameOver' ? 'Play Again' : 'Restart'}
        </button>
      </div>
      
      <div style={{ 
        marginTop: '15px', 
        textAlign: 'center',
        fontSize: '14px',
        color: '#666'
      }}>
        Use arrow keys to move left and right<br/>
        Avoid the red obstacles!
      </div>
      
      {gameState === 'gameOver' && (
        <div style={{
          marginTop: '15px',
          padding: '10px',
          backgroundColor: '#ffebee',
          border: '1px solid #f44336',
          borderRadius: '5px',
          color: '#d32f2f',
          fontWeight: 'bold'
        }}>
          Game Over! Final Score: {score}
        </div>
      )}
    </div>
  );
};

export default GameZone;
----------------------------------------


================================================================================
GAME GENERATION: pacman - 2025-08-09 13:28:01.148852
================================================================================
FULL CLAUDE GENERATED CODE:
----------------------------------------
import React, { useState, useEffect, useCallback } from 'react';

const GameZone = ({ currentGame }) => {
  const GRID_SIZE = 20;
  const ROWS = 15;
  const COLS = 20;
  
  const initialMaze = [
    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
    [1,2,2,2,2,2,2,2,2,1,1,2,2,2,2,2,2,2,2,1],
    [1,2,1,1,2,1,1,1,2,1,1,2,1,1,1,2,1,1,2,1],
    [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1],
    [1,2,1,1,2,1,2,1,1,1,1,1,1,2,1,2,1,1,2,1],
    [1,2,2,2,2,1,2,2,2,1,1,2,2,2,1,2,2,2,2,1],
    [1,1,1,1,2,1,1,1,0,1,1,0,1,1,1,2,1,1,1,1],
    [0,0,0,1,2,1,0,0,0,0,0,0,0,0,1,2,1,0,0,0],
    [1,1,1,1,2,1,0,1,1,0,0,1,1,0,1,2,1,1,1,1],
    [1,2,2,2,2,2,0,1,0,0,0,0,1,0,2,2,2,2,2,1],
    [1,2,1,1,2,1,0,1,1,1,1,1,1,0,1,2,1,1,2,1],
    [1,2,2,2,2,1,2,2,2,1,1,2,2,2,1,2,2,2,2,1],
    [1,1,1,2,2,2,2,1,2,1,1,2,1,2,2,2,2,1,1,1],
    [1,2,2,2,2,2,2,1,2,2,2,2,1,2,2,2,2,2,2,1],
    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
  ];

  const [maze, setMaze] = useState(initialMaze);
  const [pacmanPos, setPacmanPos] = useState({ x: 1, y: 1 });
  const [ghosts, setGhosts] = useState([
    { x: 9, y: 8, color: 'red' },
    { x: 10, y: 8, color: 'pink' }
  ]);
  const [score, setScore] = useState(0);
  const [gameOver, setGameOver] = useState(false);
  const [direction, setDirection] = useState({ x: 0, y: 0 });

  const isValidMove = (x, y) => {
    return x >= 0 && x < COLS && y >= 0 && y < ROWS && maze[y][x] !== 1;
  };

  const moveGhosts = useCallback(() => {
    setGhosts(prevGhosts => 
      prevGhosts.map(ghost => {
        const directions = [
          { x: 0, y: -1 },
          { x: 0, y: 1 },
          { x: -1, y: 0 },
          { x: 1, y: 0 }
        ];
        
        const validMoves = directions.filter(dir => 
          isValidMove(ghost.x + dir.x, ghost.y + dir.y)
        );
        
        if (validMoves.length > 0) {
          const randomMove = validMoves[Math.floor(Math.random() * validMoves.length)];
          return {
            ...ghost,
            x: ghost.x + randomMove.x,
            y: ghost.y + randomMove.y
          };
        }
        return ghost;
      })
    );
  }, [maze]);

  const checkCollision = useCallback(() => {
    const collision = ghosts.some(ghost => 
      ghost.x === pacmanPos.x && ghost.y === pacmanPos.y
    );
    if (collision) {
      setGameOver(true);
    }
  }, [ghosts, pacmanPos]);

  const movePacman = useCallback(() => {
    if (direction.x === 0 && direction.y === 0) return;
    
    const newX = pacmanPos.x + direction.x;
    const newY = pacmanPos.y + direction.y;
    
    if (isValidMove(newX, newY)) {
      setPacmanPos({ x: newX, y: newY });
      
      if (maze[newY][newX] === 2) {
        setScore(prev => prev + 10);
        setMaze(prev => {
          const newMaze = [...prev];
          newMaze[newY] = [...newMaze[newY]];
          newMaze[newY][newX] = 0;
          return newMaze;
        });
      }
    }
  }, [direction, pacmanPos, maze]);

  useEffect(() => {
    const handleKeyPress = (e) => {
      if (gameOver) return;
      
      switch(e.key) {
        case 'ArrowUp':
          setDirection({ x: 0, y: -1 });
          break;
        case 'ArrowDown':
          setDirection({ x: 0, y: 1 });
          break;
        case 'ArrowLeft':
          setDirection({ x: -1, y: 0 });
          break;
        case 'ArrowRight':
          setDirection({ x: 1, y: 0 });
          break;
        default:
          break;
      }
    };

    window.addEventListener('keydown', handleKeyPress);
    return () => window.removeEventListener('keydown', handleKeyPress);
  }, [gameOver]);

  useEffect(() => {
    if (gameOver) return;
    
    const gameLoop = setInterval(() => {
      movePacman();
      moveGhosts();
    }, 200);

    return () => clearInterval(gameLoop);
  }, [movePacman, moveGhosts, gameOver]);

  useEffect(() => {
    checkCollision();
  }, [checkCollision]);

  const resetGame = () => {
    setMaze(initialMaze);
    setPacmanPos({ x: 1, y: 1 });
    setGhosts([
      { x: 9, y: 8, color: 'red' },
      { x: 10, y: 8, color: 'pink' }
    ]);
    setScore(0);
    setGameOver(false);
    setDirection({ x: 0, y: 0 });
  };

  const getCellContent = (x, y) => {
    if (pacmanPos.x === x && pacmanPos.y === y) {
      return 'üü°';
    }
    
    const ghost = ghosts.find(g => g.x === x && g.y === y);
    if (ghost) {
      return ghost.color === 'red' ? 'üëª' : 'üëπ';
    }
    
    switch(maze[y][
----------------------------------------


================================================================================
GAME GENERATION: shooter game - 2025-08-09 13:31:51.192977
================================================================================
FULL CLAUDE GENERATED CODE:
----------------------------------------
import React, { useState, useEffect, useCallback } from 'react';

const GameZone = ({ currentGame }) => {
  const [player, setPlayer] = useState({ x: 200, y: 250 });
  const [bullets, setBullets] = useState([]);
  const [enemies, setEnemies] = useState([]);
  const [score, setScore] = useState(0);
  const [gameRunning, setGameRunning] = useState(false);
  const [keys, setKeys] = useState({});

  const gameWidth = 400;
  const gameHeight = 300;

  const startGame = () => {
    setPlayer({ x: 200, y: 250 });
    setBullets([]);
    setEnemies([]);
    setScore(0);
    setGameRunning(true);
  };

  const resetGame = () => {
    setGameRunning(false);
    setPlayer({ x: 200, y: 250 });
    setBullets([]);
    setEnemies([]);
    setScore(0);
  };

  const handleKeyDown = useCallback((e) => {
    setKeys(prev => ({ ...prev, [e.key]: true }));
    if (e.key === ' ') {
      e.preventDefault();
      if (gameRunning) {
        setBullets(prev => [...prev, { x: player.x, y: player.y - 10, id: Date.now() }]);
      }
    }
  }, [gameRunning, player.x, player.y]);

  const handleKeyUp = useCallback((e) => {
    setKeys(prev => ({ ...prev, [e.key]: false }));
  }, []);

  useEffect(() => {
    window.addEventListener('keydown', handleKeyDown);
    window.addEventListener('keyup', handleKeyUp);
    return () => {
      window.removeEventListener('keydown', handleKeyDown);
      window.removeEventListener('keyup', handleKeyUp);
    };
  }, [handleKeyDown, handleKeyUp]);

  useEffect(() => {
    if (!gameRunning) return;

    const gameLoop = setInterval(() => {
      setPlayer(prev => {
        let newX = prev.x;
        if (keys['ArrowLeft'] && newX > 0) newX -= 5;
        if (keys['ArrowRight'] && newX < gameWidth - 20) newX += 5;
        return { ...prev, x: newX };
      });

      setBullets(prev => prev
        .map(bullet => ({ ...bullet, y: bullet.y - 8 }))
        .filter(bullet => bullet.y > 0)
      );

      setEnemies(prev => {
        let newEnemies = prev
          .map(enemy => ({ ...enemy, y: enemy.y + 2 }))
          .filter(enemy => enemy.y < gameHeight);
        
        if (Math.random() < 0.02) {
          newEnemies.push({
            x: Math.random() * (gameWidth - 20),
            y: 0,
            id: Date.now()
          });
        }
        
        return newEnemies;
      });

      setBullets(prevBullets => {
        setEnemies(prevEnemies => {
          let newEnemies = [...prevEnemies];
          let newBullets = [...prevBullets];
          
          prevBullets.forEach(bullet => {
            const hitEnemyIndex = newEnemies.findIndex(enemy => 
              bullet.x < enemy.x + 20 && bullet.x + 5 > enemy.x &&
              bullet.y < enemy.y + 20 && bullet.y + 5 > enemy.y
            );
            
            if (hitEnemyIndex !== -1) {
              newEnemies.splice(hitEnemyIndex, 1);
              newBullets = newBullets.filter(b => b.id !== bullet.id);
              setScore(prev => prev + 10);
            }
          });
          
          const playerHit = newEnemies.some(enemy =>
            player.x < enemy.x + 20 && player.x + 20 > enemy.x &&
            player.y < enemy.y + 20 && player.y + 20 > enemy.y
          );
          
          if (playerHit) {
            setGameRunning(false);
          }
          
          return newEnemies;
        });
        
        return prevBullets;
      });
    }, 50);

    return () => clearInterval(gameLoop);
  }, [gameRunning, keys, player.x, player.y]);

  return (
    <div style={{ textAlign: 'center', padding: '20px' }}>
      <h2>Shooter Game</h2>
      <div style={{ marginBottom: '10px' }}>
        <span>Score: {score}</span>
        <button onClick={startGame} style={{ marginLeft: '20px', marginRight: '10px' }}>
          Start
        </button>
        <button onClick={resetGame}>Reset</button>
      </div>
      
      <div style={{
        width: `${gameWidth}px`,
        height: `${gameHeight}px`,
        border: '2px solid #333',
        position: 'relative',
        backgroundColor: '#001122',
        margin: '0 auto',
        overflow: 'hidden'
      }}>
        <div style={{
          position: 'absolute',
          left: `${player.x}px`,
          top: `${player.y}px`,
          width: '20px',
          height: '20px',
          backgroundColor: '#00ff00',
          borderRadius: '3px'
        }} />
        
        {bullets.map(bullet => (
          <div key={bullet.id} style={{
            position: 'absolute',
            left: `${bullet.x}px`,
            top: `${bullet.y}px`,
            width: '5px',
            height: '10px',
            backgroundColor: '#ffff00',
            borderRadius: '2px'
          }} />
        ))}
        
        {enemies.map(enemy => (
          <div key={enemy.id} style={{
            position: 'absolute',
            left: `${enemy.x}px`,
            top: `${enemy.y}px`,
            width: '20px',
            height: '20px',
            backgroundColor: '#ff0000',
            borderRadius: '3px'
          }} />
        ))}
        
        {!gameRunning && (
          <div style={{
            position: 'absolute',
            top: '50%',
            left: '50%',
            transform: 'translate(-50%, -50%)',
            color: 'white',
            fontSize: '18px',
            fontWeight: 'bold'
          }}>
            {score > 0 ? `Game Over! Final Score: ${score}` : 'Press Start to Play'}
          </div>
        )}
      </div>
      
      <div style={{ marginTop: '10px', fontSize: '14px' }}>
        Use ‚Üê ‚Üí arrows to move, SPACE to shoot
      </div>
    </div>
  );
};

export default GameZone;
----------------------------------------


================================================================================
GAME GENERATION: chess - 2025-08-09 13:33:32.818454
================================================================================
FULL CLAUDE GENERATED CODE:
----------------------------------------
import React, { useState, useRef, useEffect } from 'react';

const GameZone = ({ currentGame }) => {
  const initialBoard = [
    ['r', 'n', 'b', 'q', 'k', 'b', 'n', 'r'],
    ['p', 'p', 'p', 'p', 'p', 'p', 'p', 'p'],
    [null, null, null, null, null, null, null, null],
    [null, null, null, null, null, null, null, null],
    [null, null, null, null, null, null, null, null],
    [null, null, null, null, null, null, null, null],
    ['P', 'P', 'P', 'P', 'P', 'P', 'P', 'P'],
    ['R', 'N', 'B', 'Q', 'K', 'B', 'N', 'R']
  ];

  const [board, setBoard] = useState(initialBoard);
  const [selectedSquare, setSelectedSquare] = useState(null);
  const [currentPlayer, setCurrentPlayer] = useState('white');
  const [gameStatus, setGameStatus] = useState('playing');

  const pieceSymbols = {
    'K': '‚ôî', 'Q': '‚ôï', 'R': '‚ôñ', 'B': '‚ôó', 'N': '‚ôò', 'P': '‚ôô',
    'k': '‚ôö', 'q': '‚ôõ', 'r': '‚ôú', 'b': '‚ôù', 'n': '‚ôû', 'p': '‚ôü'
  };

  const isWhitePiece = (piece) => piece && piece === piece.toUpperCase();
  const isBlackPiece = (piece) => piece && piece === piece.toLowerCase();

  const isValidMove = (fromRow, fromCol, toRow, toCol, piece) => {
    if (toRow < 0 || toRow > 7 || toCol < 0 || toCol > 7) return false;
    
    const targetPiece = board[toRow][toCol];
    if (targetPiece && 
        ((isWhitePiece(piece) && isWhitePiece(targetPiece)) ||
         (isBlackPiece(piece) && isBlackPiece(targetPiece)))) {
      return false;
    }

    const rowDiff = Math.abs(toRow - fromRow);
    const colDiff = Math.abs(toCol - fromCol);

    switch (piece.toLowerCase()) {
      case 'p':
        const direction = isWhitePiece(piece) ? -1 : 1;
        const startRow = isWhitePiece(piece) ? 6 : 1;
        
        if (toCol === fromCol) {
          if (toRow === fromRow + direction && !targetPiece) return true;
          if (fromRow === startRow && toRow === fromRow + 2 * direction && !targetPiece) return true;
        } else if (Math.abs(toCol - fromCol) === 1 && toRow === fromRow + direction && targetPiece) {
          return true;
        }
        return false;

      case 'r':
        if (fromRow === toRow || fromCol === toCol) {
          const stepRow = fromRow === toRow ? 0 : (toRow > fromRow ? 1 : -1);
          const stepCol = fromCol === toCol ? 0 : (toCol > fromCol ? 1 : -1);
          for (let i = 1; i < Math.max(rowDiff, colDiff); i++) {
            if (board[fromRow + i * stepRow][fromCol + i * stepCol]) return false;
          }
          return true;
        }
        return false;

      case 'n':
        return (rowDiff === 2 && colDiff === 1) || (rowDiff === 1 && colDiff === 2);

      case 'b':
        if (rowDiff === colDiff) {
          const stepRow = toRow > fromRow ? 1 : -1;
          const stepCol = toCol > fromCol ? 1 : -1;
          for (let i = 1; i < rowDiff; i++) {
            if (board[fromRow + i * stepRow][fromCol + i * stepCol]) return false;
          }
          return true;
        }
        return false;

      case 'q':
        if (fromRow === toRow || fromCol === toCol || rowDiff === colDiff) {
          const stepRow = fromRow === toRow ? 0 : (toRow > fromRow ? 1 : -1);
          const stepCol = fromCol === toCol ? 0 : (toCol > fromCol ? 1 : -1);
          for (let i = 1; i < Math.max(rowDiff, colDiff); i++) {
            if (board[fromRow + i * stepRow][fromCol + i * stepCol]) return false;
          }
          return true;
        }
        return false;

      case 'k':
        return rowDiff <= 1 && colDiff <= 1 && (rowDiff + colDiff > 0);

      default:
        return false;
    }
  };

  const handleSquareClick = (row, col) => {
    if (gameStatus !== 'playing') return;

    if (selectedSquare) {
      const [fromRow, fromCol] = selectedSquare;
      const piece = board[fromRow][fromCol];
      
      if (row === fromRow && col === fromCol) {
        setSelectedSquare(null);
        return;
      }

      if (piece && 
          ((currentPlayer === 'white' && isWhitePiece(piece)) ||
           (currentPlayer === 'black' && isBlackPiece(piece))) &&
          isValidMove(fromRow, fromCol, row, col, piece)) {
        
        const newBoard = board.map(r => [...r]);
        const capturedPiece = newBoard[row][col];
        newBoard[row][col] = piece;
        newBoard[fromRow][fromCol] = null;
        
        setBoard(newBoard);
        setSelectedSquare(null);
        setCurrentPlayer(currentPlayer === 'white' ? 'black' : 'white');

        if (capturedPiece && capturedPiece.toLowerCase() === 'k') {
          setGameStatus(`${currentPlayer} wins!`);
        }
      } else {
        setSelectedSquare(null);
      }
    } else {
      const piece = board[row][col];
      if (piece && 
          ((currentPlayer === 'white' && isWhitePiece(piece)) ||
           (currentPlayer === 'black' && isBlackPiece(piece)))) {
        setSelectedSquare([row, col]);
      }
    }
  };

  const resetGame = () => {
    setBoard(initialBoard.map(row => [...row]));
    setSelectedSquare(null);
    setCurrentPlayer('white');
    setGameStatus('playing');
  };

  return (
    <div style={{ 
      display: 'flex', 
      flexDirection: 'column', 
      alignItems: 'center', 
      padding: '20px',
      fontFamily: 'Arial, sans-serif'
    }}>
      <h2 style={{ margin: '0 0 10px 0', color: '#333' }}>Chess Game</h2>
      
      <div style={{ 
        marginBottom: '10px', 
        fontSize: '16px',
        fontWeight: 'bold'
      }}>
        {gameStatus === 'playing' ? `Current Player: ${currentPlayer}` : gameStatus}
      </div>

      <div style={{
        display: 'grid',
        gridTemplate
----------------------------------------


================================================================================
GAME GENERATION: flappy bird - 2025-08-09 13:34:58.374086
================================================================================
FULL CLAUDE GENERATED CODE:
----------------------------------------
import React, { useState, useEffect, useRef, useCallback } from 'react';

const GameZone = ({ currentGame }) => {
  const canvasRef = useRef(null);
  const gameLoopRef = useRef(null);
  const [score, setScore] = useState(0);
  const [gameState, setGameState] = useState('waiting');
  const [bird, setBird] = useState({ y: 150, velocity: 0 });
  const [pipes, setPipes] = useState([]);

  const CANVAS_WIDTH = 400;
  const CANVAS_HEIGHT = 300;
  const BIRD_SIZE = 20;
  const PIPE_WIDTH = 50;
  const PIPE_GAP = 100;
  const GRAVITY = 0.5;
  const JUMP_STRENGTH = -8;
  const PIPE_SPEED = 2;

  const resetGame = useCallback(() => {
    setBird({ y: 150, velocity: 0 });
    setPipes([]);
    setScore(0);
    setGameState('waiting');
  }, []);

  const startGame = useCallback(() => {
    setGameState('playing');
    setBird(prev => ({ ...prev, velocity: JUMP_STRENGTH }));
  }, []);

  const jump = useCallback(() => {
    if (gameState === 'playing') {
      setBird(prev => ({ ...prev, velocity: JUMP_STRENGTH }));
    } else if (gameState === 'waiting') {
      startGame();
    }
  }, [gameState, startGame]);

  const checkCollision = useCallback((birdY, pipes) => {
    if (birdY < 0 || birdY + BIRD_SIZE > CANVAS_HEIGHT) {
      return true;
    }

    const birdX = 50;
    for (let pipe of pipes) {
      if (birdX + BIRD_SIZE > pipe.x && birdX < pipe.x + PIPE_WIDTH) {
        if (birdY < pipe.topHeight || birdY + BIRD_SIZE > pipe.topHeight + PIPE_GAP) {
          return true;
        }
      }
    }
    return false;
  }, []);

  const updateGame = useCallback(() => {
    if (gameState !== 'playing') return;

    setBird(prev => {
      const newY = prev.y + prev.velocity;
      const newVelocity = prev.velocity + GRAVITY;
      return { y: newY, velocity: newVelocity };
    });

    setPipes(prev => {
      let newPipes = prev.map(pipe => ({ ...pipe, x: pipe.x - PIPE_SPEED }))
                        .filter(pipe => pipe.x + PIPE_WIDTH > 0);

      if (newPipes.length === 0 || newPipes[newPipes.length - 1].x < CANVAS_WIDTH - 200) {
        const topHeight = Math.random() * (CANVAS_HEIGHT - PIPE_GAP - 40) + 20;
        newPipes.push({
          x: CANVAS_WIDTH,
          topHeight: topHeight,
          scored: false
        });
      }

      newPipes.forEach(pipe => {
        if (!pipe.scored && pipe.x + PIPE_WIDTH < 50) {
          pipe.scored = true;
          setScore(s => s + 1);
        }
      });

      return newPipes;
    });
  }, [gameState]);

  useEffect(() => {
    const handleKeyPress = (e) => {
      if (e.code === 'Space') {
        e.preventDefault();
        jump();
      }
    };

    window.addEventListener('keydown', handleKeyPress);
    return () => window.removeEventListener('keydown', handleKeyPress);
  }, [jump]);

  useEffect(() => {
    if (gameState === 'playing') {
      if (checkCollision(bird.y, pipes)) {
        setGameState('gameOver');
        return;
      }
    }
  }, [bird.y, pipes, gameState, checkCollision]);

  useEffect(() => {
    if (gameState === 'playing') {
      gameLoopRef.current = setInterval(updateGame, 16);
    } else {
      if (gameLoopRef.current) {
        clearInterval(gameLoopRef.current);
      }
    }

    return () => {
      if (gameLoopRef.current) {
        clearInterval(gameLoopRef.current);
      }
    };
  }, [gameState, updateGame]);

  useEffect(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;

    const ctx = canvas.getContext('2d');
    ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

    ctx.fillStyle = '#87CEEB';
    ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

    pipes.forEach(pipe => {
      ctx.fillStyle = '#32CD32';
      ctx.fillRect(pipe.x, 0, PIPE_WIDTH, pipe.topHeight);
      ctx.fillRect(pipe.x, pipe.topHeight + PIPE_GAP, PIPE_WIDTH, CANVAS_HEIGHT - pipe.topHeight - PIPE_GAP);
    });

    ctx.fillStyle = '#FFD700';
    ctx.fillRect(50 - BIRD_SIZE/2, bird.y, BIRD_SIZE, BIRD_SIZE);

    ctx.fillStyle = '#000';
    ctx.font = '20px Arial';
    ctx.fillText(`Score: ${score}`, 10, 30);

    if (gameState === 'waiting') {
      ctx.fillStyle = 'rgba(0,0,0,0.7)';
      ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
      ctx.fillStyle = '#FFF';
      ctx.font = '24px Arial';
      ctx.textAlign = 'center';
      ctx.fillText('Click or Press Space to Start', CANVAS_WIDTH/2, CANVAS_HEIGHT/2);
      ctx.textAlign = 'left';
    }

    if (gameState === 'gameOver') {
      ctx.fillStyle = 'rgba(255,0,0,0.7)';
      ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
      ctx.fillStyle = '#FFF';
      ctx.font = '24px Arial';
      ctx.textAlign = 'center';
      ctx.fillText('Game Over!', CANVAS_WIDTH/2, CANVAS_HEIGHT/2 - 20);
      ctx.fillText(`Final Score: ${score}`, CANVAS_WIDTH/2, CANVAS_HEIGHT/2 + 20);
      ctx.textAlign = 'left';
    }
  }, [bird, pipes, score, gameState]);

  return (
    <div style={{ 
      display: 'flex', 
      flexDirection: 'column', 
      alignItems: 'center', 
      padding: '20px',
      fontFamily: 'Arial, sans-serif'
    }}>
      <h2 style={{ margin: '0 0 20px 0', color: '#333' }}>Flappy Bird</h2>
      
      <canvas
        ref={canvasRef}
        width={CANVAS_WIDTH}
        height={CANVAS_HEIGHT}
        onClick={jump}
        style={{ 
          border: '2px solid #333',
          cursor: 'pointer',
          display: 'block'
        }}
      />
      
      <div style={{ marginTop: '20px' }}>
        <button
          onClick={resetGame}
          style={{
            padding: '10px 20px',
            fontSize: '16px',
            backgroundColor: '#4CAF50',
            color: 'white',
            border: 'none',
            borderRadius: '5px',
            cursor: 'pointer',
            marginRight: '10px'
          }}
----------------------------------------


================================================================================
GAME GENERATION: pacmanbutmakethespacebarbarelymakeujump - 2025-08-09 13:46:31.135871
================================================================================
FULL CLAUDE GENERATED CODE:
----------------------------------------
import React, { useState, useEffect, useRef, useCallback } from 'react';

const GameZone = ({ currentGame }) => {
  const canvasRef = useRef(null);
  const [gameState, setGameState] = useState('playing');
  const [score, setScore] = useState(0);
  const [player, setPlayer] = useState({ x: 50, y: 250, velY: 0, onGround: true });
  const [dots, setDots] = useState([]);
  const [ghosts, setGhosts] = useState([]);

  const initializeGame = useCallback(() => {
    const newDots = [];
    for (let i = 0; i < 20; i++) {
      newDots.push({
        x: 100 + i * 15,
        y: 260,
        collected: false
      });
    }
    
    const newGhosts = [
      { x: 200, y: 240, dx: 1 },
      { x: 300, y: 240, dx: -1 }
    ];

    setDots(newDots);
    setGhosts(newGhosts);
    setPlayer({ x: 50, y: 250, velY: 0, onGround: true });
    setScore(0);
    setGameState('playing');
  }, []);

  useEffect(() => {
    initializeGame();
  }, [initializeGame]);

  useEffect(() => {
    const handleKeyPress = (e) => {
      if (e.code === 'Space' && player.onGround) {
        e.preventDefault();
        setPlayer(prev => ({ ...prev, velY: -8, onGround: false }));
      }
    };

    window.addEventListener('keydown', handleKeyPress);
    return () => window.removeEventListener('keydown', handleKeyPress);
  }, [player.onGround]);

  useEffect(() => {
    if (gameState !== 'playing') return;

    const gameLoop = setInterval(() => {
      setPlayer(prev => {
        let newY = prev.y + prev.velY;
        let newVelY = prev.velY + 0.5;
        let newOnGround = prev.onGround;

        if (newY >= 250) {
          newY = 250;
          newVelY = 0;
          newOnGround = true;
        } else {
          newOnGround = false;
        }

        return { ...prev, y: newY, velY: newVelY, onGround: newOnGround };
      });

      setGhosts(prev => prev.map(ghost => {
        let newX = ghost.x + ghost.dx;
        let newDx = ghost.dx;

        if (newX <= 80 || newX >= 350) {
          newDx = -ghost.dx;
          newX = ghost.x + newDx;
        }

        return { ...ghost, x: newX, dx: newDx };
      }));

      setDots(prev => {
        const newDots = prev.map(dot => {
          if (!dot.collected && 
              Math.abs(dot.x - player.x) < 15 && 
              Math.abs(dot.y - player.y) < 15) {
            setScore(s => s + 10);
            return { ...dot, collected: true };
          }
          return dot;
        });
        return newDots;
      });

      ghosts.forEach(ghost => {
        if (Math.abs(ghost.x - player.x) < 20 && Math.abs(ghost.y - player.y) < 20) {
          setGameState('gameOver');
        }
      });

      if (dots.every(dot => dot.collected)) {
        setGameState('won');
      }
    }, 16);

    return () => clearInterval(gameLoop);
  }, [gameState, player, ghosts, dots]);

  useEffect(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;

    const ctx = canvas.getContext('2d');
    ctx.clearRect(0, 0, 400, 300);

    ctx.fillStyle = '#000';
    ctx.fillRect(0, 0, 400, 300);

    ctx.fillStyle = '#0f0';
    ctx.fillRect(0, 270, 400, 30);

    ctx.fillStyle = '#ff0';
    ctx.beginPath();
    ctx.arc(player.x, player.y, 10, 0.2 * Math.PI, 1.8 * Math.PI);
    ctx.lineTo(player.x, player.y);
    ctx.fill();

    dots.forEach(dot => {
      if (!dot.collected) {
        ctx.fillStyle = '#ff0';
        ctx.beginPath();
        ctx.arc(dot.x, dot.y, 3, 0, 2 * Math.PI);
        ctx.fill();
      }
    });

    ghosts.forEach(ghost => {
      ctx.fillStyle = '#f0f';
      ctx.fillRect(ghost.x - 10, ghost.y - 10, 20, 20);
      ctx.fillStyle = '#fff';
      ctx.fillRect(ghost.x - 6, ghost.y - 8, 4, 4);
      ctx.fillRect(ghost.x + 2, ghost.y - 8, 4, 4);
    });
  }, [player, dots, ghosts]);

  return (
    <div style={{ display: 'flex', flexDirection: 'column', alignItems: 'center', padding: '20px' }}>
      <h2 style={{ margin: '0 0 10px 0', color: '#333' }}>Pac-Jump</h2>
      <div style={{ marginBottom: '10px', fontSize: '18px', fontWeight: 'bold' }}>
        Score: {score}
      </div>
      <canvas
        ref={canvasRef}
        width={400}
        height={300}
        style={{ border: '2px solid #333', backgroundColor: '#000' }}
      />
      <div style={{ marginTop: '10px', textAlign: 'center' }}>
        <div style={{ marginBottom: '10px', fontSize: '14px' }}>
          Press SPACEBAR to barely jump! Collect dots, avoid ghosts!
        </div>
        {gameState === 'gameOver' && (
          <div style={{ color: 'red', fontWeight: 'bold', marginBottom: '10px' }}>
            Game Over! Ghost got you!
          </div>
        )}
        {gameState === 'won' && (
          <div style={{ color: 'green', fontWeight: 'bold', marginBottom: '10px' }}>
            You Won! All dots collected!
          </div>
        )}
        <button
          onClick={initializeGame}
          style={{
            padding: '10px 20px',
            fontSize: '16px',
            backgroundColor: '#4CAF50',
            color: 'white',
            border: 'none',
            borderRadius: '5px',
            cursor: 'pointer'
          }}
        >
          {gameState === 'playing' ? 'Restart' : 'Play Again'}
        </button>
      </div>
    </div>
  );
};

export default GameZone;
----------------------------------------


================================================================================
GAME GENERATION: boxinggame - 2025-08-09 13:47:17.378117
================================================================================
FULL CLAUDE GENERATED CODE:
----------------------------------------
import React, { useState, useEffect, useCallback } from 'react';

const GameZone = ({ currentGame }) => {
  const [playerHealth, setPlayerHealth] = useState(100);
  const [opponentHealth, setOpponentHealth] = useState(100);
  const [playerStamina, setPlayerStamina] = useState(100);
  const [gameState, setGameState] = useState('ready'); // ready, fighting, gameOver
  const [message, setMessage] = useState('Press Fight to start!');
  const [round, setRound] = useState(1);
  const [playerWins, setPlayerWins] = useState(0);
  const [opponentWins, setOpponentWins] = useState(0);
  const [isPlayerTurn, setIsPlayerTurn] = useState(true);
  const [actionCooldown, setActionCooldown] = useState(false);

  const resetGame = useCallback(() => {
    setPlayerHealth(100);
    setOpponentHealth(100);
    setPlayerStamina(100);
    setGameState('ready');
    setMessage('Press Fight to start!');
    setRound(1);
    setIsPlayerTurn(true);
    setActionCooldown(false);
  }, []);

  const resetMatch = useCallback(() => {
    setPlayerHealth(100);
    setOpponentHealth(100);
    setPlayerStamina(100);
    setGameState('ready');
    setMessage('Press Fight to start next round!');
    setIsPlayerTurn(true);
    setActionCooldown(false);
  }, []);

  const getDamage = (min, max) => Math.floor(Math.random() * (max - min + 1)) + min;

  const playerAttack = (attackType) => {
    if (gameState !== 'fighting' || !isPlayerTurn || actionCooldown || playerStamina < 10) return;

    setActionCooldown(true);
    let damage = 0;
    let staminaCost = 0;

    switch (attackType) {
      case 'jab':
        damage = getDamage(8, 15);
        staminaCost = 10;
        break;
      case 'hook':
        damage = getDamage(12, 20);
        staminaCost = 20;
        break;
      case 'uppercut':
        damage = getDamage(15, 25);
        staminaCost = 30;
        break;
      default:
        return;
    }

    setPlayerStamina(prev => Math.max(0, prev - staminaCost));
    setOpponentHealth(prev => Math.max(0, prev - damage));
    setMessage(`You hit with a ${attackType} for ${damage} damage!`);
    setIsPlayerTurn(false);

    setTimeout(() => {
      setActionCooldown(false);
    }, 800);
  };

  const defend = () => {
    if (gameState !== 'fighting' || !isPlayerTurn || actionCooldown) return;

    setActionCooldown(true);
    setPlayerStamina(prev => Math.min(100, prev + 15));
    setMessage('You defend and recover stamina!');
    setIsPlayerTurn(false);

    setTimeout(() => {
      setActionCooldown(false);
    }, 800);
  };

  const startFight = () => {
    if (gameState === 'ready') {
      setGameState('fighting');
      setMessage('Fight!');
      setIsPlayerTurn(true);
    }
  };

  useEffect(() => {
    if (gameState === 'fighting' && !isPlayerTurn && !actionCooldown) {
      const opponentAttack = () => {
        const attacks = ['jab', 'hook', 'uppercut'];
        const attack = attacks[Math.floor(Math.random() * attacks.length)];
        let damage = 0;

        switch (attack) {
          case 'jab':
            damage = getDamage(6, 12);
            break;
          case 'hook':
            damage = getDamage(10, 16);
            break;
          case 'uppercut':
            damage = getDamage(12, 20);
            break;
        }

        setPlayerHealth(prev => Math.max(0, prev - damage));
        setMessage(`Opponent hits you with a ${attack} for ${damage} damage!`);
        setIsPlayerTurn(true);
      };

      const timer = setTimeout(opponentAttack, 1200);
      return () => clearTimeout(timer);
    }
  }, [isPlayerTurn, gameState, actionCooldown]);

  useEffect(() => {
    if (playerHealth <= 0 || opponentHealth <= 0) {
      setGameState('gameOver');
      if (playerHealth <= 0) {
        setOpponentWins(prev => prev + 1);
        setMessage('You lose this round!');
      } else {
        setPlayerWins(prev => prev + 1);
        setMessage('You win this round!');
      }
      setRound(prev => prev + 1);
    }
  }, [playerHealth, opponentHealth]);

  useEffect(() => {
    if (playerStamina < 100 && gameState === 'fighting') {
      const staminaTimer = setInterval(() => {
        setPlayerStamina(prev => Math.min(100, prev + 2));
      }, 1000);
      return () => clearInterval(staminaTimer);
    }
  }, [playerStamina, gameState]);

  const getHealthBarColor = (health) => {
    if (health > 60) return '#4CAF50';
    if (health > 30) return '#FFC107';
    return '#F44336';
  };

  return (
    <div style={{
      display: 'flex',
      flexDirection: 'column',
      alignItems: 'center',
      padding: '20px',
      fontFamily: 'Arial, sans-serif',
      backgroundColor: '#1a1a1a',
      color: 'white',
      minHeight: '100vh'
    }}>
      <h1 style={{ marginBottom: '20px', color: '#FFD700' }}>Boxing Game</h1>
      
      <div style={{
        display: 'flex',
        justifyContent: 'space-between',
        width: '400px',
        marginBottom: '20px'
      }}>
        <div style={{ textAlign: 'center' }}>
          <h3>You</h3>
          <div>Wins: {playerWins}</div>
        </div>
        <div style={{ textAlign: 'center' }}>
          <h3>Round {round}</h3>
        </div>
        <div style={{ textAlign: 'center' }}>
          <h3>Opponent</h3>
          <div>Wins: {opponentWins}</div>
        </div>
      </div>

      <div style={{
        width: '400px',
        height: '300px',
        border: '3px solid #333',
        borderRadius: '10px',
        backgroundColor: '#2a2a2a',
        display: 'flex',
        flexDirection: 'column',
        justifyContent: 'space-between',
        padding: '20px',
        marginBottom: '20px'
      }}>
        <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
          <div style={{ textAlign: 'center' }}>
            <div style={{ fontSize: '60px', marginBottom: '10px' }}>ü•ä</div>
            <div>YOU</div>
            <div style={{
              width: '80px',
              height: '10px',
              backgroundColor: '#333',
              borderRadius: '5px',
              overflow: 'hidden',
              margin: '5px auto'
            }}>
              <div style={{
                width: `
----------------------------------------


================================================================================
GAME GENERATION: Space Runner - 2025-08-09 13:50:37.586564
================================================================================
FULL CLAUDE GENERATED CODE:
----------------------------------------
import React, { useState, useEffect, useCallback } from 'react';

const GameZone = ({ currentGame }) => {
  const [gameState, setGameState] = useState('menu');
  const [player, setPlayer] = useState({ x: 50, y: 150 });
  const [obstacles, setObstacles] = useState([]);
  const [score, setScore] = useState(0);
  const [gameSpeed, setGameSpeed] = useState(2);

  const resetGame = useCallback(() => {
    setPlayer({ x: 50, y: 150 });
    setObstacles([]);
    setScore(0);
    setGameSpeed(2);
    setGameState('playing');
  }, []);

  const gameOver = useCallback(() => {
    setGameState('gameOver');
  }, []);

  useEffect(() => {
    if (gameState !== 'playing') return;

    const gameLoop = setInterval(() => {
      setObstacles(prev => {
        const newObstacles = prev
          .map(obs => ({ ...obs, x: obs.x - gameSpeed }))
          .filter(obs => obs.x > -20);

        if (Math.random() < 0.02) {
          newObstacles.push({
            x: 400,
            y: Math.random() * 200 + 50,
            width: 20,
            height: 40
          });
        }

        const collision = newObstacles.some(obs => 
          player.x < obs.x + obs.width &&
          player.x + 20 > obs.x &&
          player.y < obs.y + obs.height &&
          player.y + 20 > obs.y
        );

        if (collision) {
          gameOver();
        }

        return newObstacles;
      });

      setScore(prev => prev + 1);
      setGameSpeed(prev => prev + 0.001);
    }, 50);

    return () => clearInterval(gameLoop);
  }, [gameState, player, gameSpeed, gameOver]);

  useEffect(() => {
    if (gameState !== 'playing') return;

    const handleKeyPress = (e) => {
      if (e.key === 'ArrowUp') {
        setPlayer(prev => ({ ...prev, y: Math.max(0, prev.y - 15) }));
      } else if (e.key === 'ArrowDown') {
        setPlayer(prev => ({ ...prev, y: Math.min(280, prev.y + 15) }));
      }
    };

    window.addEventListener('keydown', handleKeyPress);
    return () => window.removeEventListener('keydown', handleKeyPress);
  }, [gameState]);

  const containerStyle = {
    width: '400px',
    height: '300px',
    border: '2px solid #333',
    position: 'relative',
    backgroundColor: '#001122',
    overflow: 'hidden',
    margin: '20px auto',
    fontFamily: 'Arial, sans-serif'
  };

  const playerStyle = {
    position: 'absolute',
    left: `${player.x}px`,
    top: `${player.y}px`,
    width: '20px',
    height: '20px',
    backgroundColor: '#00ff00',
    borderRadius: '50%',
    transition: 'top 0.1s ease'
  };

  const obstacleStyle = (obs) => ({
    position: 'absolute',
    left: `${obs.x}px`,
    top: `${obs.y}px`,
    width: `${obs.width}px`,
    height: `${obs.height}px`,
    backgroundColor: '#ff0000'
  });

  const overlayStyle = {
    position: 'absolute',
    top: 0,
    left: 0,
    width: '100%',
    height: '100%',
    backgroundColor: 'rgba(0,0,0,0.8)',
    display: 'flex',
    flexDirection: 'column',
    justifyContent: 'center',
    alignItems: 'center',
    color: 'white',
    textAlign: 'center'
  };

  const buttonStyle = {
    padding: '10px 20px',
    fontSize: '16px',
    backgroundColor: '#0066cc',
    color: 'white',
    border: 'none',
    borderRadius: '5px',
    cursor: 'pointer',
    margin: '5px'
  };

  const scoreStyle = {
    position: 'absolute',
    top: '10px',
    right: '10px',
    color: 'white',
    fontSize: '16px',
    fontWeight: 'bold'
  };

  if (gameState === 'menu') {
    return (
      <div style={containerStyle}>
        <div style={overlayStyle}>
          <h2>Space Runner</h2>
          <p>Use arrow keys to avoid obstacles!</p>
          <button style={buttonStyle} onClick={resetGame}>
            Start Game
          </button>
        </div>
      </div>
    );
  }

  if (gameState === 'gameOver') {
    return (
      <div style={containerStyle}>
        <div style={overlayStyle}>
          <h2>Game Over!</h2>
          <p>Final Score: {score}</p>
          <button style={buttonStyle} onClick={resetGame}>
            Play Again
          </button>
          <button style={buttonStyle} onClick={() => setGameState('menu')}>
            Main Menu
          </button>
        </div>
      </div>
    );
  }

  return (
    <div style={containerStyle}>
      <div style={scoreStyle}>Score: {score}</div>
      <div style={playerStyle}></div>
      {obstacles.map((obs, index) => (
        <div key={index} style={obstacleStyle(obs)}></div>
      ))}
    </div>
  );
};

export default GameZone;
----------------------------------------


================================================================================
GAME GENERATION: Space Runner - 2025-08-09 13:50:41.000205
================================================================================
FULL CLAUDE GENERATED CODE:
----------------------------------------
import React, { useState, useEffect, useCallback, useRef } from 'react';

const GameZone = ({ currentGame }) => {
  const [gameState, setGameState] = useState('playing');
  const [score, setScore] = useState(0);
  const [playerY, setPlayerY] = useState(150);
  const [obstacles, setObstacles] = useState([]);
  const [stars, setStars] = useState([]);
  const gameLoopRef = useRef();
  const keysRef = useRef({ up: false, down: false });

  const GAME_WIDTH = 400;
  const GAME_HEIGHT = 300;
  const PLAYER_SIZE = 20;
  const OBSTACLE_WIDTH = 15;
  const OBSTACLE_HEIGHT = 40;
  const PLAYER_SPEED = 3;
  const OBSTACLE_SPEED = 2;

  const initializeGame = useCallback(() => {
    setGameState('playing');
    setScore(0);
    setPlayerY(150);
    setObstacles([]);
    setStars(Array.from({ length: 20 }, (_, i) => ({
      id: i,
      x: Math.random() * GAME_WIDTH,
      y: Math.random() * GAME_HEIGHT,
      size: Math.random() * 2 + 1
    })));
  }, []);

  const checkCollision = useCallback((player, obstacle) => {
    return player.x < obstacle.x + obstacle.width &&
           player.x + player.width > obstacle.x &&
           player.y < obstacle.y + obstacle.height &&
           player.y + player.height > obstacle.y;
  }, []);

  const gameLoop = useCallback(() => {
    if (gameState !== 'playing') return;

    setPlayerY(prevY => {
      let newY = prevY;
      if (keysRef.current.up && newY > 0) newY -= PLAYER_SPEED;
      if (keysRef.current.down && newY < GAME_HEIGHT - PLAYER_SIZE) newY += PLAYER_SPEED;
      return newY;
    });

    setObstacles(prevObstacles => {
      let newObstacles = prevObstacles.map(obs => ({
        ...obs,
        x: obs.x - OBSTACLE_SPEED
      })).filter(obs => obs.x > -OBSTACLE_WIDTH);

      if (Math.random() < 0.02) {
        newObstacles.push({
          id: Date.now(),
          x: GAME_WIDTH,
          y: Math.random() * (GAME_HEIGHT - OBSTACLE_HEIGHT),
          width: OBSTACLE_WIDTH,
          height: OBSTACLE_HEIGHT
        });
      }

      return newObstacles;
    });

    setStars(prevStars => 
      prevStars.map(star => ({
        ...star,
        x: star.x - 0.5 < 0 ? GAME_WIDTH : star.x - 0.5
      }))
    );

    setScore(prevScore => prevScore + 1);
  }, [gameState]);

  useEffect(() => {
    if (gameState === 'playing') {
      const player = { x: 20, y: playerY, width: PLAYER_SIZE, height: PLAYER_SIZE };
      
      for (let obstacle of obstacles) {
        if (checkCollision(player, obstacle)) {
          setGameState('gameOver');
          break;
        }
      }
    }
  }, [playerY, obstacles, gameState, checkCollision]);

  useEffect(() => {
    const handleKeyDown = (e) => {
      if (e.code === 'ArrowUp' || e.code === 'KeyW') {
        keysRef.current.up = true;
        e.preventDefault();
      }
      if (e.code === 'ArrowDown' || e.code === 'KeyS') {
        keysRef.current.down = true;
        e.preventDefault();
      }
    };

    const handleKeyUp = (e) => {
      if (e.code === 'ArrowUp' || e.code === 'KeyW') {
        keysRef.current.up = false;
      }
      if (e.code === 'ArrowDown' || e.code === 'KeyS') {
        keysRef.current.down = false;
      }
    };

    window.addEventListener('keydown', handleKeyDown);
    window.addEventListener('keyup', handleKeyUp);

    return () => {
      window.removeEventListener('keydown', handleKeyDown);
      window.removeEventListener('keyup', handleKeyUp);
    };
  }, []);

  useEffect(() => {
    initializeGame();
  }, [initializeGame]);

  useEffect(() => {
    if (gameState === 'playing') {
      gameLoopRef.current = setInterval(gameLoop, 16);
    } else {
      clearInterval(gameLoopRef.current);
    }

    return () => clearInterval(gameLoopRef.current);
  }, [gameState, gameLoop]);

  return (
    <div style={{
      display: 'flex',
      flexDirection: 'column',
      alignItems: 'center',
      padding: '20px',
      fontFamily: 'Arial, sans-serif'
    }}>
      <h2 style={{ margin: '0 0 10px 0', color: '#fff' }}>Space Runner</h2>
      
      <div style={{
        display: 'flex',
        justifyContent: 'space-between',
        width: `${GAME_WIDTH}px`,
        marginBottom: '10px',
        color: '#fff'
      }}>
        <div>Score: {score}</div>
        <button 
          onClick={initializeGame}
          style={{
            padding: '5px 15px',
            backgroundColor: '#4CAF50',
            color: 'white',
            border: 'none',
            borderRadius: '3px',
            cursor: 'pointer'
          }}
        >
          Restart
        </button>
      </div>

      <div style={{
        position: 'relative',
        width: `${GAME_WIDTH}px`,
        height: `${GAME_HEIGHT}px`,
        backgroundColor: '#000',
        border: '2px solid #333',
        overflow: 'hidden'
      }}>
        {stars.map(star => (
          <div
            key={star.id}
            style={{
              position: 'absolute',
              left: `${star.x}px`,
              top: `${star.y}px`,
              width: `${star.size}px`,
              height: `${star.size}px`,
              backgroundColor: '#fff',
              borderRadius: '50%'
            }}
          />
        ))}

        <div style={{
          position: 'absolute',
          left: '20px',
          top: `${playerY}px`,
          width: `${PLAYER_SIZE}px`,
          height: `${PLAYER_SIZE}px`,
          backgroundColor: '#00ff00',
          clipPath: 'polygon(0% 50%, 100% 0%, 80% 50%, 100% 100%)'
        }} />

        {obstacles.map(obstacle => (
          <div
            key={obstacle.id}
            style={{
              position: 'absolute',
              left: `${obstacle.x}px`,
              top: `${obstacle.y}px`,
              width: `${obstacle.width}px`,
              height: `${obstacle.height}px`,
              backgroundColor: '#ff4444'
            }}
          />
        ))}

        {gameState === 'gameOver' && (
          <div style={{
            position: 'absolute',
            top: '50%',
            left: '50%',
            transform: 'translate(-50%, -50%)',
            backgroundColor: 'rgba(0, 0, 0, 0.8)',
            color: '#fff',
            
----------------------------------------


================================================================================
GAME GENERATION: Jungle Jump - 2025-08-09 13:51:02.021997
================================================================================
FULL CLAUDE GENERATED CODE:
----------------------------------------
import React, { useState, useEffect, useCallback } from 'react';

const GameZone = ({ currentGame }) => {
  const [gameState, setGameState] = useState('menu');
  const [playerY, setPlayerY] = useState(250);
  const [playerVelocity, setPlayerVelocity] = useState(0);
  const [platforms, setPlatforms] = useState([]);
  const [score, setScore] = useState(0);
  const [gameSpeed, setGameSpeed] = useState(2);

  const GRAVITY = 0.8;
  const JUMP_FORCE = -15;
  const PLAYER_SIZE = 20;
  const GROUND_Y = 270;

  const initializePlatforms = useCallback(() => {
    const initialPlatforms = [];
    for (let i = 0; i < 5; i++) {
      initialPlatforms.push({
        x: 500 + i * 200,
        y: Math.random() * 150 + 100,
        width: 80,
        height: 20,
        id: i
      });
    }
    return initialPlatforms;
  }, []);

  const resetGame = useCallback(() => {
    setPlayerY(250);
    setPlayerVelocity(0);
    setPlatforms(initializePlatforms());
    setScore(0);
    setGameSpeed(2);
    setGameState('playing');
  }, [initializePlatforms]);

  const startGame = () => {
    resetGame();
  };

  const jump = useCallback(() => {
    if (gameState === 'playing') {
      setPlayerVelocity(JUMP_FORCE);
    }
  }, [gameState]);

  useEffect(() => {
    const handleKeyPress = (e) => {
      if (e.code === 'Space' || e.code === 'ArrowUp') {
        e.preventDefault();
        jump();
      }
    };

    window.addEventListener('keydown', handleKeyPress);
    return () => window.removeEventListener('keydown', handleKeyPress);
  }, [jump]);

  useEffect(() => {
    if (gameState !== 'playing') return;

    const gameLoop = setInterval(() => {
      setPlayerY(prevY => {
        let newY = prevY + playerVelocity;
        
        if (newY >= GROUND_Y) {
          newY = GROUND_Y;
          setPlayerVelocity(0);
        }
        
        return newY;
      });

      setPlayerVelocity(prevVel => prevVel + GRAVITY);

      setPlatforms(prevPlatforms => {
        const newPlatforms = prevPlatforms.map(platform => ({
          ...platform,
          x: platform.x - gameSpeed
        })).filter(platform => platform.x > -100);

        if (newPlatforms.length < 5) {
          const lastPlatform = newPlatforms[newPlatforms.length - 1];
          const newX = lastPlatform ? lastPlatform.x + 200 : 500;
          newPlatforms.push({
            x: newX,
            y: Math.random() * 150 + 100,
            width: 80,
            height: 20,
            id: Date.now()
          });
        }

        return newPlatforms;
      });

      setScore(prevScore => prevScore + 1);
      
      if (score > 0 && score % 500 === 0) {
        setGameSpeed(prevSpeed => prevSpeed + 0.5);
      }
    }, 16);

    return () => clearInterval(gameLoop);
  }, [gameState, playerVelocity, gameSpeed, score]);

  useEffect(() => {
    if (gameState !== 'playing') return;

    platforms.forEach(platform => {
      if (
        50 < platform.x + platform.width &&
        50 + PLAYER_SIZE > platform.x &&
        playerY < platform.y + platform.height &&
        playerY + PLAYER_SIZE > platform.y &&
        playerVelocity > 0
      ) {
        setPlayerY(platform.y - PLAYER_SIZE);
        setPlayerVelocity(JUMP_FORCE * 0.8);
      }
    });

    if (playerY > 300) {
      setGameState('gameOver');
    }
  }, [playerY, platforms, playerVelocity, gameState]);

  if (gameState === 'menu') {
    return (
      <div style={{
        width: '400px',
        height: '300px',
        backgroundColor: '#87CEEB',
        display: 'flex',
        flexDirection: 'column',
        justifyContent: 'center',
        alignItems: 'center',
        fontFamily: 'Arial, sans-serif',
        position: 'relative'
      }}>
        <h1 style={{ color: '#2F4F2F', marginBottom: '20px' }}>üêí Jungle Jump</h1>
        <p style={{ color: '#2F4F2F', marginBottom: '20px', textAlign: 'center' }}>
          Press SPACE or ‚Üë to jump on platforms!<br />
          Avoid falling to the ground!
        </p>
        <button
          onClick={startGame}
          style={{
            padding: '10px 20px',
            fontSize: '18px',
            backgroundColor: '#32CD32',
            color: 'white',
            border: 'none',
            borderRadius: '5px',
            cursor: 'pointer'
          }}
        >
          Start Game
        </button>
      </div>
    );
  }

  if (gameState === 'gameOver') {
    return (
      <div style={{
        width: '400px',
        height: '300px',
        backgroundColor: '#87CEEB',
        display: 'flex',
        flexDirection: 'column',
        justifyContent: 'center',
        alignItems: 'center',
        fontFamily: 'Arial, sans-serif'
      }}>
        <h1 style={{ color: '#DC143C', marginBottom: '20px' }}>Game Over!</h1>
        <p style={{ color: '#2F4F2F', marginBottom: '20px' }}>Score: {score}</p>
        <button
          onClick={resetGame}
          style={{
            padding: '10px 20px',
            fontSize: '18px',
            backgroundColor: '#32CD32',
            color: 'white',
            border: 'none',
            borderRadius: '5px',
            cursor: 'pointer'
          }}
        >
          Play Again
        </button>
      </div>
    );
  }

  return (
    <div 
      style={{
        width: '400px',
        height: '300px',
        backgroundColor: '#87CEEB',
        position: 'relative',
        overflow: 'hidden',
        fontFamily: 'Arial, sans-serif'
      }}
      onClick={jump}
    >
      <div style={{
        position: 'absolute',
        top: '10px',
        left: '10px',
        color: '#2F4F2F',
        fontSize: '16px',
        fontWeight: 'bold'
      }}>
        Score: {score}
      </div>

      <div style={{
        position: 'absolute',
        top: '10px',
        right: '10px',
        color: '#2F4F2F',
        fontSize: '12px'
      }}>
        SPACE/‚Üë to Jump
      </div>

      <div
        style={{
          position: 'absolute',
          left: '50px',
          top: `${playerY}px`,
          width: `${PLAYER_SIZE}px`,
          height: `${PLAYER_SIZE}px`,
          backgroundColor: '#8B4513',
          borderRadius: '50%
----------------------------------------


================================================================================
GAME GENERATION: Jungle Jump - 2025-08-09 13:51:07.033367
================================================================================
FULL CLAUDE GENERATED CODE:
----------------------------------------
import React, { useState, useEffect, useCallback } from 'react';

const GameZone = ({ currentGame }) => {
  const [gameState, setGameState] = useState('playing');
  const [score, setScore] = useState(0);
  const [playerY, setPlayerY] = useState(200);
  const [playerVelY, setPlayerVelY] = useState(0);
  const [obstacles, setObstacles] = useState([]);
  const [gameTime, setGameTime] = useState(0);
  const [keys, setKeys] = useState({});

  const GRAVITY = 0.8;
  const JUMP_FORCE = -15;
  const GROUND_Y = 250;
  const PLAYER_SIZE = 30;
  const OBSTACLE_WIDTH = 20;
  const OBSTACLE_HEIGHT = 40;
  const GAME_WIDTH = 400;
  const GAME_HEIGHT = 300;

  const resetGame = useCallback(() => {
    setGameState('playing');
    setScore(0);
    setPlayerY(200);
    setPlayerVelY(0);
    setObstacles([]);
    setGameTime(0);
  }, []);

  const jump = useCallback(() => {
    if (playerY >= GROUND_Y - PLAYER_SIZE) {
      setPlayerVelY(JUMP_FORCE);
    }
  }, [playerY]);

  useEffect(() => {
    const handleKeyDown = (e) => {
      setKeys(prev => ({ ...prev, [e.code]: true }));
      if (e.code === 'Space' || e.code === 'ArrowUp') {
        e.preventDefault();
        jump();
      }
    };

    const handleKeyUp = (e) => {
      setKeys(prev => ({ ...prev, [e.code]: false }));
    };

    window.addEventListener('keydown', handleKeyDown);
    window.addEventListener('keyup', handleKeyUp);

    return () => {
      window.removeEventListener('keydown', handleKeyDown);
      window.removeEventListener('keyup', handleKeyUp);
    };
  }, [jump]);

  useEffect(() => {
    if (gameState !== 'playing') return;

    const gameLoop = setInterval(() => {
      setGameTime(prev => prev + 1);

      setPlayerY(prevY => {
        const newY = prevY + playerVelY;
        return Math.min(newY, GROUND_Y - PLAYER_SIZE);
      });

      setPlayerVelY(prevVel => {
        if (playerY >= GROUND_Y - PLAYER_SIZE && prevVel > 0) {
          return 0;
        }
        return prevVel + GRAVITY;
      });

      setObstacles(prevObstacles => {
        let newObstacles = prevObstacles
          .map(obs => ({ ...obs, x: obs.x - 3 }))
          .filter(obs => obs.x > -OBSTACLE_WIDTH);

        if (Math.random() < 0.02) {
          newObstacles.push({
            x: GAME_WIDTH,
            y: GROUND_Y - OBSTACLE_HEIGHT,
            width: OBSTACLE_WIDTH,
            height: OBSTACLE_HEIGHT
          });
        }

        const playerLeft = 50;
        const playerRight = playerLeft + PLAYER_SIZE;
        const playerTop = playerY;
        const playerBottom = playerY + PLAYER_SIZE;

        for (let obs of newObstacles) {
          if (playerRight > obs.x && 
              playerLeft < obs.x + obs.width && 
              playerBottom > obs.y && 
              playerTop < obs.y + obs.height) {
            setGameState('gameOver');
            break;
          }
        }

        return newObstacles;
      });

      setScore(prev => prev + 1);
    }, 16);

    return () => clearInterval(gameLoop);
  }, [gameState, playerY, playerVelY]);

  return (
    <div style={{
      display: 'flex',
      flexDirection: 'column',
      alignItems: 'center',
      padding: '20px',
      fontFamily: 'Arial, sans-serif'
    }}>
      <h2 style={{ margin: '0 0 10px 0', color: '#2d5a27' }}>Jungle Jump</h2>
      
      <div style={{ marginBottom: '10px', fontSize: '18px', fontWeight: 'bold' }}>
        Score: {score}
      </div>

      <div style={{
        position: 'relative',
        width: GAME_WIDTH,
        height: GAME_HEIGHT,
        backgroundColor: '#87CEEB',
        border: '3px solid #2d5a27',
        overflow: 'hidden'
      }}>
        <div style={{
          position: 'absolute',
          bottom: 0,
          width: '100%',
          height: '50px',
          backgroundColor: '#228B22'
        }} />

        <div style={{
          position: 'absolute',
          left: '50px',
          top: `${playerY}px`,
          width: `${PLAYER_SIZE}px`,
          height: `${PLAYER_SIZE}px`,
          backgroundColor: '#8B4513',
          borderRadius: '50%',
          border: '2px solid #654321'
        }} />

        {obstacles.map((obs, index) => (
          <div key={index} style={{
            position: 'absolute',
            left: `${obs.x}px`,
            top: `${obs.y}px`,
            width: `${obs.width}px`,
            height: `${obs.height}px`,
            backgroundColor: '#8B4513',
            border: '1px solid #654321'
          }} />
        ))}

        {gameState === 'gameOver' && (
          <div style={{
            position: 'absolute',
            top: '50%',
            left: '50%',
            transform: 'translate(-50%, -50%)',
            backgroundColor: 'rgba(0,0,0,0.8)',
            color: 'white',
            padding: '20px',
            borderRadius: '10px',
            textAlign: 'center'
          }}>
            <h3 style={{ margin: '0 0 10px 0' }}>Game Over!</h3>
            <p style={{ margin: '0 0 15px 0' }}>Final Score: {score}</p>
            <button onClick={resetGame} style={{
              padding: '10px 20px',
              fontSize: '16px',
              backgroundColor: '#228B22',
              color: 'white',
              border: 'none',
              borderRadius: '5px',
              cursor: 'pointer'
            }}>
              Play Again
            </button>
          </div>
        )}
      </div>

      <div style={{ marginTop: '10px', textAlign: 'center', fontSize: '14px' }}>
        <p>Press SPACE or UP ARROW to jump!</p>
        <button onClick={resetGame} style={{
          padding: '8px 16px',
          fontSize: '14px',
          backgroundColor: '#2d5a27',
          color: 'white',
          border: 'none',
          borderRadius: '5px',
          cursor: 'pointer',
          marginTop: '5px'
        }}>
          Restart Game
        </button>
      </div>
    </div>
  );
};

export default GameZone;
----------------------------------------


================================================================================
GAME GENERATION: Space Runner - 2025-08-09 13:51:30.882798
================================================================================
FULL CLAUDE GENERATED CODE:
----------------------------------------
import React, { useState, useEffect, useCallback } from 'react';

const GameZone = ({ currentGame }) => {
  const [gameState, setGameState] = useState('playing');
  const [score, setScore] = useState(0);
  const [playerY, setPlayerY] = useState(150);
  const [obstacles, setObstacles] = useState([]);
  const [gameSpeed, setGameSpeed] = useState(2);

  const resetGame = useCallback(() => {
    setGameState('playing');
    setScore(0);
    setPlayerY(150);
    setObstacles([]);
    setGameSpeed(2);
  }, []);

  useEffect(() => {
    if (gameState !== 'playing') return;

    const gameLoop = setInterval(() => {
      setObstacles(prev => {
        let newObstacles = prev.map(obs => ({
          ...obs,
          x: obs.x - gameSpeed
        })).filter(obs => obs.x > -50);

        if (Math.random() < 0.02) {
          newObstacles.push({
            x: 450,
            y: Math.random() * 200 + 50,
            width: 30,
            height: 30
          });
        }

        const collision = newObstacles.some(obs => 
          obs.x < 70 && obs.x > 20 && 
          obs.y < playerY + 30 && obs.y + obs.height > playerY
        );

        if (collision) {
          setGameState('gameOver');
        }

        return newObstacles;
      });

      setScore(prev => prev + 1);
      setGameSpeed(prev => prev + 0.001);
    }, 50);

    return () => clearInterval(gameLoop);
  }, [gameState, playerY, gameSpeed]);

  useEffect(() => {
    const handleKeyPress = (e) => {
      if (gameState !== 'playing') return;
      
      if (e.key === 'ArrowUp' || e.key === ' ') {
        setPlayerY(prev => Math.max(0, prev - 40));
      }
      if (e.key === 'ArrowDown') {
        setPlayerY(prev => Math.min(270, prev + 40));
      }
    };

    window.addEventListener('keydown', handleKeyPress);
    return () => window.removeEventListener('keydown', handleKeyPress);
  }, [gameState]);

  return (
    <div style={{
      width: '400px',
      height: '300px',
      border: '2px solid #333',
      position: 'relative',
      backgroundColor: '#001122',
      overflow: 'hidden',
      margin: '20px auto'
    }}>
      <div style={{
        position: 'absolute',
        top: '10px',
        left: '10px',
        color: '#fff',
        fontSize: '16px',
        fontFamily: 'monospace'
      }}>
        Score: {score}
      </div>

      <div style={{
        position: 'absolute',
        left: '50px',
        top: `${playerY}px`,
        width: '20px',
        height: '30px',
        backgroundColor: '#00ff00',
        clipPath: 'polygon(0% 50%, 100% 0%, 80% 50%, 100% 100%)'
      }} />

      {obstacles.map((obs, index) => (
        <div
          key={index}
          style={{
            position: 'absolute',
            left: `${obs.x}px`,
            top: `${obs.y}px`,
            width: `${obs.width}px`,
            height: `${obs.height}px`,
            backgroundColor: '#ff4444',
            borderRadius: '4px'
          }}
        />
      ))}

      {gameState === 'gameOver' && (
        <div style={{
          position: 'absolute',
          top: '50%',
          left: '50%',
          transform: 'translate(-50%, -50%)',
          backgroundColor: 'rgba(0,0,0,0.8)',
          color: '#fff',
          padding: '20px',
          borderRadius: '10px',
          textAlign: 'center',
          fontFamily: 'monospace'
        }}>
          <div style={{ fontSize: '18px', marginBottom: '10px' }}>
            Game Over!
          </div>
          <div style={{ marginBottom: '15px' }}>
            Final Score: {score}
          </div>
          <button
            onClick={resetGame}
            style={{
              padding: '8px 16px',
              backgroundColor: '#00ff00',
              border: 'none',
              borderRadius: '4px',
              cursor: 'pointer',
              fontSize: '14px'
            }}
          >
            Play Again
          </button>
        </div>
      )}

      <div style={{
        position: 'absolute',
        bottom: '10px',
        left: '10px',
        color: '#888',
        fontSize: '12px',
        fontFamily: 'monospace'
      }}>
        Use ‚Üë‚Üì or SPACE to move
      </div>
    </div>
  );
};

export default GameZone;
----------------------------------------


================================================================================
GAME GENERATION: Space Runner - 2025-08-09 13:51:31.814208
================================================================================
FULL CLAUDE GENERATED CODE:
----------------------------------------
import React, { useState, useEffect, useRef, useCallback } from 'react';

const GameZone = ({ currentGame }) => {
  const canvasRef = useRef(null);
  const animationRef = useRef(null);
  const keysRef = useRef({});
  
  const [gameState, setGameState] = useState({
    player: { x: 50, y: 150, width: 20, height: 20 },
    obstacles: [],
    score: 0,
    gameOver: false,
    speed: 2
  });

  const resetGame = useCallback(() => {
    setGameState({
      player: { x: 50, y: 150, width: 20, height: 20 },
      obstacles: [],
      score: 0,
      gameOver: false,
      speed: 2
    });
  }, []);

  const generateObstacle = useCallback(() => {
    return {
      x: 400,
      y: Math.random() * 260 + 20,
      width: 15,
      height: Math.random() * 40 + 20,
      id: Date.now()
    };
  }, []);

  const checkCollision = useCallback((rect1, rect2) => {
    return rect1.x < rect2.x + rect2.width &&
           rect1.x + rect1.width > rect2.x &&
           rect1.y < rect2.y + rect2.height &&
           rect1.y + rect1.height > rect2.y;
  }, []);

  const gameLoop = useCallback(() => {
    setGameState(prevState => {
      if (prevState.gameOver) return prevState;

      const newState = { ...prevState };
      
      if (keysRef.current.ArrowUp && newState.player.y > 0) {
        newState.player.y -= 3;
      }
      if (keysRef.current.ArrowDown && newState.player.y < 280) {
        newState.player.y += 3;
      }

      newState.obstacles = newState.obstacles
        .map(obstacle => ({ ...obstacle, x: obstacle.x - newState.speed }))
        .filter(obstacle => obstacle.x > -obstacle.width);

      if (Math.random() < 0.02) {
        newState.obstacles.push(generateObstacle());
      }

      for (let obstacle of newState.obstacles) {
        if (checkCollision(newState.player, obstacle)) {
          newState.gameOver = true;
          break;
        }
      }

      newState.score += 1;
      if (newState.score % 500 === 0) {
        newState.speed += 0.5;
      }

      return newState;
    });
  }, [generateObstacle, checkCollision]);

  const draw = useCallback(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;
    
    const ctx = canvas.getContext('2d');
    ctx.fillStyle = '#000033';
    ctx.fillRect(0, 0, 400, 300);

    ctx.fillStyle = '#00ff00';
    ctx.fillRect(gameState.player.x, gameState.player.y, gameState.player.width, gameState.player.height);

    ctx.fillStyle = '#ff0000';
    gameState.obstacles.forEach(obstacle => {
      ctx.fillRect(obstacle.x, obstacle.y, obstacle.width, obstacle.height);
    });

    ctx.fillStyle = '#ffffff';
    ctx.font = '16px Arial';
    ctx.fillText(`Score: ${gameState.score}`, 10, 25);

    if (gameState.gameOver) {
      ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
      ctx.fillRect(0, 0, 400, 300);
      ctx.fillStyle = '#ffffff';
      ctx.font = '24px Arial';
      ctx.fillText('Game Over!', 140, 140);
      ctx.font = '16px Arial';
      ctx.fillText(`Final Score: ${gameState.score}`, 140, 170);
    }
  }, [gameState]);

  useEffect(() => {
    const handleKeyDown = (e) => {
      keysRef.current[e.code] = true;
    };

    const handleKeyUp = (e) => {
      keysRef.current[e.code] = false;
    };

    window.addEventListener('keydown', handleKeyDown);
    window.addEventListener('keyup', handleKeyUp);

    return () => {
      window.removeEventListener('keydown', handleKeyDown);
      window.removeEventListener('keyup', handleKeyUp);
    };
  }, []);

  useEffect(() => {
    const animate = () => {
      gameLoop();
      draw();
      animationRef.current = requestAnimationFrame(animate);
    };

    animationRef.current = requestAnimationFrame(animate);

    return () => {
      if (animationRef.current) {
        cancelAnimationFrame(animationRef.current);
      }
    };
  }, [gameLoop, draw]);

  return (
    <div style={{ 
      display: 'flex', 
      flexDirection: 'column', 
      alignItems: 'center', 
      padding: '20px',
      fontFamily: 'Arial, sans-serif'
    }}>
      <h2 style={{ margin: '0 0 10px 0', color: '#333' }}>Space Runner</h2>
      <canvas
        ref={canvasRef}
        width={400}
        height={300}
        style={{
          border: '2px solid #333',
          backgroundColor: '#000033'
        }}
      />
      <div style={{ marginTop: '10px' }}>
        <p style={{ margin: '5px 0', fontSize: '14px' }}>
          Use arrow keys to move up and down. Avoid the red obstacles!
        </p>
        <button
          onClick={resetGame}
          style={{
            padding: '8px 16px',
            fontSize: '14px',
            backgroundColor: '#4CAF50',
            color: 'white',
            border: 'none',
            borderRadius: '4px',
            cursor: 'pointer'
          }}
        >
          Restart Game
        </button>
      </div>
    </div>
  );
};

export default GameZone;
----------------------------------------


================================================================================
GAME GENERATION: Jungle Jump - 2025-08-09 13:51:54.993644
================================================================================
FULL CLAUDE GENERATED CODE:
----------------------------------------
import React, { useState, useEffect, useCallback } from 'react';

const GameZone = ({ currentGame }) => {
  const [playerY, setPlayerY] = useState(250);
  const [playerVelocity, setPlayerVelocity] = useState(0);
  const [obstacles, setObstacles] = useState([]);
  const [score, setScore] = useState(0);
  const [gameOver, setGameOver] = useState(false);
  const [gameStarted, setGameStarted] = useState(false);

  const GRAVITY = 0.5;
  const JUMP_FORCE = -12;
  const GROUND_Y = 250;
  const PLAYER_SIZE = 20;
  const OBSTACLE_WIDTH = 15;
  const OBSTACLE_HEIGHT = 40;

  const jump = useCallback(() => {
    if (!gameStarted) {
      setGameStarted(true);
      return;
    }
    if (!gameOver && playerY >= GROUND_Y - PLAYER_SIZE) {
      setPlayerVelocity(JUMP_FORCE);
    }
  }, [gameOver, playerY, gameStarted]);

  const resetGame = () => {
    setPlayerY(GROUND_Y);
    setPlayerVelocity(0);
    setObstacles([]);
    setScore(0);
    setGameOver(false);
    setGameStarted(false);
  };

  useEffect(() => {
    const handleKeyPress = (e) => {
      if (e.code === 'Space' || e.key === ' ') {
        e.preventDefault();
        jump();
      }
    };

    window.addEventListener('keydown', handleKeyPress);
    return () => window.removeEventListener('keydown', handleKeyPress);
  }, [jump]);

  useEffect(() => {
    if (!gameStarted || gameOver) return;

    const gameLoop = setInterval(() => {
      setPlayerVelocity(prev => prev + GRAVITY);
      
      setPlayerY(prev => {
        const newY = prev + playerVelocity;
        return Math.min(newY, GROUND_Y);
      });

      setObstacles(prev => {
        let newObstacles = prev.map(obs => ({ ...obs, x: obs.x - 3 }))
          .filter(obs => obs.x > -OBSTACLE_WIDTH);

        if (newObstacles.length === 0 || newObstacles[newObstacles.length - 1].x < 200) {
          newObstacles.push({ x: 400, y: GROUND_Y - OBSTACLE_HEIGHT });
        }

        return newObstacles;
      });

      setScore(prev => prev + 1);
    }, 16);

    return () => clearInterval(gameLoop);
  }, [gameStarted, gameOver, playerVelocity]);

  useEffect(() => {
    if (!gameStarted || gameOver) return;

    const checkCollision = () => {
      const playerX = 50;
      const playerBottom = playerY + PLAYER_SIZE;

      for (let obstacle of obstacles) {
        if (playerX + PLAYER_SIZE > obstacle.x && 
            playerX < obstacle.x + OBSTACLE_WIDTH &&
            playerBottom > obstacle.y) {
          setGameOver(true);
          break;
        }
      }
    };

    checkCollision();
  }, [playerY, obstacles, gameStarted, gameOver]);

  return (
    <div style={{
      display: 'flex',
      flexDirection: 'column',
      alignItems: 'center',
      padding: '20px',
      fontFamily: 'Arial, sans-serif'
    }}>
      <h2 style={{ margin: '0 0 10px 0', color: '#2d5016' }}>Jungle Jump</h2>
      
      <div style={{
        position: 'relative',
        width: '400px',
        height: '300px',
        border: '2px solid #2d5016',
        backgroundColor: '#87ceeb',
        overflow: 'hidden',
        cursor: 'pointer'
      }} onClick={jump}>
        
        <div style={{
          position: 'absolute',
          bottom: '0',
          width: '100%',
          height: '50px',
          backgroundColor: '#228b22'
        }} />

        <div style={{
          position: 'absolute',
          left: '50px',
          top: `${playerY}px`,
          width: `${PLAYER_SIZE}px`,
          height: `${PLAYER_SIZE}px`,
          backgroundColor: '#8b4513',
          borderRadius: '50%',
          border: '2px solid #654321'
        }} />

        {obstacles.map((obstacle, index) => (
          <div key={index} style={{
            position: 'absolute',
            left: `${obstacle.x}px`,
            top: `${obstacle.y}px`,
            width: `${OBSTACLE_WIDTH}px`,
            height: `${OBSTACLE_HEIGHT}px`,
            backgroundColor: '#006400',
            border: '1px solid #004d00'
          }} />
        ))}

        {!gameStarted && (
          <div style={{
            position: 'absolute',
            top: '50%',
            left: '50%',
            transform: 'translate(-50%, -50%)',
            textAlign: 'center',
            color: '#2d5016',
            fontSize: '18px',
            fontWeight: 'bold'
          }}>
            Click or Press Space to Start!
          </div>
        )}

        {gameOver && (
          <div style={{
            position: 'absolute',
            top: '50%',
            left: '50%',
            transform: 'translate(-50%, -50%)',
            textAlign: 'center',
            backgroundColor: 'rgba(255, 255, 255, 0.9)',
            padding: '20px',
            borderRadius: '10px',
            border: '2px solid #2d5016'
          }}>
            <div style={{ color: '#d32f2f', fontSize: '20px', fontWeight: 'bold' }}>
              Game Over!
            </div>
            <div style={{ color: '#2d5016', margin: '10px 0' }}>
              Final Score: {Math.floor(score / 10)}
            </div>
            <button onClick={resetGame} style={{
              padding: '10px 20px',
              fontSize: '16px',
              backgroundColor: '#4caf50',
              color: 'white',
              border: 'none',
              borderRadius: '5px',
              cursor: 'pointer'
            }}>
              Play Again
            </button>
          </div>
        )}
      </div>

      <div style={{
        marginTop: '10px',
        display: 'flex',
        gap: '20px',
        alignItems: 'center'
      }}>
        <div style={{ color: '#2d5016', fontWeight: 'bold' }}>
          Score: {Math.floor(score / 10)}
        </div>
        <button onClick={resetGame} style={{
          padding: '8px 16px',
          backgroundColor: '#ff9800',
          color: 'white',
          border: 'none',
          borderRadius: '4px',
          cursor: 'pointer'
        }}>
          Reset
        </button>
      </div>
      
      <div style={{
        marginTop: '10px',
        color: '#666',
        fontSize: '14px',
        textAlign: 'center'
      }}>
        Click the game area or press Space to jump over obstacles!
      </div>
    </div>
  );
};

export default GameZone;
----------------------------------------


================================================================================
GAME GENERATION: Jungle Jump - 2025-08-09 13:51:57.314328
================================================================================
FULL CLAUDE GENERATED CODE:
----------------------------------------
import React, { useState, useEffect, useRef } from 'react';

const GameZone = ({ currentGame }) => {
  const [playerY, setPlayerY] = useState(250);
  const [playerVelocity, setPlayerVelocity] = useState(0);
  const [obstacles, setObstacles] = useState([]);
  const [score, setScore] = useState(0);
  const [gameOver, setGameOver] = useState(false);
  const [gameStarted, setGameStarted] = useState(false);
  const gameLoopRef = useRef();

  const GRAVITY = 0.8;
  const JUMP_FORCE = -15;
  const PLAYER_SIZE = 30;
  const OBSTACLE_WIDTH = 20;
  const OBSTACLE_HEIGHT = 60;
  const GAME_WIDTH = 400;
  const GAME_HEIGHT = 300;
  const GROUND_Y = 280;

  useEffect(() => {
    if (gameStarted && !gameOver) {
      gameLoopRef.current = setInterval(() => {
        setPlayerY(prevY => {
          const newY = prevY + playerVelocity;
          return Math.min(newY, GROUND_Y - PLAYER_SIZE);
        });

        setPlayerVelocity(prevVel => {
          if (playerY >= GROUND_Y - PLAYER_SIZE) {
            return 0;
          }
          return prevVel + GRAVITY;
        });

        setObstacles(prevObstacles => {
          const newObstacles = prevObstacles
            .map(obs => ({ ...obs, x: obs.x - 3 }))
            .filter(obs => obs.x > -OBSTACLE_WIDTH);

          if (Math.random() < 0.015 && (newObstacles.length === 0 || newObstacles[newObstacles.length - 1].x < GAME_WIDTH - 150)) {
            newObstacles.push({
              x: GAME_WIDTH,
              y: GROUND_Y - OBSTACLE_HEIGHT,
              width: OBSTACLE_WIDTH,
              height: OBSTACLE_HEIGHT
            });
          }

          return newObstacles;
        });

        setScore(prevScore => prevScore + 1);
      }, 1000 / 60);
    }

    return () => clearInterval(gameLoopRef.current);
  }, [gameStarted, gameOver, playerY, playerVelocity]);

  useEffect(() => {
    const checkCollision = () => {
      const playerX = 50;
      const playerBottom = playerY + PLAYER_SIZE;
      const playerRight = playerX + PLAYER_SIZE;

      for (let obstacle of obstacles) {
        if (
          playerRight > obstacle.x &&
          playerX < obstacle.x + obstacle.width &&
          playerBottom > obstacle.y &&
          playerY < obstacle.y + obstacle.height
        ) {
          setGameOver(true);
          setGameStarted(false);
          break;
        }
      }
    };

    if (gameStarted && !gameOver) {
      checkCollision();
    }
  }, [playerY, obstacles, gameStarted, gameOver]);

  const handleJump = () => {
    if (!gameStarted) {
      startGame();
      return;
    }
    
    if (gameOver) return;
    
    if (playerY >= GROUND_Y - PLAYER_SIZE) {
      setPlayerVelocity(JUMP_FORCE);
    }
  };

  const startGame = () => {
    setGameStarted(true);
    setGameOver(false);
    setScore(0);
    setPlayerY(250);
    setPlayerVelocity(0);
    setObstacles([]);
  };

  const resetGame = () => {
    setGameStarted(false);
    setGameOver(false);
    setScore(0);
    setPlayerY(250);
    setPlayerVelocity(0);
    setObstacles([]);
  };

  useEffect(() => {
    const handleKeyPress = (e) => {
      if (e.code === 'Space') {
        e.preventDefault();
        handleJump();
      }
    };

    window.addEventListener('keydown', handleKeyPress);
    return () => window.removeEventListener('keydown', handleKeyPress);
  }, [gameStarted, gameOver, playerY]);

  return (
    <div style={{
      display: 'flex',
      flexDirection: 'column',
      alignItems: 'center',
      padding: '20px',
      fontFamily: 'Arial, sans-serif'
    }}>
      <h2 style={{ margin: '0 0 10px 0', color: '#2d5016' }}>Jungle Jump</h2>
      
      <div style={{
        position: 'relative',
        width: GAME_WIDTH,
        height: GAME_HEIGHT,
        backgroundColor: '#87CEEB',
        border: '2px solid #2d5016',
        overflow: 'hidden',
        cursor: 'pointer'
      }} onClick={handleJump}>
        
        <div style={{
          position: 'absolute',
          bottom: 0,
          left: 0,
          width: '100%',
          height: '20px',
          backgroundColor: '#8B4513'
        }} />

        <div style={{
          position: 'absolute',
          left: '50px',
          top: `${playerY}px`,
          width: `${PLAYER_SIZE}px`,
          height: `${PLAYER_SIZE}px`,
          backgroundColor: '#FF6B35',
          borderRadius: '50%',
          border: '2px solid #FF4500'
        }} />

        {obstacles.map((obstacle, index) => (
          <div key={index} style={{
            position: 'absolute',
            left: `${obstacle.x}px`,
            top: `${obstacle.y}px`,
            width: `${obstacle.width}px`,
            height: `${obstacle.height}px`,
            backgroundColor: '#2d5016',
            border: '1px solid #1a2e0a'
          }} />
        ))}

        {!gameStarted && !gameOver && (
          <div style={{
            position: 'absolute',
            top: '50%',
            left: '50%',
            transform: 'translate(-50%, -50%)',
            backgroundColor: 'rgba(255, 255, 255, 0.9)',
            padding: '20px',
            borderRadius: '10px',
            textAlign: 'center'
          }}>
            <div style={{ fontSize: '18px', marginBottom: '10px' }}>Jungle Jump</div>
            <div style={{ fontSize: '14px', marginBottom: '15px' }}>Click or press SPACE to jump over obstacles!</div>
            <button onClick={startGame} style={{
              padding: '10px 20px',
              fontSize: '16px',
              backgroundColor: '#2d5016',
              color: 'white',
              border: 'none',
              borderRadius: '5px',
              cursor: 'pointer'
            }}>
              Start Game
            </button>
          </div>
        )}

        {gameOver && (
          <div style={{
            position: 'absolute',
            top: '50%',
            left: '50%',
            transform: 'translate(-50%, -50%)',
            backgroundColor: 'rgba(255, 255, 255, 0.9)',
            padding: '20px',
            borderRadius: '10px',
            textAlign: 'center'
          }}>
            <div style={{ fontSize: '18px', marginBottom: '10px', color: '#d32f2f' }}>Game Over!</div>
            <div style={{ fontSize: '16px', marginBottom: '15px' }}>Score: {Math.floor(score / 10)}</div>
            <button onClick={resetGame} style={{
              padding: '10
----------------------------------------


================================================================================
GAME GENERATION: Space Runner - 2025-08-09 13:52:18.612061
================================================================================
FULL CLAUDE GENERATED CODE:
----------------------------------------
import React, { useState, useEffect, useRef, useCallback } from 'react';

const GameZone = ({ currentGame }) => {
  const canvasRef = useRef(null);
  const gameLoopRef = useRef(null);
  const keysRef = useRef({});
  
  const [gameState, setGameState] = useState({
    player: { x: 50, y: 150, width: 20, height: 20 },
    obstacles: [],
    score: 0,
    gameOver: false,
    speed: 2
  });

  const resetGame = useCallback(() => {
    setGameState({
      player: { x: 50, y: 150, width: 20, height: 20 },
      obstacles: [],
      score: 0,
      gameOver: false,
      speed: 2
    });
  }, []);

  const checkCollision = (rect1, rect2) => {
    return rect1.x < rect2.x + rect2.width &&
           rect1.x + rect1.width > rect2.x &&
           rect1.y < rect2.y + rect2.height &&
           rect1.y + rect1.height > rect2.y;
  };

  const gameLoop = useCallback(() => {
    setGameState(prevState => {
      if (prevState.gameOver) return prevState;

      const newState = { ...prevState };
      
      // Move player
      if (keysRef.current['ArrowUp'] && newState.player.y > 0) {
        newState.player.y -= 3;
      }
      if (keysRef.current['ArrowDown'] && newState.player.y < 280) {
        newState.player.y += 3;
      }

      // Move obstacles
      newState.obstacles = newState.obstacles.map(obs => ({
        ...obs,
        x: obs.x - newState.speed
      })).filter(obs => obs.x > -50);

      // Add new obstacles
      if (Math.random() < 0.02) {
        newState.obstacles.push({
          x: 400,
          y: Math.random() * 250,
          width: 30,
          height: 30
        });
      }

      // Check collisions
      for (let obs of newState.obstacles) {
        if (checkCollision(newState.player, obs)) {
          newState.gameOver = true;
          break;
        }
      }

      // Update score and speed
      newState.score += 1;
      if (newState.score % 500 === 0) {
        newState.speed += 0.5;
      }

      return newState;
    });
  }, []);

  useEffect(() => {
    const handleKeyDown = (e) => {
      keysRef.current[e.key] = true;
    };

    const handleKeyUp = (e) => {
      keysRef.current[e.key] = false;
    };

    window.addEventListener('keydown', handleKeyDown);
    window.addEventListener('keyup', handleKeyUp);

    return () => {
      window.removeEventListener('keydown', handleKeyDown);
      window.removeEventListener('keyup', handleKeyUp);
    };
  }, []);

  useEffect(() => {
    if (!gameState.gameOver) {
      gameLoopRef.current = setInterval(gameLoop, 16);
    } else {
      clearInterval(gameLoopRef.current);
    }

    return () => clearInterval(gameLoopRef.current);
  }, [gameLoop, gameState.gameOver]);

  useEffect(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;

    const ctx = canvas.getContext('2d');
    ctx.clearRect(0, 0, 400, 300);

    // Draw background
    ctx.fillStyle = '#000';
    ctx.fillRect(0, 0, 400, 300);

    // Draw stars
    ctx.fillStyle = '#fff';
    for (let i = 0; i < 50; i++) {
      const x = (i * 37) % 400;
      const y = (i * 23) % 300;
      ctx.fillRect(x, y, 1, 1);
    }

    // Draw player
    ctx.fillStyle = '#0f0';
    ctx.fillRect(gameState.player.x, gameState.player.y, gameState.player.width, gameState.player.height);

    // Draw obstacles
    ctx.fillStyle = '#f00';
    gameState.obstacles.forEach(obs => {
      ctx.fillRect(obs.x, obs.y, obs.width, obs.height);
    });

  }, [gameState]);

  return (
    <div style={{ 
      display: 'flex', 
      flexDirection: 'column', 
      alignItems: 'center', 
      padding: '20px',
      fontFamily: 'Arial, sans-serif'
    }}>
      <h2 style={{ margin: '0 0 10px 0', color: '#333' }}>Space Runner</h2>
      
      <div style={{ marginBottom: '10px', fontSize: '18px', fontWeight: 'bold' }}>
        Score: {gameState.score}
      </div>

      <canvas
        ref={canvasRef}
        width={400}
        height={300}
        style={{
          border: '2px solid #333',
          backgroundColor: '#000'
        }}
      />

      <div style={{ marginTop: '10px', textAlign: 'center' }}>
        <div style={{ marginBottom: '10px', fontSize: '14px' }}>
          Use ‚Üë‚Üì arrow keys to move
        </div>
        
        {gameState.gameOver && (
          <div style={{ 
            backgroundColor: '#f44', 
            color: 'white', 
            padding: '10px', 
            borderRadius: '5px',
            marginBottom: '10px'
          }}>
            Game Over! Final Score: {gameState.score}
          </div>
        )}

        <button
          onClick={resetGame}
          style={{
            padding: '10px 20px',
            fontSize: '16px',
            backgroundColor: '#4CAF50',
            color: 'white',
            border: 'none',
            borderRadius: '5px',
            cursor: 'pointer'
          }}
        >
          {gameState.gameOver ? 'Play Again' : 'Restart'}
        </button>
      </div>
    </div>
  );
};

export default GameZone;
----------------------------------------


================================================================================
GAME GENERATION: Space Runner - 2025-08-09 13:52:22.199218
================================================================================
FULL CLAUDE GENERATED CODE:
----------------------------------------
import React, { useState, useEffect, useRef, useCallback } from 'react';

const GameZone = ({ currentGame }) => {
  const canvasRef = useRef(null);
  const animationRef = useRef(null);
  const gameStateRef = useRef({
    player: { x: 50, y: 150, width: 20, height: 15 },
    obstacles: [],
    stars: [],
    score: 0,
    speed: 2,
    gameOver: false,
    keys: {}
  });

  const [score, setScore] = useState(0);
  const [gameOver, setGameOver] = useState(false);

  const initGame = useCallback(() => {
    const state = gameStateRef.current;
    state.player = { x: 50, y: 150, width: 20, height: 15 };
    state.obstacles = [];
    state.stars = [];
    state.score = 0;
    state.speed = 2;
    state.gameOver = false;
    setScore(0);
    setGameOver(false);
  }, []);

  const generateObstacle = useCallback(() => {
    const state = gameStateRef.current;
    if (Math.random() < 0.02) {
      state.obstacles.push({
        x: 400,
        y: Math.random() * 250 + 25,
        width: 15,
        height: 15
      });
    }
  }, []);

  const generateStar = useCallback(() => {
    const state = gameStateRef.current;
    if (Math.random() < 0.01) {
      state.stars.push({
        x: 400,
        y: Math.random() * 280 + 10,
        width: 8,
        height: 8
      });
    }
  }, []);

  const updateGame = useCallback(() => {
    const state = gameStateRef.current;
    const canvas = canvasRef.current;
    if (!canvas || state.gameOver) return;

    if (state.keys['ArrowUp'] && state.player.y > 0) {
      state.player.y -= 3;
    }
    if (state.keys['ArrowDown'] && state.player.y < 285) {
      state.player.y += 3;
    }

    generateObstacle();
    generateStar();

    state.obstacles = state.obstacles.filter(obstacle => {
      obstacle.x -= state.speed;
      if (obstacle.x < state.player.x + state.player.width &&
          obstacle.x + obstacle.width > state.player.x &&
          obstacle.y < state.player.y + state.player.height &&
          obstacle.y + obstacle.height > state.player.y) {
        state.gameOver = true;
        setGameOver(true);
        return false;
      }
      return obstacle.x > -obstacle.width;
    });

    state.stars = state.stars.filter(star => {
      star.x -= state.speed;
      if (star.x < state.player.x + state.player.width &&
          star.x + star.width > state.player.x &&
          star.y < state.player.y + state.player.height &&
          star.y + star.height > state.player.y) {
        state.score += 10;
        setScore(state.score);
        return false;
      }
      return star.x > -star.width;
    });

    state.score += 1;
    if (state.score % 500 === 0) {
      state.speed += 0.5;
    }
    setScore(state.score);
  }, [generateObstacle, generateStar]);

  const draw = useCallback(() => {
    const canvas = canvasRef.current;
    const ctx = canvas?.getContext('2d');
    if (!ctx) return;

    const state = gameStateRef.current;

    ctx.fillStyle = '#000011';
    ctx.fillRect(0, 0, 400, 300);

    ctx.fillStyle = '#00ff00';
    ctx.fillRect(state.player.x, state.player.y, state.player.width, state.player.height);

    ctx.fillStyle = '#ff0000';
    state.obstacles.forEach(obstacle => {
      ctx.fillRect(obstacle.x, obstacle.y, obstacle.width, obstacle.height);
    });

    ctx.fillStyle = '#ffff00';
    state.stars.forEach(star => {
      ctx.fillRect(star.x, star.y, star.width, star.height);
    });
  }, []);

  const gameLoop = useCallback(() => {
    updateGame();
    draw();
    if (!gameStateRef.current.gameOver) {
      animationRef.current = requestAnimationFrame(gameLoop);
    }
  }, [updateGame, draw]);

  const handleKeyDown = useCallback((e) => {
    gameStateRef.current.keys[e.key] = true;
  }, []);

  const handleKeyUp = useCallback((e) => {
    gameStateRef.current.keys[e.key] = false;
  }, []);

  useEffect(() => {
    initGame();
    
    window.addEventListener('keydown', handleKeyDown);
    window.addEventListener('keyup', handleKeyUp);

    animationRef.current = requestAnimationFrame(gameLoop);

    return () => {
      window.removeEventListener('keydown', handleKeyDown);
      window.removeEventListener('keyup', handleKeyUp);
      if (animationRef.current) {
        cancelAnimationFrame(animationRef.current);
      }
    };
  }, [initGame, handleKeyDown, handleKeyUp, gameLoop]);

  const restart = () => {
    if (animationRef.current) {
      cancelAnimationFrame(animationRef.current);
    }
    initGame();
    animationRef.current = requestAnimationFrame(gameLoop);
  };

  return (
    <div style={{ display: 'flex', flexDirection: 'column', alignItems: 'center', padding: '20px' }}>
      <h2 style={{ color: '#333', margin: '10px 0' }}>Space Runner</h2>
      <div style={{ marginBottom: '10px' }}>
        <span style={{ fontSize: '18px', fontWeight: 'bold', marginRight: '20px' }}>Score: {score}</span>
        <button 
          onClick={restart}
          style={{
            padding: '8px 16px',
            fontSize: '14px',
            backgroundColor: '#007bff',
            color: 'white',
            border: 'none',
            borderRadius: '4px',
            cursor: 'pointer'
          }}
        >
          Restart
        </button>
      </div>
      <canvas
        ref={canvasRef}
        width={400}
        height={300}
        style={{
          border: '2px solid #333',
          backgroundColor: '#000011'
        }}
      />
      <div style={{ marginTop: '10px', textAlign: 'center', fontSize: '14px', color: '#666' }}>
        Use arrow keys to move up/down. Avoid red obstacles, collect yellow stars!
      </div>
      {gameOver && (
        <div style={{
          position: 'absolute',
          top: '50%',
          left: '50%',
          transform: 'translate(-50%, -50%)',
          backgroundColor: 'rgba(0,0,0,0.8)',
          color: 'white',
          padding: '20px',
          borderRadius: '10px',
          textAlign: 'center'
        }}>
          <h3>Game Over!</h3>
          <p>Final Score: {score}</p>
          <button 
            onClick={restart}
            style={{
              padding: '10px 20px',
              fontSize: '16px',
              backgroundColor: '#28a745',
              color: 'white',
              border: '
----------------------------------------


================================================================================
GAME GENERATION: Jungle Jump - 2025-08-09 13:52:44.523337
================================================================================
FULL CLAUDE GENERATED CODE:
----------------------------------------
import React, { useState, useEffect, useRef } from 'react';

const GameZone = ({ currentGame }) => {
  const canvasRef = useRef(null);
  const [gameState, setGameState] = useState('playing');
  const [score, setScore] = useState(0);
  const [gameStarted, setGameStarted] = useState(false);
  
  const gameRef = useRef({
    player: { x: 50, y: 200, width: 30, height: 30, velocityY: 0, onGround: false },
    platforms: [
      { x: 0, y: 250, width: 100, height: 20 },
      { x: 150, y: 200, width: 80, height: 20 },
      { x: 280, y: 150, width: 80, height: 20 },
      { x: 400, y: 100, width: 80, height: 20 },
      { x: 550, y: 180, width: 80, height: 20 },
      { x: 700, y: 220, width: 80, height: 20 }
    ],
    camera: { x: 0 },
    keys: {},
    gravity: 0.5,
    jumpPower: -12,
    speed: 3
  });

  const resetGame = () => {
    const game = gameRef.current;
    game.player = { x: 50, y: 200, width: 30, height: 30, velocityY: 0, onGround: false };
    game.camera = { x: 0 };
    setScore(0);
    setGameState('playing');
    setGameStarted(true);
  };

  useEffect(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;
    
    const ctx = canvas.getContext('2d');
    const game = gameRef.current;

    const handleKeyDown = (e) => {
      game.keys[e.code] = true;
      if (e.code === 'Space' || e.code === 'ArrowUp') {
        e.preventDefault();
      }
    };

    const handleKeyUp = (e) => {
      game.keys[e.code] = false;
    };

    window.addEventListener('keydown', handleKeyDown);
    window.addEventListener('keyup', handleKeyUp);

    const gameLoop = () => {
      if (!gameStarted || gameState !== 'playing') return;

      // Update player
      const player = game.player;
      
      // Horizontal movement
      if (game.keys['ArrowLeft'] || game.keys['KeyA']) {
        player.x -= game.speed;
      }
      if (game.keys['ArrowRight'] || game.keys['KeyD']) {
        player.x += game.speed;
      }

      // Jumping
      if ((game.keys['Space'] || game.keys['ArrowUp']) && player.onGround) {
        player.velocityY = game.jumpPower;
        player.onGround = false;
      }

      // Apply gravity
      player.velocityY += game.gravity;
      player.y += player.velocityY;

      // Platform collision
      player.onGround = false;
      game.platforms.forEach(platform => {
        if (player.x < platform.x + platform.width &&
            player.x + player.width > platform.x &&
            player.y < platform.y + platform.height &&
            player.y + player.height > platform.y) {
          
          if (player.velocityY > 0 && player.y < platform.y) {
            player.y = platform.y - player.height;
            player.velocityY = 0;
            player.onGround = true;
          }
        }
      });

      // Camera follow
      game.camera.x = player.x - 200;
      if (game.camera.x < 0) game.camera.x = 0;

      // Update score based on distance
      const newScore = Math.floor(Math.max(0, player.x - 50) / 10);
      setScore(newScore);

      // Game over conditions
      if (player.y > 300) {
        setGameState('gameOver');
      }

      // Clear canvas
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // Draw background
      ctx.fillStyle = '#87CEEB';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // Draw jungle background elements
      ctx.fillStyle = '#228B22';
      for (let i = 0; i < 10; i++) {
        const treeX = i * 80 - game.camera.x;
        if (treeX > -50 && treeX < canvas.width + 50) {
          ctx.fillRect(treeX, 0, 30, canvas.height);
        }
      }

      // Draw platforms
      ctx.fillStyle = '#8B4513';
      game.platforms.forEach(platform => {
        const platformX = platform.x - game.camera.x;
        if (platformX > -platform.width && platformX < canvas.width) {
          ctx.fillRect(platformX, platform.y, platform.width, platform.height);
          
          // Add leaves on platforms
          ctx.fillStyle = '#32CD32';
          ctx.fillRect(platformX, platform.y - 5, platform.width, 5);
          ctx.fillStyle = '#8B4513';
        }
      });

      // Draw player
      ctx.fillStyle = player.onGround ? '#FF6B35' : '#FF4500';
      ctx.fillRect(player.x - game.camera.x, player.y, player.width, player.height);
      
      // Player face
      ctx.fillStyle = '#000';
      ctx.fillRect(player.x - game.camera.x + 5, player.y + 5, 3, 3);
      ctx.fillRect(player.x - game.camera.x + 15, player.y + 5, 3, 3);
    };

    const interval = setInterval(gameLoop, 16);

    return () => {
      clearInterval(interval);
      window.removeEventListener('keydown', handleKeyDown);
      window.removeEventListener('keyup', handleKeyUp);
    };
  }, [gameStarted, gameState]);

  return (
    <div style={{ 
      display: 'flex', 
      flexDirection: 'column', 
      alignItems: 'center', 
      padding: '20px',
      fontFamily: 'Arial, sans-serif'
    }}>
      <h2 style={{ margin: '0 0 10px 0', color: '#2E8B57' }}>Jungle Jump</h2>
      
      <div style={{ marginBottom: '10px', fontSize: '18px', fontWeight: 'bold' }}>
        Score: {score}
      </div>

      <canvas
        ref={canvasRef}
        width={400}
        height={300}
        style={{
          border: '2px solid #2E8B57',
          backgroundColor: '#87CEEB',
          marginBottom: '10px'
        }}
      />

      <div style={{ textAlign: 'center', marginBottom: '10px' }}>
        {!gameStarted && (
          <div>
            <p>Jump through the jungle platforms!</p>
            <p>Use ARROW KEYS or WASD to move, SPACE or UP to jump</p>
          </div>
        )}
        
        {gameState === 'gameOver' && (
          <div style={{ color: '#D2691E', fontSize: '18px', fontWeight: 'bold' }}>
            Game Over! Final Score: {score}
          </div>
        )}
      </div>

      <button
        onClick={resetGame}
        style={{
          padding: '10px 20px',
          
----------------------------------------


================================================================================
GAME GENERATION: Jungle Jump - 2025-08-09 13:52:45.357675
================================================================================
FULL CLAUDE GENERATED CODE:
----------------------------------------
import React, { useState, useEffect, useCallback } from 'react';

const GameZone = ({ currentGame }) => {
  const [player, setPlayer] = useState({ x: 50, y: 200, width: 30, height: 30, velocityY: 0, onGround: false });
  const [platforms, setPlatforms] = useState([
    { x: 0, y: 250, width: 100, height: 20 },
    { x: 150, y: 200, width: 80, height: 20 },
    { x: 280, y: 150, width: 80, height: 20 },
    { x: 200, y: 100, width: 100, height: 20 },
    { x: 350, y: 50, width: 50, height: 20 }
  ]);
  const [score, setScore] = useState(0);
  const [gameRunning, setGameRunning] = useState(true);
  const [keys, setKeys] = useState({});

  const GRAVITY = 0.5;
  const JUMP_FORCE = -12;
  const MOVE_SPEED = 3;
  const GAME_WIDTH = 400;
  const GAME_HEIGHT = 300;

  const handleKeyDown = useCallback((e) => {
    setKeys(prev => ({ ...prev, [e.key]: true }));
  }, []);

  const handleKeyUp = useCallback((e) => {
    setKeys(prev => ({ ...prev, [e.key]: false }));
  }, []);

  useEffect(() => {
    window.addEventListener('keydown', handleKeyDown);
    window.addEventListener('keyup', handleKeyUp);
    return () => {
      window.removeEventListener('keydown', handleKeyDown);
      window.removeEventListener('keyup', handleKeyUp);
    };
  }, [handleKeyDown, handleKeyUp]);

  const checkCollision = (rect1, rect2) => {
    return rect1.x < rect2.x + rect2.width &&
           rect1.x + rect1.width > rect2.x &&
           rect1.y < rect2.y + rect2.height &&
           rect1.y + rect1.height > rect2.y;
  };

  const resetGame = () => {
    setPlayer({ x: 50, y: 200, width: 30, height: 30, velocityY: 0, onGround: false });
    setScore(0);
    setGameRunning(true);
  };

  useEffect(() => {
    if (!gameRunning) return;

    const gameLoop = setInterval(() => {
      setPlayer(prevPlayer => {
        let newPlayer = { ...prevPlayer };

        // Handle input
        if (keys['ArrowLeft'] || keys['a']) {
          newPlayer.x = Math.max(0, newPlayer.x - MOVE_SPEED);
        }
        if (keys['ArrowRight'] || keys['d']) {
          newPlayer.x = Math.min(GAME_WIDTH - newPlayer.width, newPlayer.x + MOVE_SPEED);
        }
        if ((keys['ArrowUp'] || keys[' '] || keys['w']) && newPlayer.onGround) {
          newPlayer.velocityY = JUMP_FORCE;
          newPlayer.onGround = false;
        }

        // Apply gravity
        newPlayer.velocityY += GRAVITY;
        newPlayer.y += newPlayer.velocityY;

        // Check platform collisions
        newPlayer.onGround = false;
        platforms.forEach(platform => {
          if (checkCollision(newPlayer, platform)) {
            if (newPlayer.velocityY > 0 && newPlayer.y < platform.y) {
              newPlayer.y = platform.y - newPlayer.height;
              newPlayer.velocityY = 0;
              newPlayer.onGround = true;
              
              // Score for landing on higher platforms
              const platformHeight = GAME_HEIGHT - platform.y;
              if (platformHeight > 50) {
                setScore(prev => prev + Math.floor(platformHeight / 10));
              }
            }
          }
        });

        // Check if player fell off screen
        if (newPlayer.y > GAME_HEIGHT) {
          setGameRunning(false);
        }

        return newPlayer;
      });
    }, 1000 / 60);

    return () => clearInterval(gameLoop);
  }, [gameRunning, keys, platforms]);

  return (
    <div style={{ 
      display: 'flex', 
      flexDirection: 'column', 
      alignItems: 'center', 
      padding: '20px',
      fontFamily: 'Arial, sans-serif'
    }}>
      <h2 style={{ margin: '0 0 10px 0', color: '#2c5530' }}>Jungle Jump</h2>
      
      <div style={{ marginBottom: '10px' }}>
        <span style={{ marginRight: '20px', fontWeight: 'bold' }}>Score: {score}</span>
        <button 
          onClick={resetGame}
          style={{
            padding: '5px 15px',
            backgroundColor: '#4CAF50',
            color: 'white',
            border: 'none',
            borderRadius: '5px',
            cursor: 'pointer'
          }}
        >
          Reset Game
        </button>
      </div>

      <div 
        style={{
          position: 'relative',
          width: GAME_WIDTH,
          height: GAME_HEIGHT,
          backgroundColor: '#87CEEB',
          border: '2px solid #2c5530',
          overflow: 'hidden'
        }}
      >
        {/* Platforms */}
        {platforms.map((platform, index) => (
          <div
            key={index}
            style={{
              position: 'absolute',
              left: platform.x,
              top: platform.y,
              width: platform.width,
              height: platform.height,
              backgroundColor: '#8B4513',
              border: '1px solid #654321'
            }}
          />
        ))}

        {/* Player */}
        <div
          style={{
            position: 'absolute',
            left: player.x,
            top: player.y,
            width: player.width,
            height: player.height,
            backgroundColor: '#FF6B35',
            border: '2px solid #D2691E',
            borderRadius: '5px'
          }}
        />

        {/* Game Over overlay */}
        {!gameRunning && (
          <div
            style={{
              position: 'absolute',
              top: 0,
              left: 0,
              right: 0,
              bottom: 0,
              backgroundColor: 'rgba(0,0,0,0.7)',
              display: 'flex',
              flexDirection: 'column',
              justifyContent: 'center',
              alignItems: 'center',
              color: 'white'
            }}
          >
            <h3 style={{ margin: '0 0 10px 0' }}>Game Over!</h3>
            <p style={{ margin: '0 0 15px 0' }}>Final Score: {score}</p>
            <button 
              onClick={resetGame}
              style={{
                padding: '10px 20px',
                backgroundColor: '#4CAF50',
                color: 'white',
                border: 'none',
                borderRadius: '5px',
                cursor: 'pointer',
                fontSize: '16px'
              }}
            >
              Play Again
            </button>
          </div>
        )}
      </div>

      <div style={{ marginTop: '10px', fontSize: '12px', textAlign: 'center' }}>
        <p>Use Arrow Keys or WASD to move and jump</p>
        <p>Jump on higher platforms to score more points!</p>
      </div>
    </div>
  );
};

export
----------------------------------------


================================================================================
GAME GENERATION: Space Runner - 2025-08-09 14:07:58.236654
================================================================================
FULL CLAUDE GENERATED CODE:
----------------------------------------
import React, { useState, useEffect, useCallback } from 'react';

const GameZone = ({ currentGame }) => {
  const [gameState, setGameState] = useState('playing');
  const [score, setScore] = useState(0);
  const [playerY, setPlayerY] = useState(150);
  const [obstacles, setObstacles] = useState([]);
  const [gameSpeed, setGameSpeed] = useState(2);

  const resetGame = useCallback(() => {
    setGameState('playing');
    setScore(0);
    setPlayerY(150);
    setObstacles([]);
    setGameSpeed(2);
  }, []);

  useEffect(() => {
    if (gameState !== 'playing') return;

    const gameLoop = setInterval(() => {
      setObstacles(prev => {
        const newObstacles = prev
          .map(obs => ({ ...obs, x: obs.x - gameSpeed }))
          .filter(obs => obs.x > -50);

        if (Math.random() < 0.02) {
          newObstacles.push({
            x: 450,
            y: Math.random() * 200 + 50,
            width: 30,
            height: 30
          });
        }

        return newObstacles;
      });

      setScore(prev => prev + 1);
      setGameSpeed(prev => prev + 0.001);
    }, 16);

    return () => clearInterval(gameLoop);
  }, [gameState, gameSpeed]);

  useEffect(() => {
    const handleKeyPress = (e) => {
      if (gameState !== 'playing') return;
      
      if (e.key === 'ArrowUp' && playerY > 10) {
        setPlayerY(prev => prev - 15);
      } else if (e.key === 'ArrowDown' && playerY < 260) {
        setPlayerY(prev => prev + 15);
      }
    };

    window.addEventListener('keydown', handleKeyPress);
    return () => window.removeEventListener('keydown', handleKeyPress);
  }, [gameState, playerY]);

  useEffect(() => {
    if (gameState !== 'playing') return;

    const playerRect = { x: 50, y: playerY, width: 30, height: 30 };
    
    for (let obstacle of obstacles) {
      if (
        playerRect.x < obstacle.x + obstacle.width &&
        playerRect.x + playerRect.width > obstacle.x &&
        playerRect.y < obstacle.y + obstacle.height &&
        playerRect.y + playerRect.height > obstacle.y
      ) {
        setGameState('gameOver');
        break;
      }
    }
  }, [obstacles, playerY, gameState]);

  return (
    <div style={{
      display: 'flex',
      flexDirection: 'column',
      alignItems: 'center',
      padding: '20px',
      fontFamily: 'Arial, sans-serif'
    }}>
      <h2 style={{ margin: '0 0 10px 0', color: '#333' }}>Space Runner</h2>
      
      <div style={{
        display: 'flex',
        justifyContent: 'space-between',
        width: '400px',
        marginBottom: '10px'
      }}>
        <div style={{ fontSize: '18px', fontWeight: 'bold' }}>Score: {score}</div>
        <button
          onClick={resetGame}
          style={{
            padding: '5px 15px',
            backgroundColor: '#4CAF50',
            color: 'white',
            border: 'none',
            borderRadius: '4px',
            cursor: 'pointer',
            fontSize: '14px'
          }}
        >
          Restart
        </button>
      </div>

      <div style={{
        position: 'relative',
        width: '400px',
        height: '300px',
        backgroundColor: '#000020',
        border: '2px solid #333',
        overflow: 'hidden'
      }}>
        <div style={{
          position: 'absolute',
          left: '50px',
          top: `${playerY}px`,
          width: '30px',
          height: '30px',
          backgroundColor: '#00FF00',
          borderRadius: '50%',
          transition: 'top 0.1s ease'
        }} />

        {obstacles.map((obstacle, index) => (
          <div
            key={index}
            style={{
              position: 'absolute',
              left: `${obstacle.x}px`,
              top: `${obstacle.y}px`,
              width: `${obstacle.width}px`,
              height: `${obstacle.height}px`,
              backgroundColor: '#FF4444',
              borderRadius: '4px'
            }}
          />
        ))}

        {gameState === 'gameOver' && (
          <div style={{
            position: 'absolute',
            top: '50%',
            left: '50%',
            transform: 'translate(-50%, -50%)',
            backgroundColor: 'rgba(0, 0, 0, 0.8)',
            color: 'white',
            padding: '20px',
            borderRadius: '8px',
            textAlign: 'center'
          }}>
            <h3 style={{ margin: '0 0 10px 0' }}>Game Over!</h3>
            <p style={{ margin: '0 0 15px 0' }}>Final Score: {score}</p>
            <button
              onClick={resetGame}
              style={{
                padding: '10px 20px',
                backgroundColor: '#4CAF50',
                color: 'white',
                border: 'none',
                borderRadius: '4px',
                cursor: 'pointer',
                fontSize: '16px'
              }}
            >
              Play Again
            </button>
          </div>
        )}
      </div>

      <div style={{
        marginTop: '10px',
        fontSize: '14px',
        color: '#666',
        textAlign: 'center'
      }}>
        Use ‚Üë and ‚Üì arrow keys to move
      </div>
    </div>
  );
};

export default GameZone;
----------------------------------------


================================================================================
GAME GENERATION: Gravity Bounce: Guide a bouncing ball through rotating maze platforms by reversing gravity. - 2025-08-09 14:08:17.993930
================================================================================
FULL CLAUDE GENERATED CODE:
----------------------------------------
import React, { useState, useEffect, useRef } from 'react';

const GameZone = ({ currentGame }) => {
  const canvasRef = useRef(null);
  const animationRef = useRef(null);
  const [gameState, setGameState] = useState('playing');
  const [score, setScore] = useState(0);

  const gameData = useRef({
    ball: { x: 50, y: 50, vx: 0, vy: 0, radius: 8 },
    gravity: 0.3,
    gravityDirection: 1,
    platforms: [
      { x: 100, y: 150, width: 80, height: 10, rotation: 0, rotSpeed: 0.02 },
      { x: 250, y: 100, width: 60, height: 10, rotation: 0, rotSpeed: -0.015 },
      { x: 150, y: 220, width: 70, height: 10, rotation: 0, rotSpeed: 0.025 },
      { x: 320, y: 180, width: 50, height: 10, rotation: 0, rotSpeed: -0.03 }
    ],
    goal: { x: 350, y: 250, width: 30, height: 30 },
    keys: {}
  });

  useEffect(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;

    const ctx = canvas.getContext('2d');
    const game = gameData.current;

    const handleKeyDown = (e) => {
      game.keys[e.key] = true;
      if (e.key === ' ') {
        e.preventDefault();
        game.gravityDirection *= -1;
      }
    };

    const handleKeyUp = (e) => {
      game.keys[e.key] = false;
    };

    window.addEventListener('keydown', handleKeyDown);
    window.addEventListener('keyup', handleKeyUp);

    const gameLoop = () => {
      if (gameState !== 'playing') return;

      // Update ball physics
      const ball = game.ball;
      
      // Apply gravity
      ball.vy += game.gravity * game.gravityDirection;
      
      // Apply horizontal movement
      if (game.keys['ArrowLeft']) ball.vx -= 0.2;
      if (game.keys['ArrowRight']) ball.vx += 0.2;
      
      // Friction
      ball.vx *= 0.98;
      
      // Update position
      ball.x += ball.vx;
      ball.y += ball.vy;

      // Boundary collision
      if (ball.x - ball.radius <= 0 || ball.x + ball.radius >= canvas.width) {
        ball.vx *= -0.7;
        ball.x = Math.max(ball.radius, Math.min(canvas.width - ball.radius, ball.x));
      }
      if (ball.y - ball.radius <= 0 || ball.y + ball.radius >= canvas.height) {
        ball.vy *= -0.7;
        ball.y = Math.max(ball.radius, Math.min(canvas.height - ball.radius, ball.y));
      }

      // Update platforms
      game.platforms.forEach(platform => {
        platform.rotation += platform.rotSpeed;
      });

      // Platform collision
      game.platforms.forEach(platform => {
        const dx = ball.x - platform.x;
        const dy = ball.y - platform.y;
        
        // Rotate point to platform's local space
        const cos = Math.cos(-platform.rotation);
        const sin = Math.sin(-platform.rotation);
        const localX = dx * cos - dy * sin;
        const localY = dx * sin + dy * cos;
        
        if (Math.abs(localX) < platform.width / 2 + ball.radius && 
            Math.abs(localY) < platform.height / 2 + ball.radius) {
          
          if (Math.abs(localY) > Math.abs(localX)) {
            ball.vy = localY > 0 ? Math.abs(ball.vy) : -Math.abs(ball.vy);
            ball.vy *= 0.8;
            ball.y = platform.y + (localY > 0 ? platform.height / 2 + ball.radius : -platform.height / 2 - ball.radius);
          } else {
            ball.vx *= -0.7;
            ball.x = platform.x + (localX > 0 ? platform.width / 2 + ball.radius : -platform.width / 2 - ball.radius);
          }
        }
      });

      // Goal collision
      const goal = game.goal;
      if (ball.x + ball.radius > goal.x && ball.x - ball.radius < goal.x + goal.width &&
          ball.y + ball.radius > goal.y && ball.y - ball.radius < goal.y + goal.height) {
        setScore(prev => prev + 1);
        resetBall();
      }

      // Render
      ctx.fillStyle = '#1a1a2e';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // Draw platforms
      game.platforms.forEach(platform => {
        ctx.save();
        ctx.translate(platform.x, platform.y);
        ctx.rotate(platform.rotation);
        ctx.fillStyle = '#16213e';
        ctx.fillRect(-platform.width / 2, -platform.height / 2, platform.width, platform.height);
        ctx.strokeStyle = '#0f3460';
        ctx.lineWidth = 2;
        ctx.strokeRect(-platform.width / 2, -platform.height / 2, platform.width, platform.height);
        ctx.restore();
      });

      // Draw goal
      ctx.fillStyle = '#e94560';
      ctx.fillRect(goal.x, goal.y, goal.width, goal.height);

      // Draw ball
      ctx.fillStyle = '#f39c12';
      ctx.beginPath();
      ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
      ctx.fill();

      // Draw gravity indicator
      ctx.fillStyle = game.gravityDirection > 0 ? '#e74c3c' : '#3498db';
      ctx.font = '16px Arial';
      ctx.fillText(game.gravityDirection > 0 ? '‚Üì' : '‚Üë', 10, 25);

      animationRef.current = requestAnimationFrame(gameLoop);
    };

    gameLoop();

    return () => {
      window.removeEventListener('keydown', handleKeyDown);
      window.removeEventListener('keyup', handleKeyUp);
      if (animationRef.current) {
        cancelAnimationFrame(animationRef.current);
      }
    };
  }, [gameState]);

  const resetBall = () => {
    gameData.current.ball = { x: 50, y: 50, vx: 0, vy: 0, radius: 8 };
  };

  const resetGame = () => {
    setScore(0);
    setGameState('playing');
    resetBall();
    gameData.current.gravityDirection = 1;
  };

  return (
    <div style={{ textAlign: 'center', padding: '20px', backgroundColor: '#0f0f23', color: 'white', minHeight: '100vh' }}>
      <h2 style={{ margin: '0 0 10px 0', color: '#f39c12' }}>Gravity Bounce</h2>
      <div style={{ marginBottom: '10px' }}>
        <span style={{ marginRight: '20px' }}>Score: {score}</span>
        <button 
          onClick={resetGame}
          style={{
            padding: '8px 16px',
            backgroundColor: '#e94560',
----------------------------------------


================================================================================
GAME GENERATION: Bubble Bounce: Pop floating bubbles by drawing lines that reflect a bouncing ball before time runs out. - 2025-08-09 14:09:23.501850
================================================================================
FULL CLAUDE GENERATED CODE:
----------------------------------------
import React, { useState, useRef, useEffect, useCallback } from 'react';

const GameZone = ({ currentGame }) => {
  const canvasRef = useRef(null);
  const [gameState, setGameState] = useState('playing');
  const [score, setScore] = useState(0);
  const [timeLeft, setTimeLeft] = useState(30);
  const [ball, setBall] = useState({ x: 200, y: 250, vx: 3, vy: -3, radius: 8 });
  const [bubbles, setBubbles] = useState([]);
  const [lines, setLines] = useState([]);
  const [isDrawing, setIsDrawing] = useState(false);
  const [currentLine, setCurrentLine] = useState([]);

  const initializeGame = useCallback(() => {
    const newBubbles = [];
    for (let i = 0; i < 8; i++) {
      newBubbles.push({
        x: 50 + Math.random() * 300,
        y: 50 + Math.random() * 200,
        radius: 15 + Math.random() * 10,
        id: i
      });
    }
    setBubbles(newBubbles);
    setBall({ x: 200, y: 250, vx: 3, vy: -3, radius: 8 });
    setLines([]);
    setScore(0);
    setTimeLeft(30);
    setGameState('playing');
  }, []);

  useEffect(() => {
    initializeGame();
  }, [initializeGame]);

  useEffect(() => {
    if (gameState !== 'playing') return;

    const timer = setInterval(() => {
      setTimeLeft(prev => {
        if (prev <= 1) {
          setGameState('gameOver');
          return 0;
        }
        return prev - 1;
      });
    }, 1000);

    return () => clearInterval(timer);
  }, [gameState]);

  useEffect(() => {
    if (gameState !== 'playing') return;

    const gameLoop = setInterval(() => {
      setBall(prevBall => {
        let newBall = { ...prevBall };
        newBall.x += newBall.vx;
        newBall.y += newBall.vy;

        // Wall collisions
        if (newBall.x <= newBall.radius || newBall.x >= 400 - newBall.radius) {
          newBall.vx = -newBall.vx;
        }
        if (newBall.y <= newBall.radius || newBall.y >= 300 - newBall.radius) {
          newBall.vy = -newBall.vy;
        }

        // Line collisions
        lines.forEach(line => {
          if (line.length < 2) return;
          
          for (let i = 0; i < line.length - 1; i++) {
            const p1 = line[i];
            const p2 = line[i + 1];
            
            const dist = distanceToLineSegment(newBall.x, newBall.y, p1.x, p1.y, p2.x, p2.y);
            
            if (dist < newBall.radius) {
              // Simple reflection
              const dx = p2.x - p1.x;
              const dy = p2.y - p1.y;
              const len = Math.sqrt(dx * dx + dy * dy);
              const nx = -dy / len;
              const ny = dx / len;
              
              const dot = newBall.vx * nx + newBall.vy * ny;
              newBall.vx -= 2 * dot * nx;
              newBall.vy -= 2 * dot * ny;
            }
          }
        });

        // Bubble collisions
        setBubbles(prevBubbles => {
          return prevBubbles.filter(bubble => {
            const dx = newBall.x - bubble.x;
            const dy = newBall.y - bubble.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            if (distance < newBall.radius + bubble.radius) {
              setScore(prev => prev + 10);
              return false;
            }
            return true;
          });
        });

        return newBall;
      });
    }, 16);

    return () => clearInterval(gameLoop);
  }, [gameState, lines]);

  useEffect(() => {
    if (bubbles.length === 0 && gameState === 'playing') {
      setGameState('won');
    }
  }, [bubbles.length, gameState]);

  const distanceToLineSegment = (px, py, x1, y1, x2, y2) => {
    const dx = x2 - x1;
    const dy = y2 - y1;
    const length = Math.sqrt(dx * dx + dy * dy);
    
    if (length === 0) return Math.sqrt((px - x1) * (px - x1) + (py - y1) * (py - y1));
    
    const t = Math.max(0, Math.min(1, ((px - x1) * dx + (py - y1) * dy) / (length * length)));
    const projX = x1 + t * dx;
    const projY = y1 + t * dy;
    
    return Math.sqrt((px - projX) * (px - projX) + (py - projY) * (py - projY));
  };

  useEffect(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;

    const ctx = canvas.getContext('2d');
    ctx.clearRect(0, 0, 400, 300);

    // Draw bubbles
    bubbles.forEach(bubble => {
      ctx.beginPath();
      ctx.arc(bubble.x, bubble.y, bubble.radius, 0, Math.PI * 2);
      ctx.fillStyle = 'rgba(100, 200, 255, 0.7)';
      ctx.fill();
      ctx.strokeStyle = 'rgba(50, 150, 255, 1)';
      ctx.stroke();
    });

    // Draw ball
    ctx.beginPath();
    ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
    ctx.fillStyle = '#ff4444';
    ctx.fill();

    // Draw lines
    ctx.strokeStyle = '#333';
    ctx.lineWidth = 3;
    lines.forEach(line => {
      if (line.length < 2) return;
      ctx.beginPath();
      ctx.moveTo(line[0].x, line[0].y);
      for (let i = 1; i < line.length; i++) {
        ctx.lineTo(line[i].x, line[i].y);
      }
      ctx.stroke();
    });

    // Draw current line being drawn
    if (currentLine.length > 1) {
      ctx.strokeStyle = '#666';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(currentLine[0].x, currentLine[0].y);
      for (let i = 1; i < currentLine.length; i++) {
        ctx.lineTo(currentLine[i].x, currentLine[i].y);
      }
      ctx.stroke();
    }
  });

  const handleMouseDown = (e) => {
    if (gameState !== 'playing') return;
    
    const rect = canvasRef.current.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    
    setIsDrawing(true);
    setCurrentLine([{ x, y }]);
  };

  const handleMouseMove = (e) => {
    if (!
----------------------------------------


================================================================================
GAME GENERATION: Color Matcher: Match falling colored blocks with same-colored zones at the bottom by sliding left/right before they land. - 2025-08-09 14:10:05.472111
================================================================================
FULL CLAUDE GENERATED CODE:
----------------------------------------
import React, { useState, useEffect, useRef } from 'react';

const GameZone = ({ currentGame }) => {
  const canvasRef = useRef(null);
  const [gameState, setGameState] = useState('playing');
  const [score, setScore] = useState(0);
  const [blocks, setBlocks] = useState([]);
  const [playerX, setPlayerX] = useState(200);
  const [keys, setKeys] = useState({});

  const CANVAS_WIDTH = 400;
  const CANVAS_HEIGHT = 300;
  const ZONE_WIDTH = 80;
  const ZONE_HEIGHT = 30;
  const BLOCK_SIZE = 20;
  const COLORS = ['red', 'blue', 'green', 'yellow'];

  useEffect(() => {
    const canvas = canvasRef.current;
    const ctx = canvas.getContext('2d');

    const handleKeyDown = (e) => {
      setKeys(prev => ({ ...prev, [e.key]: true }));
    };

    const handleKeyUp = (e) => {
      setKeys(prev => ({ ...prev, [e.key]: false }));
    };

    window.addEventListener('keydown', handleKeyDown);
    window.addEventListener('keyup', handleKeyUp);

    return () => {
      window.removeEventListener('keydown', handleKeyDown);
      window.removeEventListener('keyup', handleKeyUp);
    };
  }, []);

  useEffect(() => {
    if (gameState !== 'playing') return;

    const gameLoop = setInterval(() => {
      setBlocks(prevBlocks => {
        const newBlocks = prevBlocks.map(block => ({
          ...block,
          y: block.y + 2
        }));

        const activeBlocks = newBlocks.filter(block => {
          if (block.y >= CANVAS_HEIGHT - ZONE_HEIGHT - BLOCK_SIZE) {
            const zoneIndex = Math.floor(block.x / (CANVAS_WIDTH / 4));
            const zoneColor = COLORS[zoneIndex];
            if (block.color === zoneColor) {
              setScore(prev => prev + 10);
              return false;
            } else {
              setGameState('gameOver');
              return false;
            }
          }
          return block.y < CANVAS_HEIGHT;
        });

        if (Math.random() < 0.02) {
          activeBlocks.push({
            x: Math.random() * (CANVAS_WIDTH - BLOCK_SIZE),
            y: 0,
            color: COLORS[Math.floor(Math.random() * COLORS.length)]
          });
        }

        return activeBlocks;
      });

      if (keys['ArrowLeft'] && playerX > 0) {
        setPlayerX(prev => Math.max(0, prev - 5));
      }
      if (keys['ArrowRight'] && playerX < CANVAS_WIDTH - BLOCK_SIZE) {
        setPlayerX(prev => Math.min(CANVAS_WIDTH - BLOCK_SIZE, prev + 5));
      }
    }, 50);

    return () => clearInterval(gameLoop);
  }, [gameState, keys, playerX]);

  useEffect(() => {
    const canvas = canvasRef.current;
    const ctx = canvas.getContext('2d');
    
    ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

    for (let i = 0; i < 4; i++) {
      ctx.fillStyle = COLORS[i];
      ctx.fillRect(i * (CANVAS_WIDTH / 4), CANVAS_HEIGHT - ZONE_HEIGHT, ZONE_WIDTH, ZONE_HEIGHT);
      
      ctx.fillStyle = 'white';
      ctx.font = '12px Arial';
      ctx.textAlign = 'center';
      ctx.fillText(COLORS[i].toUpperCase(), i * (CANVAS_WIDTH / 4) + ZONE_WIDTH / 2, CANVAS_HEIGHT - 10);
    }

    blocks.forEach(block => {
      ctx.fillStyle = block.color;
      ctx.fillRect(block.x, block.y, BLOCK_SIZE, BLOCK_SIZE);
    });

    ctx.fillStyle = 'black';
    ctx.font = '16px Arial';
    ctx.textAlign = 'left';
    ctx.fillText(`Score: ${score}`, 10, 20);

    if (gameState === 'gameOver') {
      ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
      ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
      ctx.fillStyle = 'white';
      ctx.font = '24px Arial';
      ctx.textAlign = 'center';
      ctx.fillText('Game Over!', CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2 - 20);
      ctx.fillText(`Final Score: ${score}`, CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2 + 10);
    }
  }, [blocks, score, gameState]);

  const resetGame = () => {
    setGameState('playing');
    setScore(0);
    setBlocks([]);
    setPlayerX(200);
    setKeys({});
  };

  return (
    <div style={{ 
      display: 'flex', 
      flexDirection: 'column', 
      alignItems: 'center', 
      padding: '20px',
      fontFamily: 'Arial, sans-serif'
    }}>
      <h2 style={{ margin: '0 0 10px 0', color: '#333' }}>Color Matcher</h2>
      <p style={{ margin: '0 0 10px 0', fontSize: '14px', color: '#666' }}>
        Use arrow keys to move. Match falling blocks with same-colored zones!
      </p>
      <canvas
        ref={canvasRef}
        width={CANVAS_WIDTH}
        height={CANVAS_HEIGHT}
        style={{
          border: '2px solid #333',
          backgroundColor: '#f0f0f0',
          marginBottom: '10px'
        }}
      />
      <button
        onClick={resetGame}
        style={{
          padding: '10px 20px',
          fontSize: '16px',
          backgroundColor: '#4CAF50',
          color: 'white',
          border: 'none',
          borderRadius: '5px',
          cursor: 'pointer'
        }}
        onMouseOver={(e) => e.target.style.backgroundColor = '#45a049'}
        onMouseOut={(e) => e.target.style.backgroundColor = '#4CAF50'}
      >
        {gameState === 'gameOver' ? 'Play Again' : 'Restart'}
      </button>
    </div>
  );
};

export default GameZone;
----------------------------------------


================================================================================
GAME GENERATION: Pixel Pogo: Bounce a square character between platforms while collecting stars and avoiding spikes. - 2025-08-09 14:11:12.290773
================================================================================
FULL CLAUDE GENERATED CODE:
----------------------------------------
import React, { useState, useEffect, useCallback } from 'react';

const GameZone = ({ currentGame }) => {
  const [player, setPlayer] = useState({ x: 200, y: 200, vx: 0, vy: 0, onGround: false });
  const [platforms] = useState([
    { x: 0, y: 280, width: 400, height: 20 },
    { x: 100, y: 220, width: 80, height: 15 },
    { x: 250, y: 180, width: 80, height: 15 },
    { x: 50, y: 120, width: 80, height: 15 },
    { x: 280, y: 80, width: 80, height: 15 }
  ]);
  const [stars, setStars] = useState([
    { x: 130, y: 190, collected: false },
    { x: 280, y: 150, collected: false },
    { x: 80, y: 90, collected: false },
    { x: 310, y: 50, collected: false }
  ]);
  const [spikes] = useState([
    { x: 200, y: 265, width: 20, height: 15 },
    { x: 160, y: 205, width: 20, height: 15 },
    { x: 20, y: 105, width: 20, height: 15 }
  ]);
  const [keys, setKeys] = useState({ left: false, right: false, space: false });
  const [score, setScore] = useState(0);
  const [gameOver, setGameOver] = useState(false);

  const GRAVITY = 0.5;
  const JUMP_FORCE = -12;
  const MOVE_SPEED = 3;
  const PLAYER_SIZE = 15;

  const checkCollision = useCallback((rect1, rect2) => {
    return rect1.x < rect2.x + rect2.width &&
           rect1.x + rect1.width > rect2.x &&
           rect1.y < rect2.y + rect2.height &&
           rect1.y + rect1.height > rect2.y;
  }, []);

  const resetGame = () => {
    setPlayer({ x: 200, y: 200, vx: 0, vy: 0, onGround: false });
    setStars([
      { x: 130, y: 190, collected: false },
      { x: 280, y: 150, collected: false },
      { x: 80, y: 90, collected: false },
      { x: 310, y: 50, collected: false }
    ]);
    setScore(0);
    setGameOver(false);
  };

  useEffect(() => {
    const handleKeyDown = (e) => {
      if (e.code === 'ArrowLeft') setKeys(prev => ({ ...prev, left: true }));
      if (e.code === 'ArrowRight') setKeys(prev => ({ ...prev, right: true }));
      if (e.code === 'Space') {
        e.preventDefault();
        setKeys(prev => ({ ...prev, space: true }));
      }
    };

    const handleKeyUp = (e) => {
      if (e.code === 'ArrowLeft') setKeys(prev => ({ ...prev, left: false }));
      if (e.code === 'ArrowRight') setKeys(prev => ({ ...prev, right: false }));
      if (e.code === 'Space') setKeys(prev => ({ ...prev, space: false }));
    };

    window.addEventListener('keydown', handleKeyDown);
    window.addEventListener('keyup', handleKeyUp);

    return () => {
      window.removeEventListener('keydown', handleKeyDown);
      window.removeEventListener('keyup', handleKeyUp);
    };
  }, []);

  useEffect(() => {
    if (gameOver) return;

    const gameLoop = setInterval(() => {
      setPlayer(prevPlayer => {
        let newPlayer = { ...prevPlayer };

        if (keys.left) newPlayer.vx = -MOVE_SPEED;
        else if (keys.right) newPlayer.vx = MOVE_SPEED;
        else newPlayer.vx = 0;

        if (keys.space && newPlayer.onGround) {
          newPlayer.vy = JUMP_FORCE;
          newPlayer.onGround = false;
        }

        newPlayer.vy += GRAVITY;
        newPlayer.x += newPlayer.vx;
        newPlayer.y += newPlayer.vy;

        if (newPlayer.x < 0) newPlayer.x = 0;
        if (newPlayer.x > 400 - PLAYER_SIZE) newPlayer.x = 400 - PLAYER_SIZE;

        newPlayer.onGround = false;

        platforms.forEach(platform => {
          const playerRect = { x: newPlayer.x, y: newPlayer.y, width: PLAYER_SIZE, height: PLAYER_SIZE };
          const platformRect = { x: platform.x, y: platform.y, width: platform.width, height: platform.height };

          if (checkCollision(playerRect, platformRect)) {
            if (newPlayer.vy > 0 && prevPlayer.y + PLAYER_SIZE <= platform.y) {
              newPlayer.y = platform.y - PLAYER_SIZE;
              newPlayer.vy = 0;
              newPlayer.onGround = true;
            }
          }
        });

        spikes.forEach(spike => {
          const playerRect = { x: newPlayer.x, y: newPlayer.y, width: PLAYER_SIZE, height: PLAYER_SIZE };
          const spikeRect = { x: spike.x, y: spike.y, width: spike.width, height: spike.height };

          if (checkCollision(playerRect, spikeRect)) {
            setGameOver(true);
          }
        });

        if (newPlayer.y > 300) {
          setGameOver(true);
        }

        return newPlayer;
      });

      setStars(prevStars => {
        return prevStars.map(star => {
          if (star.collected) return star;

          const playerRect = { x: player.x, y: player.y, width: PLAYER_SIZE, height: PLAYER_SIZE };
          const starRect = { x: star.x, y: star.y, width: 12, height: 12 };

          if (checkCollision(playerRect, starRect)) {
            setScore(prev => prev + 10);
            return { ...star, collected: true };
          }

          return star;
        });
      });
    }, 16);

    return () => clearInterval(gameLoop);
  }, [keys, player, platforms, spikes, checkCollision, gameOver]);

  return (
    <div style={{ 
      display: 'flex', 
      flexDirection: 'column', 
      alignItems: 'center', 
      padding: '20px',
      fontFamily: 'monospace'
    }}>
      <div style={{ marginBottom: '10px', fontSize: '18px', fontWeight: 'bold' }}>
        Pixel Pogo - Score: {score}
      </div>
      
      <div style={{
        position: 'relative',
        width: '400px',
        height: '300px',
        border: '2px solid #333',
        backgroundColor: '#87CEEB',
        overflow: 'hidden'
      }}>
        {platforms.map((platform, index) => (
          <div
            key={index}
            style={{
              position: 'absolute',
              left: `${platform.x}px`,
              top: `${platform.y}px`,
              width: `${platform.width}px`,
              height: `${platform.height}px`,
              backgroundColor: '#8B4513'
            }}
          />
        )
----------------------------------------


================================================================================
GAME GENERATION: safari - 2025-08-09 14:13:05.445488
================================================================================
FULL CLAUDE GENERATED CODE:
----------------------------------------
import React, { useState, useEffect, useCallback } from 'react';

const GameZone = ({ currentGame }) => {
  const [gameState, setGameState] = useState('playing');
  const [score, setScore] = useState(0);
  const [timeLeft, setTimeLeft] = useState(30);
  const [animals, setAnimals] = useState([]);
  const [nextAnimalId, setNextAnimalId] = useState(1);

  const animalTypes = [
    { type: 'lion', emoji: 'ü¶Å', points: 10, speed: 2 },
    { type: 'elephant', emoji: 'üêò', points: 15, speed: 1.5 },
    { type: 'zebra', emoji: 'ü¶ì', points: 8, speed: 3 },
    { type: 'giraffe', emoji: 'ü¶í', points: 12, speed: 2.5 }
  ];

  const spawnAnimal = useCallback(() => {
    const animalType = animalTypes[Math.floor(Math.random() * animalTypes.length)];
    const newAnimal = {
      id: nextAnimalId,
      ...animalType,
      x: Math.random() * 350,
      y: Math.random() * 250,
      direction: Math.random() * 2 * Math.PI
    };
    setAnimals(prev => [...prev, newAnimal]);
    setNextAnimalId(prev => prev + 1);
  }, [nextAnimalId]);

  const moveAnimals = useCallback(() => {
    setAnimals(prev => prev.map(animal => {
      let newX = animal.x + Math.cos(animal.direction) * animal.speed;
      let newY = animal.y + Math.sin(animal.direction) * animal.speed;
      let newDirection = animal.direction;

      if (newX < 0 || newX > 350) {
        newDirection = Math.PI - animal.direction;
        newX = Math.max(0, Math.min(350, newX));
      }
      if (newY < 0 || newY > 250) {
        newDirection = -animal.direction;
        newY = Math.max(0, Math.min(250, newY));
      }

      return {
        ...animal,
        x: newX,
        y: newY,
        direction: newDirection
      };
    }));
  }, []);

  const handleAnimalClick = (animalId) => {
    const animal = animals.find(a => a.id === animalId);
    if (animal) {
      setScore(prev => prev + animal.points);
      setAnimals(prev => prev.filter(a => a.id !== animalId));
    }
  };

  const resetGame = () => {
    setGameState('playing');
    setScore(0);
    setTimeLeft(30);
    setAnimals([]);
    setNextAnimalId(1);
  };

  useEffect(() => {
    if (gameState !== 'playing') return;

    const gameTimer = setInterval(() => {
      setTimeLeft(prev => {
        if (prev <= 1) {
          setGameState('gameOver');
          return 0;
        }
        return prev - 1;
      });
    }, 1000);

    return () => clearInterval(gameTimer);
  }, [gameState]);

  useEffect(() => {
    if (gameState !== 'playing') return;

    const spawnTimer = setInterval(spawnAnimal, 2000);
    return () => clearInterval(spawnTimer);
  }, [gameState, spawnAnimal]);

  useEffect(() => {
    if (gameState !== 'playing') return;

    const moveTimer = setInterval(moveAnimals, 100);
    return () => clearInterval(moveTimer);
  }, [gameState, moveAnimals]);

  useEffect(() => {
    spawnAnimal();
  }, []);

  return (
    <div style={{
      display: 'flex',
      flexDirection: 'column',
      alignItems: 'center',
      padding: '20px',
      fontFamily: 'Arial, sans-serif'
    }}>
      <h2 style={{ margin: '0 0 10px 0', color: '#8B4513' }}>Safari Hunt</h2>
      
      <div style={{
        display: 'flex',
        justifyContent: 'space-between',
        width: '400px',
        marginBottom: '10px',
        fontSize: '18px',
        fontWeight: 'bold'
      }}>
        <span style={{ color: '#228B22' }}>Score: {score}</span>
        <span style={{ color: '#DC143C' }}>Time: {timeLeft}s</span>
      </div>

      <div style={{
        width: '400px',
        height: '300px',
        border: '3px solid #8B4513',
        backgroundColor: '#F4A460',
        position: 'relative',
        overflow: 'hidden',
        borderRadius: '10px'
      }}>
        {animals.map(animal => (
          <div
            key={animal.id}
            onClick={() => handleAnimalClick(animal.id)}
            style={{
              position: 'absolute',
              left: `${animal.x}px`,
              top: `${animal.y}px`,
              fontSize: '24px',
              cursor: 'pointer',
              userSelect: 'none',
              transition: 'transform 0.1s',
              transform: 'scale(1)',
              zIndex: 1
            }}
            onMouseDown={(e) => {
              e.target.style.transform = 'scale(0.9)';
            }}
            onMouseUp={(e) => {
              e.target.style.transform = 'scale(1)';
            }}
          >
            {animal.emoji}
          </div>
        ))}

        {gameState === 'gameOver' && (
          <div style={{
            position: 'absolute',
            top: '50%',
            left: '50%',
            transform: 'translate(-50%, -50%)',
            backgroundColor: 'rgba(0, 0, 0, 0.8)',
            color: 'white',
            padding: '20px',
            borderRadius: '10px',
            textAlign: 'center',
            zIndex: 10
          }}>
            <h3 style={{ margin: '0 0 10px 0' }}>Game Over!</h3>
            <p style={{ margin: '0 0 15px 0' }}>Final Score: {score}</p>
            <button
              onClick={resetGame}
              style={{
                padding: '10px 20px',
                fontSize: '16px',
                backgroundColor: '#228B22',
                color: 'white',
                border: 'none',
                borderRadius: '5px',
                cursor: 'pointer'
              }}
            >
              Play Again
            </button>
          </div>
        )}
      </div>

      <div style={{
        marginTop: '15px',
        textAlign: 'center',
        color: '#8B4513'
      }}>
        <p style={{ margin: '5px 0', fontSize: '14px' }}>
          Click on the animals to score points!
        </p>
        <button
          onClick={resetGame}
          style={{
            padding: '8px 16px',
            fontSize: '14px',
            backgroundColor: '#DC143C',
            color: 'white',
            border: 'none',
            borderRadius: '5px',
            cursor: 'pointer',
            marginTop: '5px'
          }}
        >
          Restart Game
        </button>
      </div>
    </div>
  );
};

export default GameZone;
----------------------------------------


================================================================================
GAME GENERATION: Dot Dash: Guide a bouncing dot through a maze by drawing temporary line segments that disappear after a few seconds. - 2025-08-09 14:13:50.389479
================================================================================
FULL CLAUDE GENERATED CODE:
----------------------------------------
import React, { useState, useRef, useEffect, useCallback } from 'react';

const GameZone = ({ currentGame }) => {
  const canvasRef = useRef(null);
  const [gameState, setGameState] = useState('playing');
  const [score, setScore] = useState(0);
  const [lines, setLines] = useState([]);
  const [isDrawing, setIsDrawing] = useState(false);
  const [currentLine, setCurrentLine] = useState(null);
  
  const dotRef = useRef({ x: 50, y: 150, vx: 2, vy: 1 });
  const animationRef = useRef();

  const CANVAS_WIDTH = 400;
  const CANVAS_HEIGHT = 300;
  const DOT_RADIUS = 8;
  const LINE_DURATION = 3000;

  const maze = [
    { x: 100, y: 0, width: 20, height: 100 },
    { x: 200, y: 50, width: 20, height: 150 },
    { x: 300, y: 0, width: 20, height: 120 },
    { x: 0, y: 200, width: 150, height: 20 },
    { x: 250, y: 250, width: 150, height: 20 }
  ];

  const checkCollision = (x, y, radius) => {
    for (let wall of maze) {
      if (x + radius > wall.x && x - radius < wall.x + wall.width &&
          y + radius > wall.y && y - radius < wall.y + wall.height) {
        return true;
      }
    }
    return false;
  };

  const lineIntersectsCircle = (line, cx, cy, radius) => {
    const dx = line.endX - line.startX;
    const dy = line.endY - line.startY;
    const fx = line.startX - cx;
    const fy = line.startY - cy;

    const a = dx * dx + dy * dy;
    const b = 2 * (fx * dx + fy * dy);
    const c = (fx * fx + fy * fy) - radius * radius;

    const discriminant = b * b - 4 * a * c;
    if (discriminant < 0) return false;

    const discriminantSqrt = Math.sqrt(discriminant);
    const t1 = (-b - discriminantSqrt) / (2 * a);
    const t2 = (-b + discriminantSqrt) / (2 * a);

    return (t1 >= 0 && t1 <= 1) || (t2 >= 0 && t2 <= 1);
  };

  const gameLoop = useCallback(() => {
    if (gameState !== 'playing') return;

    const dot = dotRef.current;
    let newX = dot.x + dot.vx;
    let newY = dot.y + dot.vy;

    if (newX - DOT_RADIUS <= 0 || newX + DOT_RADIUS >= CANVAS_WIDTH) {
      dot.vx = -dot.vx;
      newX = dot.x + dot.vx;
    }
    if (newY - DOT_RADIUS <= 0 || newY + DOT_RADIUS >= CANVAS_HEIGHT) {
      dot.vy = -dot.vy;
      newY = dot.y + dot.vy;
    }

    if (checkCollision(newX, newY, DOT_RADIUS)) {
      dot.vx = -dot.vx;
      dot.vy = -dot.vy;
      newX = dot.x + dot.vx;
      newY = dot.y + dot.vy;
    }

    setLines(prevLines => {
      const currentTime = Date.now();
      const validLines = prevLines.filter(line => currentTime - line.timestamp < LINE_DURATION);
      
      for (let line of validLines) {
        if (lineIntersectsCircle(line, newX, newY, DOT_RADIUS)) {
          const dx = line.endX - line.startX;
          const dy = line.endY - line.startY;
          const length = Math.sqrt(dx * dx + dy * dy);
          if (length > 0) {
            const normalX = -dy / length;
            const normalY = dx / length;
            const dotProduct = dot.vx * normalX + dot.vy * normalY;
            dot.vx = dot.vx - 2 * dotProduct * normalX;
            dot.vy = dot.vy - 2 * dotProduct * normalY;
          }
          break;
        }
      }
      
      return validLines;
    });

    dot.x = newX;
    dot.y = newY;

    if (dot.x > CANVAS_WIDTH - 50 && dot.y > CANVAS_HEIGHT - 50) {
      setGameState('won');
      setScore(prev => prev + 100);
    }

    animationRef.current = requestAnimationFrame(gameLoop);
  }, [gameState]);

  useEffect(() => {
    if (gameState === 'playing') {
      animationRef.current = requestAnimationFrame(gameLoop);
    }
    return () => {
      if (animationRef.current) {
        cancelAnimationFrame(animationRef.current);
      }
    };
  }, [gameLoop, gameState]);

  useEffect(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;

    const ctx = canvas.getContext('2d');
    ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

    ctx.fillStyle = '#f0f0f0';
    ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

    ctx.fillStyle = '#333';
    maze.forEach(wall => {
      ctx.fillRect(wall.x, wall.y, wall.width, wall.height);
    });

    ctx.fillStyle = '#00ff00';
    ctx.fillRect(CANVAS_WIDTH - 50, CANVAS_HEIGHT - 50, 40, 40);

    const currentTime = Date.now();
    lines.forEach(line => {
      const age = currentTime - line.timestamp;
      const opacity = Math.max(0, 1 - age / LINE_DURATION);
      ctx.strokeStyle = `rgba(255, 0, 0, ${opacity})`;
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(line.startX, line.startY);
      ctx.lineTo(line.endX, line.endY);
      ctx.stroke();
    });

    if (currentLine) {
      ctx.strokeStyle = 'rgba(255, 0, 0, 0.5)';
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(currentLine.startX, currentLine.startY);
      ctx.lineTo(currentLine.endX, currentLine.endY);
      ctx.stroke();
    }

    const dot = dotRef.current;
    ctx.fillStyle = '#0066ff';
    ctx.beginPath();
    ctx.arc(dot.x, dot.y, DOT_RADIUS, 0, Math.PI * 2);
    ctx.fill();
  });

  const handleMouseDown = (e) => {
    if (gameState !== 'playing') return;
    const canvas = canvasRef.current;
    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    
    setIsDrawing(true);
    setCurrentLine({ startX: x, startY: y, endX: x, endY: y });
  };

  const handleMouseMove = (e
----------------------------------------


================================================================================
GAME GENERATION: Color Matcher: Match falling colored blocks by dragging and connecting same-colored pairs before they hit the bottom. - 2025-08-09 14:15:31.256522
================================================================================
FULL CLAUDE GENERATED CODE:
----------------------------------------
import React, { useState, useEffect, useCallback } from 'react';

const GameZone = ({ currentGame }) => {
  const [blocks, setBlocks] = useState([]);
  const [score, setScore] = useState(0);
  const [gameOver, setGameOver] = useState(false);
  const [selectedBlock, setSelectedBlock] = useState(null);
  const [gameStarted, setGameStarted] = useState(false);

  const colors = ['#ff6b6b', '#4ecdc4', '#45b7d1', '#96ceb4', '#ffeaa7'];
  const gameWidth = 400;
  const gameHeight = 300;

  const generateBlock = useCallback(() => {
    return {
      id: Math.random(),
      x: Math.random() * (gameWidth - 40),
      y: -40,
      color: colors[Math.floor(Math.random() * colors.length)],
      matched: false
    };
  }, []);

  const resetGame = () => {
    setBlocks([]);
    setScore(0);
    setGameOver(false);
    setSelectedBlock(null);
    setGameStarted(true);
  };

  useEffect(() => {
    if (!gameStarted || gameOver) return;

    const gameLoop = setInterval(() => {
      setBlocks(prevBlocks => {
        const newBlocks = prevBlocks.map(block => ({
          ...block,
          y: block.y + 1
        }));

        const activeBlocks = newBlocks.filter(block => !block.matched && block.y < gameHeight);
        const bottomBlocks = newBlocks.filter(block => block.y >= gameHeight && !block.matched);

        if (bottomBlocks.length > 0) {
          setGameOver(true);
          return newBlocks;
        }

        if (Math.random() < 0.02 && activeBlocks.length < 8) {
          activeBlocks.push(generateBlock());
        }

        return activeBlocks;
      });
    }, 50);

    return () => clearInterval(gameLoop);
  }, [gameStarted, gameOver, generateBlock]);

  const handleBlockClick = (block) => {
    if (block.matched) return;

    if (!selectedBlock) {
      setSelectedBlock(block);
    } else if (selectedBlock.id === block.id) {
      setSelectedBlock(null);
    } else if (selectedBlock.color === block.color) {
      setBlocks(prevBlocks => 
        prevBlocks.map(b => 
          b.id === selectedBlock.id || b.id === block.id 
            ? { ...b, matched: true }
            : b
        )
      );
      setScore(prev => prev + 10);
      setSelectedBlock(null);
      
      setTimeout(() => {
        setBlocks(prevBlocks => 
          prevBlocks.filter(b => b.id !== selectedBlock.id && b.id !== block.id)
        );
      }, 200);
    } else {
      setSelectedBlock(block);
    }
  };

  if (!gameStarted) {
    return (
      <div style={{
        width: gameWidth,
        height: gameHeight,
        border: '2px solid #333',
        display: 'flex',
        flexDirection: 'column',
        justifyContent: 'center',
        alignItems: 'center',
        backgroundColor: '#f0f0f0',
        fontFamily: 'Arial, sans-serif'
      }}>
        <h2 style={{ margin: '10px', textAlign: 'center' }}>Color Matcher</h2>
        <p style={{ margin: '10px', textAlign: 'center', fontSize: '14px' }}>
          Click same-colored blocks to match them before they hit the bottom!
        </p>
        <button
          onClick={resetGame}
          style={{
            padding: '10px 20px',
            fontSize: '16px',
            backgroundColor: '#4ecdc4',
            color: 'white',
            border: 'none',
            borderRadius: '5px',
            cursor: 'pointer'
          }}
        >
          Start Game
        </button>
      </div>
    );
  }

  return (
    <div style={{
      width: gameWidth,
      height: gameHeight + 60,
      border: '2px solid #333',
      position: 'relative',
      backgroundColor: '#f9f9f9',
      fontFamily: 'Arial, sans-serif'
    }}>
      <div style={{
        height: '40px',
        backgroundColor: '#333',
        color: 'white',
        display: 'flex',
        justifyContent: 'space-between',
        alignItems: 'center',
        padding: '0 10px'
      }}>
        <div>Score: {score}</div>
        <button
          onClick={resetGame}
          style={{
            padding: '5px 10px',
            backgroundColor: '#ff6b6b',
            color: 'white',
            border: 'none',
            borderRadius: '3px',
            cursor: 'pointer',
            fontSize: '12px'
          }}
        >
          Restart
        </button>
      </div>

      <div style={{
        width: gameWidth,
        height: gameHeight,
        position: 'relative',
        overflow: 'hidden',
        backgroundColor: '#e8e8e8'
      }}>
        {blocks.map(block => (
          <div
            key={block.id}
            onClick={() => handleBlockClick(block)}
            style={{
              position: 'absolute',
              left: block.x,
              top: block.y,
              width: '40px',
              height: '40px',
              backgroundColor: block.color,
              border: selectedBlock?.id === block.id ? '3px solid #333' : '2px solid #fff',
              borderRadius: '5px',
              cursor: 'pointer',
              opacity: block.matched ? 0.3 : 1,
              transition: 'opacity 0.2s',
              display: 'flex',
              alignItems: 'center',
              justifyContent: 'center',
              fontSize: '12px',
              fontWeight: 'bold',
              color: '#333'
            }}
          >
            {selectedBlock?.id === block.id ? '‚úì' : ''}
          </div>
        ))}
      </div>

      {gameOver && (
        <div style={{
          position: 'absolute',
          top: '50%',
          left: '50%',
          transform: 'translate(-50%, -50%)',
          backgroundColor: 'rgba(0,0,0,0.8)',
          color: 'white',
          padding: '20px',
          borderRadius: '10px',
          textAlign: 'center'
        }}>
          <h3>Game Over!</h3>
          <p>Final Score: {score}</p>
          <button
            onClick={resetGame}
            style={{
              padding: '10px 20px',
              backgroundColor: '#4ecdc4',
              color: 'white',
              border: 'none',
              borderRadius: '5px',
              cursor: 'pointer'
            }}
          >
            Play Again
          </button>
        </div>
      )}
    </div>
  );
};

export default GameZone;
----------------------------------------


================================================================================
GAME GENERATION: Neon Dodge: Weave through scrolling geometric obstacles as a glowing triangle while collecting power-ups that temporarily shrink your hitbox. - 2025-08-09 14:15:34.017764
================================================================================
FULL CLAUDE GENERATED CODE:
----------------------------------------
import React, { useState, useEffect, useRef, useCallback } from 'react';

const GameZone = ({ currentGame }) => {
  const canvasRef = useRef(null);
  const animationRef = useRef(null);
  const gameStateRef = useRef({
    player: { x: 50, y: 150, size: 12, shrunk: false, shrinkTimer: 0 },
    obstacles: [],
    powerUps: [],
    score: 0,
    gameRunning: false,
    gameOver: false,
    keys: {}
  });

  const [score, setScore] = useState(0);
  const [gameOver, setGameOver] = useState(false);
  const [gameRunning, setGameRunning] = useState(false);

  const CANVAS_WIDTH = 400;
  const CANVAS_HEIGHT = 300;
  const PLAYER_SPEED = 3;
  const OBSTACLE_SPEED = 2;
  const POWERUP_SPEED = 1.5;

  const resetGame = useCallback(() => {
    gameStateRef.current = {
      player: { x: 50, y: 150, size: 12, shrunk: false, shrinkTimer: 0 },
      obstacles: [],
      powerUps: [],
      score: 0,
      gameRunning: true,
      gameOver: false,
      keys: {}
    };
    setScore(0);
    setGameOver(false);
    setGameRunning(true);
  }, []);

  const startGame = useCallback(() => {
    resetGame();
  }, [resetGame]);

  const stopGame = useCallback(() => {
    gameStateRef.current.gameRunning = false;
    setGameRunning(false);
    setGameOver(true);
    if (animationRef.current) {
      cancelAnimationFrame(animationRef.current);
    }
  }, []);

  const spawnObstacle = useCallback(() => {
    const obstacle = {
      x: CANVAS_WIDTH,
      y: Math.random() * (CANVAS_HEIGHT - 40),
      width: 20 + Math.random() * 30,
      height: 20 + Math.random() * 30,
      color: `hsl(${Math.random() * 60 + 300}, 100%, 60%)`
    };
    gameStateRef.current.obstacles.push(obstacle);
  }, []);

  const spawnPowerUp = useCallback(() => {
    const powerUp = {
      x: CANVAS_WIDTH,
      y: Math.random() * (CANVAS_HEIGHT - 20),
      size: 8,
      color: '#00ff00'
    };
    gameStateRef.current.powerUps.push(powerUp);
  }, []);

  const checkCollision = useCallback((rect1, rect2) => {
    return rect1.x < rect2.x + rect2.width &&
           rect1.x + rect1.width > rect2.x &&
           rect1.y < rect2.y + rect2.height &&
           rect1.y + rect1.height > rect2.y;
  }, []);

  const updateGame = useCallback(() => {
    const state = gameStateRef.current;
    if (!state.gameRunning) return;

    const player = state.player;
    
    // Handle player movement
    if (state.keys['ArrowUp'] && player.y > 0) {
      player.y -= PLAYER_SPEED;
    }
    if (state.keys['ArrowDown'] && player.y < CANVAS_HEIGHT - player.size * 2) {
      player.y += PLAYER_SPEED;
    }
    if (state.keys['ArrowLeft'] && player.x > 0) {
      player.x -= PLAYER_SPEED;
    }
    if (state.keys['ArrowRight'] && player.x < CANVAS_WIDTH - player.size * 2) {
      player.x += PLAYER_SPEED;
    }

    // Update shrink timer
    if (player.shrunk) {
      player.shrinkTimer--;
      if (player.shrinkTimer <= 0) {
        player.shrunk = false;
        player.size = 12;
      }
    }

    // Spawn obstacles
    if (Math.random() < 0.02) {
      spawnObstacle();
    }

    // Spawn power-ups
    if (Math.random() < 0.005) {
      spawnPowerUp();
    }

    // Update obstacles
    state.obstacles = state.obstacles.filter(obstacle => {
      obstacle.x -= OBSTACLE_SPEED;
      return obstacle.x > -obstacle.width;
    });

    // Update power-ups
    state.powerUps = state.powerUps.filter(powerUp => {
      powerUp.x -= POWERUP_SPEED;
      return powerUp.x > -powerUp.size;
    });

    // Check obstacle collisions
    const playerRect = { x: player.x, y: player.y, width: player.size * 2, height: player.size * 2 };
    for (let obstacle of state.obstacles) {
      if (checkCollision(playerRect, obstacle)) {
        stopGame();
        return;
      }
    }

    // Check power-up collisions
    state.powerUps = state.powerUps.filter(powerUp => {
      const powerUpRect = { x: powerUp.x, y: powerUp.y, width: powerUp.size * 2, height: powerUp.size * 2 };
      if (checkCollision(playerRect, powerUpRect)) {
        player.shrunk = true;
        player.shrinkTimer = 300; // 5 seconds at 60fps
        player.size = 6;
        return false;
      }
      return true;
    });

    // Update score
    state.score += 1;
    setScore(state.score);
  }, [checkCollision, spawnObstacle, spawnPowerUp, stopGame]);

  const draw = useCallback(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;

    const ctx = canvas.getContext('2d');
    const state = gameStateRef.current;

    // Clear canvas with dark background
    ctx.fillStyle = '#000011';
    ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

    if (!state.gameRunning && !state.gameOver) return;

    // Draw player (glowing triangle)
    ctx.save();
    ctx.translate(state.player.x + state.player.size, state.player.y + state.player.size);
    
    // Glow effect
    ctx.shadowColor = state.player.shrunk ? '#00ff00' : '#00ffff';
    ctx.shadowBlur = 15;
    
    ctx.fillStyle = state.player.shrunk ? '#00ff00' : '#00ffff';
    ctx.beginPath();
    ctx.moveTo(state.player.size, 0);
    ctx.lineTo(-state.player.size, state.player.size);
    ctx.lineTo(-state.player.size, -state.player.size);
    ctx.closePath();
    ctx.fill();
    
    ctx.restore();

    // Draw obstacles
    state.obstacles.forEach(obstacle => {
      ctx.save();
      ctx.shadowColor = obstacle.color;
      ctx.shadowBlur = 10;
      ctx.fillStyle = obstacle.color;
      ctx.fillRect(obstacle.x, obstacle.y, obstacle.width, obstacle.height);
      ctx.restore();
    });

    // Draw power-ups
    state.powerUps.forEach(powerUp => {
      ctx.save();
      ctx.shadowColor = powerUp.color;
      ctx.shadowBlur = 8;
      ctx.fillStyle = powerUp.color;
      ctx.beginPath();
      ctx.arc(powerUp.x + powerUp.size, powerUp.y + powerUp.size, powerUp.
----------------------------------------


================================================================================
GAME GENERATION: Neon Bounce: Tap to bounce a glowing ball between moving platforms while avoiding deadly red barriers. - 2025-08-09 14:16:14.877479
================================================================================
FULL CLAUDE GENERATED CODE:
----------------------------------------
import React, { useState, useEffect, useRef, useCallback } from 'react';

const GameZone = ({ currentGame }) => {
  const canvasRef = useRef(null);
  const animationRef = useRef(null);
  const gameStateRef = useRef({
    ball: { x: 200, y: 150, vx: 0, vy: 0, radius: 8 },
    platforms: [
      { x: 50, y: 250, width: 80, height: 8, vx: 1 },
      { x: 270, y: 180, width: 80, height: 8, vx: -1 },
      { x: 150, y: 100, width: 80, height: 8, vx: 1.5 }
    ],
    barriers: [
      { x: 0, y: 80, width: 400, height: 4 },
      { x: 0, y: 280, width: 400, height: 4 }
    ],
    score: 0,
    gameOver: false,
    gravity: 0.3,
    bounceForce: -8
  });

  const [score, setScore] = useState(0);
  const [gameOver, setGameOver] = useState(false);

  const resetGame = useCallback(() => {
    gameStateRef.current = {
      ball: { x: 200, y: 150, vx: 0, vy: 0, radius: 8 },
      platforms: [
        { x: 50, y: 250, width: 80, height: 8, vx: 1 },
        { x: 270, y: 180, width: 80, height: 8, vx: -1 },
        { x: 150, y: 100, width: 80, height: 8, vx: 1.5 }
      ],
      barriers: [
        { x: 0, y: 80, width: 400, height: 4 },
        { x: 0, y: 280, width: 400, height: 4 }
      ],
      score: 0,
      gameOver: false,
      gravity: 0.3,
      bounceForce: -8
    };
    setScore(0);
    setGameOver(false);
  }, []);

  const handleTap = useCallback(() => {
    if (!gameStateRef.current.gameOver) {
      gameStateRef.current.ball.vy = gameStateRef.current.bounceForce;
    }
  }, []);

  const checkCollision = useCallback((rect1, rect2) => {
    return rect1.x < rect2.x + rect2.width &&
           rect1.x + rect1.width > rect2.x &&
           rect1.y < rect2.y + rect2.height &&
           rect1.y + rect1.height > rect2.y;
  }, []);

  const updateGame = useCallback(() => {
    const game = gameStateRef.current;
    
    if (game.gameOver) return;

    // Update ball physics
    game.ball.vy += game.gravity;
    game.ball.x += game.ball.vx;
    game.ball.y += game.ball.vy;

    // Update platforms
    game.platforms.forEach(platform => {
      platform.x += platform.vx;
      if (platform.x <= 0 || platform.x + platform.width >= 400) {
        platform.vx *= -1;
      }
    });

    // Check platform collisions
    game.platforms.forEach(platform => {
      const ballRect = {
        x: game.ball.x - game.ball.radius,
        y: game.ball.y - game.ball.radius,
        width: game.ball.radius * 2,
        height: game.ball.radius * 2
      };
      
      if (checkCollision(ballRect, platform) && game.ball.vy > 0) {
        game.ball.vy = game.bounceForce * 0.8;
        game.score += 10;
        setScore(game.score);
      }
    });

    // Check barrier collisions
    game.barriers.forEach(barrier => {
      const ballRect = {
        x: game.ball.x - game.ball.radius,
        y: game.ball.y - game.ball.radius,
        width: game.ball.radius * 2,
        height: game.ball.radius * 2
      };
      
      if (checkCollision(ballRect, barrier)) {
        game.gameOver = true;
        setGameOver(true);
      }
    });

    // Check bounds
    if (game.ball.x < 0 || game.ball.x > 400 || game.ball.y > 300) {
      game.gameOver = true;
      setGameOver(true);
    }
  }, [checkCollision]);

  const draw = useCallback(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;
    
    const ctx = canvas.getContext('2d');
    const game = gameStateRef.current;
    
    // Clear canvas
    ctx.fillStyle = '#000';
    ctx.fillRect(0, 0, 400, 300);
    
    // Draw ball with glow effect
    ctx.shadowColor = '#00ffff';
    ctx.shadowBlur = 20;
    ctx.fillStyle = '#00ffff';
    ctx.beginPath();
    ctx.arc(game.ball.x, game.ball.y, game.ball.radius, 0, Math.PI * 2);
    ctx.fill();
    
    // Reset shadow
    ctx.shadowBlur = 0;
    
    // Draw platforms with glow
    ctx.shadowColor = '#00ff00';
    ctx.shadowBlur = 10;
    ctx.fillStyle = '#00ff00';
    game.platforms.forEach(platform => {
      ctx.fillRect(platform.x, platform.y, platform.width, platform.height);
    });
    
    // Draw barriers
    ctx.shadowColor = '#ff0000';
    ctx.shadowBlur = 15;
    ctx.fillStyle = '#ff0000';
    game.barriers.forEach(barrier => {
      ctx.fillRect(barrier.x, barrier.y, barrier.width, barrier.height);
    });
    
    // Reset shadow
    ctx.shadowBlur = 0;
  }, []);

  const gameLoop = useCallback(() => {
    updateGame();
    draw();
    animationRef.current = requestAnimationFrame(gameLoop);
  }, [updateGame, draw]);

  useEffect(() => {
    const canvas = canvasRef.current;
    if (canvas) {
      canvas.width = 400;
      canvas.height = 300;
    }
    
    gameLoop();
    
    return () => {
      if (animationRef.current) {
        cancelAnimationFrame(animationRef.current);
      }
    };
  }, [gameLoop]);

  return (
    <div style={{ 
      display: 'flex', 
      flexDirection: 'column', 
      alignItems: 'center', 
      padding: '20px',
      backgroundColor: '#111',
      minHeight: '100vh',
      color: '#fff',
      fontFamily: 'Arial, sans-serif'
    }}>
      <h2 style={{ 
        margin: '0 0 10px 0', 
        color: '#00ffff',
        textShadow: '0 0 10px #00ffff'
      }}>
        Neon Bounce
      </h2>
      
      <div style={{ marginBottom: '10px', fontSize: '18px' }}>
        Score: {score}
      </div>
      
      <canvas
        ref={canvasRef}
        onClick={handleTap}
        style={{
          border: '2px solid #333',
          cursor: 'pointer',
          
----------------------------------------


================================================================================
GAME GENERATION: Lucky Racer: hold-and-release to dash through breakable walls in a neon city. - 2025-08-09 14:19:36.447822
================================================================================
FULL CLAUDE GENERATED CODE:
----------------------------------------
import React, { useState, useEffect, useRef } from 'react';

const GameZone = ({ currentGame }) => {
  const canvasRef = useRef(null);
  const [gameState, setGameState] = useState('playing');
  const [score, setScore] = useState(0);
  const [isCharging, setIsCharging] = useState(false);
  const [chargeLevel, setChargeLevel] = useState(0);
  
  const gameRef = useRef({
    player: { x: 50, y: 150, width: 20, height: 20, vx: 0, vy: 0, isDashing: false, dashTime: 0 },
    walls: [],
    particles: [],
    camera: { x: 0 },
    keys: {},
    lastTime: 0,
    wallSpawnTimer: 0
  });

  const resetGame = () => {
    setGameState('playing');
    setScore(0);
    setIsCharging(false);
    setChargeLevel(0);
    const game = gameRef.current;
    game.player = { x: 50, y: 150, width: 20, height: 20, vx: 0, vy: 0, isDashing: false, dashTime: 0 };
    game.walls = [];
    game.particles = [];
    game.camera = { x: 0 };
    game.wallSpawnTimer = 0;
    
    // Initial walls
    for (let i = 0; i < 10; i++) {
      game.walls.push({
        x: 200 + i * 100,
        y: Math.random() * 200 + 50,
        width: 30,
        height: 60,
        broken: false,
        health: 1
      });
    }
  };

  useEffect(() => {
    resetGame();
  }, []);

  useEffect(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;
    
    const ctx = canvas.getContext('2d');
    const game = gameRef.current;
    
    const handleKeyDown = (e) => {
      game.keys[e.code] = true;
      if (e.code === 'Space') {
        e.preventDefault();
        if (!game.player.isDashing) {
          setIsCharging(true);
        }
      }
    };
    
    const handleKeyUp = (e) => {
      game.keys[e.code] = false;
      if (e.code === 'Space') {
        e.preventDefault();
        if (isCharging && !game.player.isDashing) {
          // Start dash
          const dashPower = Math.min(chargeLevel / 60, 1);
          game.player.isDashing = true;
          game.player.dashTime = dashPower * 30;
          game.player.vx = dashPower * 15;
          game.player.vy = 0;
        }
        setIsCharging(false);
        setChargeLevel(0);
      }
    };

    window.addEventListener('keydown', handleKeyDown);
    window.addEventListener('keyup', handleKeyUp);

    const gameLoop = (currentTime) => {
      const deltaTime = currentTime - game.lastTime;
      game.lastTime = currentTime;
      
      if (gameState !== 'playing') return;
      
      // Update charge level
      if (isCharging && chargeLevel < 120) {
        setChargeLevel(prev => prev + 2);
      }
      
      // Update player
      const player = game.player;
      
      if (player.isDashing) {
        player.dashTime--;
        if (player.dashTime <= 0) {
          player.isDashing = false;
          player.vx *= 0.8;
        }
      } else {
        // Normal movement
        if (game.keys['ArrowUp'] && player.y > 0) player.vy = -3;
        else if (game.keys['ArrowDown'] && player.y < 280) player.vy = 3;
        else player.vy *= 0.9;
        
        player.vx *= 0.95;
      }
      
      player.x += player.vx;
      player.y += player.vy;
      
      // Keep player in bounds
      player.y = Math.max(0, Math.min(280, player.y));
      
      // Update camera
      game.camera.x = player.x - 100;
      
      // Spawn new walls
      game.wallSpawnTimer++;
      if (game.wallSpawnTimer > 120) {
        game.wallSpawnTimer = 0;
        game.walls.push({
          x: game.camera.x + 500,
          y: Math.random() * 200 + 50,
          width: 30,
          height: 60,
          broken: false,
          health: 1
        });
      }
      
      // Check wall collisions
      game.walls.forEach(wall => {
        if (!wall.broken && 
            player.x < wall.x + wall.width &&
            player.x + player.width > wall.x &&
            player.y < wall.y + wall.height &&
            player.y + player.height > wall.y) {
          
          if (player.isDashing && player.vx > 8) {
            // Break wall
            wall.broken = true;
            setScore(prev => prev + 10);
            
            // Create particles
            for (let i = 0; i < 8; i++) {
              game.particles.push({
                x: wall.x + wall.width/2,
                y: wall.y + wall.height/2,
                vx: (Math.random() - 0.5) * 8,
                vy: (Math.random() - 0.5) * 8,
                life: 30,
                color: `hsl(${Math.random() * 60 + 180}, 100%, 60%)`
              });
            }
          } else {
            // Stop player
            player.vx = 0;
            player.x = wall.x - player.width - 1;
          }
        }
      });
      
      // Update particles
      game.particles = game.particles.filter(particle => {
        particle.x += particle.vx;
        particle.y += particle.vy;
        particle.vx *= 0.95;
        particle.vy *= 0.95;
        particle.life--;
        return particle.life > 0;
      });
      
      // Remove old walls
      game.walls = game.walls.filter(wall => wall.x > game.camera.x - 100);
      
      // Render
      ctx.fillStyle = '#000020';
      ctx.fillRect(0, 0, 400, 300);
      
      // Grid background
      ctx.strokeStyle = '#00ffff20';
      ctx.lineWidth = 1;
      for (let x = -game.camera.x % 40; x < 400; x += 40) {
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, 300);
        ctx.stroke();
      }
      for (let y = 0; y < 300; y += 40) {
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(400, y);
        ctx.stroke();
      }
      
      // Render walls
      game.walls.forEach(wall => {
        if (wall.broken) return;
        
        const screenX = wall.x - game.camera.x;
        if (screenX > -50 && screenX < 450) {
          ctx.fillStyle = '#ff0080';
          ctx.fillRect(screenX, wall.y, wall.width, wall.height);
          
          // Neon glow
          ctx.shadowColor = '#ff0080';
----------------------------------------


================================================================================
GAME GENERATION: DotChase: Move white 20px circle with Arrow keys (speed: 5px/frame) to catch randomly-spawning red 10px dots (1 every 2sec) while avoiding black 15px circles that spawn every 3sec and move toward player at 3px/frame; score +1 per dot, lose on black circle collision. - 2025-08-09 14:20:23.199396
================================================================================
FULL CLAUDE GENERATED CODE:
----------------------------------------
import React, { useState, useEffect, useCallback } from 'react';

const GameZone = ({ currentGame }) => {
  const [gameState, setGameState] = useState('playing');
  const [score, setScore] = useState(0);
  const [player, setPlayer] = useState({ x: 200, y: 150 });
  const [dots, setDots] = useState([]);
  const [enemies, setEnemies] = useState([]);
  const [keys, setKeys] = useState({});

  const GAME_WIDTH = 400;
  const GAME_HEIGHT = 300;
  const PLAYER_SIZE = 20;
  const DOT_SIZE = 10;
  const ENEMY_SIZE = 15;
  const PLAYER_SPEED = 5;
  const ENEMY_SPEED = 3;

  const generateRandomPosition = () => ({
    x: Math.random() * (GAME_WIDTH - 20) + 10,
    y: Math.random() * (GAME_HEIGHT - 20) + 10
  });

  const checkCollision = (obj1, obj2, size1, size2) => {
    const dx = obj1.x - obj2.x;
    const dy = obj1.y - obj2.y;
    const distance = Math.sqrt(dx * dx + dy * dy);
    return distance < (size1 + size2) / 2;
  };

  const resetGame = () => {
    setGameState('playing');
    setScore(0);
    setPlayer({ x: 200, y: 150 });
    setDots([]);
    setEnemies([]);
  };

  const gameLoop = useCallback(() => {
    if (gameState !== 'playing') return;

    setPlayer(prev => {
      let newX = prev.x;
      let newY = prev.y;

      if (keys.ArrowUp) newY = Math.max(PLAYER_SIZE/2, prev.y - PLAYER_SPEED);
      if (keys.ArrowDown) newY = Math.min(GAME_HEIGHT - PLAYER_SIZE/2, prev.y + PLAYER_SPEED);
      if (keys.ArrowLeft) newX = Math.max(PLAYER_SIZE/2, prev.x - PLAYER_SPEED);
      if (keys.ArrowRight) newX = Math.min(GAME_WIDTH - PLAYER_SIZE/2, prev.x + PLAYER_SPEED);

      return { x: newX, y: newY };
    });

    setEnemies(prev => prev.map(enemy => {
      const dx = player.x - enemy.x;
      const dy = player.y - enemy.y;
      const distance = Math.sqrt(dx * dx + dy * dy);
      
      if (distance > 0) {
        return {
          x: enemy.x + (dx / distance) * ENEMY_SPEED,
          y: enemy.y + (dy / distance) * ENEMY_SPEED
        };
      }
      return enemy;
    }));

    setDots(prev => {
      const remainingDots = prev.filter(dot => {
        if (checkCollision(player, dot, PLAYER_SIZE, DOT_SIZE)) {
          setScore(s => s + 1);
          return false;
        }
        return true;
      });
      return remainingDots;
    });

    setEnemies(prev => {
      const hasCollision = prev.some(enemy => 
        checkCollision(player, enemy, PLAYER_SIZE, ENEMY_SIZE)
      );
      if (hasCollision) {
        setGameState('gameOver');
      }
      return prev;
    });
  }, [gameState, keys, player]);

  useEffect(() => {
    const interval = setInterval(gameLoop, 16);
    return () => clearInterval(interval);
  }, [gameLoop]);

  useEffect(() => {
    const dotInterval = setInterval(() => {
      if (gameState === 'playing') {
        setDots(prev => [...prev, generateRandomPosition()]);
      }
    }, 2000);

    const enemyInterval = setInterval(() => {
      if (gameState === 'playing') {
        setEnemies(prev => [...prev, generateRandomPosition()]);
      }
    }, 3000);

    return () => {
      clearInterval(dotInterval);
      clearInterval(enemyInterval);
    };
  }, [gameState]);

  useEffect(() => {
    const handleKeyDown = (e) => {
      setKeys(prev => ({ ...prev, [e.key]: true }));
    };

    const handleKeyUp = (e) => {
      setKeys(prev => ({ ...prev, [e.key]: false }));
    };

    window.addEventListener('keydown', handleKeyDown);
    window.addEventListener('keyup', handleKeyUp);

    return () => {
      window.removeEventListener('keydown', handleKeyDown);
      window.removeEventListener('keyup', handleKeyUp);
    };
  }, []);

  return (
    <div style={{ textAlign: 'center', padding: '20px' }}>
      <div style={{ marginBottom: '10px' }}>
        <div>Score: {score}</div>
        {gameState === 'gameOver' && (
          <div style={{ color: 'red', fontWeight: 'bold' }}>Game Over!</div>
        )}
      </div>
      
      <div
        style={{
          position: 'relative',
          width: GAME_WIDTH,
          height: GAME_HEIGHT,
          border: '2px solid #333',
          margin: '0 auto',
          backgroundColor: '#f0f0f0'
        }}
      >
        <div
          style={{
            position: 'absolute',
            left: player.x - PLAYER_SIZE/2,
            top: player.y - PLAYER_SIZE/2,
            width: PLAYER_SIZE,
            height: PLAYER_SIZE,
            backgroundColor: 'white',
            borderRadius: '50%',
            border: '1px solid #ccc'
          }}
        />
        
        {dots.map((dot, index) => (
          <div
            key={index}
            style={{
              position: 'absolute',
              left: dot.x - DOT_SIZE/2,
              top: dot.y - DOT_SIZE/2,
              width: DOT_SIZE,
              height: DOT_SIZE,
              backgroundColor: 'red',
              borderRadius: '50%'
            }}
          />
        ))}
        
        {enemies.map((enemy, index) => (
          <div
            key={index}
            style={{
              position: 'absolute',
              left: enemy.x - ENEMY_SIZE/2,
              top: enemy.y - ENEMY_SIZE/2,
              width: ENEMY_SIZE,
              height: ENEMY_SIZE,
              backgroundColor: 'black',
              borderRadius: '50%'
            }}
          />
        ))}
      </div>
      
      <div style={{ marginTop: '10px' }}>
        <button onClick={resetGame} style={{ padding: '8px 16px', fontSize: '16px' }}>
          {gameState === 'gameOver' ? 'Play Again' : 'Restart'}
        </button>
      </div>
      
      <div style={{ marginTop: '10px', fontSize: '12px', color: '#666' }}>
        Use Arrow Keys to move. Catch red dots, avoid black circles!
      </div>
    </div>
  );
};

export default GameZone;
----------------------------------------


================================================================================
GAME GENERATION: Lucky Glider: swipe to change lanes and avoid traffic on floating islands. - 2025-08-09 14:25:09.344616
================================================================================
FULL CLAUDE GENERATED CODE:
----------------------------------------
import React, { useState, useEffect, useRef, useCallback } from 'react';

const GameZone = ({ currentGame }) => {
  const canvasRef = useRef(null);
  const [gameState, setGameState] = useState('playing');
  const [score, setScore] = useState(0);
  const [playerLane, setPlayerLane] = useState(1);
  const [islands, setIslands] = useState([]);
  const [traffic, setTraffic] = useState([]);
  const [gameSpeed, setGameSpeed] = useState(2);

  const CANVAS_WIDTH = 400;
  const CANVAS_HEIGHT = 300;
  const LANES = 3;
  const LANE_WIDTH = CANVAS_WIDTH / LANES;
  const PLAYER_SIZE = 20;
  const TRAFFIC_SIZE = 15;
  const ISLAND_HEIGHT = 40;

  const resetGame = useCallback(() => {
    setGameState('playing');
    setScore(0);
    setPlayerLane(1);
    setIslands([
      { x: 0, y: 260, width: CANVAS_WIDTH, height: ISLAND_HEIGHT },
      { x: 0, y: 180, width: CANVAS_WIDTH, height: ISLAND_HEIGHT },
      { x: 0, y: 100, width: CANVAS_WIDTH, height: ISLAND_HEIGHT },
      { x: 0, y: 20, width: CANVAS_WIDTH, height: ISLAND_HEIGHT }
    ]);
    setTraffic([]);
    setGameSpeed(2);
  }, []);

  const handleSwipe = useCallback((direction) => {
    if (gameState !== 'playing') return;
    
    if (direction === 'left' && playerLane > 0) {
      setPlayerLane(prev => prev - 1);
    } else if (direction === 'right' && playerLane < LANES - 1) {
      setPlayerLane(prev => prev + 1);
    }
  }, [gameState, playerLane]);

  const handleKeyPress = useCallback((e) => {
    if (e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'A') {
      handleSwipe('left');
    } else if (e.key === 'ArrowRight' || e.key === 'd' || e.key === 'D') {
      handleSwipe('right');
    }
  }, [handleSwipe]);

  const handleTouch = useCallback((e) => {
    e.preventDefault();
    const touch = e.touches[0] || e.changedTouches[0];
    const rect = canvasRef.current.getBoundingClientRect();
    const x = touch.clientX - rect.left;
    
    if (x < CANVAS_WIDTH / 2) {
      handleSwipe('left');
    } else {
      handleSwipe('right');
    }
  }, [handleSwipe]);

  useEffect(() => {
    resetGame();
  }, [resetGame]);

  useEffect(() => {
    window.addEventListener('keydown', handleKeyPress);
    return () => window.removeEventListener('keydown', handleKeyPress);
  }, [handleKeyPress]);

  useEffect(() => {
    if (gameState !== 'playing') return;

    const gameLoop = setInterval(() => {
      setIslands(prev => prev.map(island => ({
        ...island,
        y: island.y + gameSpeed
      })).filter(island => island.y < CANVAS_HEIGHT + ISLAND_HEIGHT));

      setTraffic(prev => {
        let newTraffic = prev.map(car => ({
          ...car,
          y: car.y + gameSpeed
        })).filter(car => car.y < CANVAS_HEIGHT + TRAFFIC_SIZE);

        if (Math.random() < 0.03) {
          const lane = Math.floor(Math.random() * LANES);
          newTraffic.push({
            x: lane * LANE_WIDTH + LANE_WIDTH / 2 - TRAFFIC_SIZE / 2,
            y: -TRAFFIC_SIZE,
            lane: lane
          });
        }

        return newTraffic;
      });

      setScore(prev => prev + 1);
      setGameSpeed(prev => Math.min(prev + 0.005, 4));

      setTraffic(currentTraffic => {
        const playerX = playerLane * LANE_WIDTH + LANE_WIDTH / 2;
        const playerY = CANVAS_HEIGHT - 60;
        
        for (let car of currentTraffic) {
          const distance = Math.sqrt(
            Math.pow(car.x + TRAFFIC_SIZE / 2 - playerX, 2) + 
            Math.pow(car.y + TRAFFIC_SIZE / 2 - playerY, 2)
          );
          
          if (distance < (PLAYER_SIZE + TRAFFIC_SIZE) / 2) {
            setGameState('gameOver');
            break;
          }
        }
        
        return currentTraffic;
      });

      setIslands(currentIslands => {
        if (currentIslands.length < 4) {
          const newIslands = [...currentIslands];
          const lastIsland = newIslands[newIslands.length - 1];
          if (!lastIsland || lastIsland.y > -ISLAND_HEIGHT) {
            newIslands.push({
              x: 0,
              y: lastIsland ? lastIsland.y - 80 : -ISLAND_HEIGHT,
              width: CANVAS_WIDTH,
              height: ISLAND_HEIGHT
            });
          }
          return newIslands;
        }
        return currentIslands;
      });
    }, 16);

    return () => clearInterval(gameLoop);
  }, [gameState, gameSpeed, playerLane]);

  useEffect(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;

    const ctx = canvas.getContext('2d');
    ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

    ctx.fillStyle = '#87CEEB';
    ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

    islands.forEach(island => {
      ctx.fillStyle = '#90EE90';
      ctx.fillRect(island.x, island.y, island.width, island.height);
      
      ctx.fillStyle = '#228B22';
      ctx.fillRect(island.x, island.y, island.width, 5);
    });

    for (let i = 1; i < LANES; i++) {
      ctx.strokeStyle = '#FFFFFF';
      ctx.lineWidth = 2;
      ctx.setLineDash([10, 10]);
      ctx.beginPath();
      ctx.moveTo(i * LANE_WIDTH, 0);
      ctx.lineTo(i * LANE_WIDTH, CANVAS_HEIGHT);
      ctx.stroke();
      ctx.setLineDash([]);
    }

    traffic.forEach(car => {
      ctx.fillStyle = '#FF4444';
      ctx.fillRect(car.x, car.y, TRAFFIC_SIZE, TRAFFIC_SIZE);
    });

    const playerX = playerLane * LANE_WIDTH + LANE_WIDTH / 2 - PLAYER_SIZE / 2;
    const playerY = CANVAS_HEIGHT - 60;
    
    ctx.fillStyle = '#4169E1';
    ctx.beginPath();
    ctx.moveTo(playerX + PLAYER_SIZE / 2, playerY);
    ctx.lineTo(playerX, playerY + PLAYER_SIZE);
    ctx.lineTo(playerX + PLAYER_SIZE, playerY + PLAYER_SIZE);
    ctx.closePath();
    ctx.fill();

    ctx.fillStyle = '#FFFFFF';
    ctx.font = '16px Arial';
    ctx.fillText(`Score: ${score}`, 10, 25);
    
    if (gameState === 'gameOver') {
----------------------------------------


================================================================================
GAME GENERATION: DotChase: Move blue 20px circle with Arrow keys at 5px/step to collect green 10px dots (+1 point each) while avoiding red 15px circles that spawn every 2s and move at 3px/step toward player; game ends if touched by red circle or reaching 30 points. - 2025-08-09 14:26:01.315612
================================================================================
FULL CLAUDE GENERATED CODE:
----------------------------------------
import React, { useState, useEffect, useRef, useCallback } from 'react';

const GameZone = ({ currentGame }) => {
  const canvasRef = useRef(null);
  const gameLoopRef = useRef(null);
  const keysRef = useRef({});
  
  const [gameState, setGameState] = useState({
    player: { x: 200, y: 150 },
    dots: [],
    enemies: [],
    score: 0,
    gameOver: false,
    won: false
  });

  const CANVAS_WIDTH = 400;
  const CANVAS_HEIGHT = 300;
  const PLAYER_SIZE = 20;
  const DOT_SIZE = 10;
  const ENEMY_SIZE = 15;
  const PLAYER_SPEED = 5;
  const ENEMY_SPEED = 3;

  const resetGame = useCallback(() => {
    setGameState({
      player: { x: 200, y: 150 },
      dots: [
        { x: 50, y: 50 },
        { x: 350, y: 50 },
        { x: 50, y: 250 },
        { x: 350, y: 250 },
        { x: 200, y: 100 }
      ],
      enemies: [],
      score: 0,
      gameOver: false,
      won: false
    });
  }, []);

  const spawnDot = useCallback(() => {
    return {
      x: Math.random() * (CANVAS_WIDTH - DOT_SIZE),
      y: Math.random() * (CANVAS_HEIGHT - DOT_SIZE)
    };
  }, []);

  const spawnEnemy = useCallback(() => {
    const side = Math.floor(Math.random() * 4);
    let x, y;
    
    switch(side) {
      case 0: x = 0; y = Math.random() * CANVAS_HEIGHT; break;
      case 1: x = CANVAS_WIDTH; y = Math.random() * CANVAS_HEIGHT; break;
      case 2: x = Math.random() * CANVAS_WIDTH; y = 0; break;
      case 3: x = Math.random() * CANVAS_WIDTH; y = CANVAS_HEIGHT; break;
    }
    
    return { x, y };
  }, []);

  const checkCollision = useCallback((obj1, obj2, size1, size2) => {
    const dx = obj1.x - obj2.x;
    const dy = obj1.y - obj2.y;
    const distance = Math.sqrt(dx * dx + dy * dy);
    return distance < (size1 + size2) / 2;
  }, []);

  const updateGame = useCallback(() => {
    setGameState(prevState => {
      if (prevState.gameOver || prevState.won) return prevState;

      let newState = { ...prevState };
      
      // Move player
      let newX = newState.player.x;
      let newY = newState.player.y;
      
      if (keysRef.current.ArrowLeft) newX = Math.max(PLAYER_SIZE/2, newX - PLAYER_SPEED);
      if (keysRef.current.ArrowRight) newX = Math.min(CANVAS_WIDTH - PLAYER_SIZE/2, newX + PLAYER_SPEED);
      if (keysRef.current.ArrowUp) newY = Math.max(PLAYER_SIZE/2, newY - PLAYER_SPEED);
      if (keysRef.current.ArrowDown) newY = Math.min(CANVAS_HEIGHT - PLAYER_SIZE/2, newY + PLAYER_SPEED);
      
      newState.player = { x: newX, y: newY };

      // Move enemies toward player
      newState.enemies = newState.enemies.map(enemy => {
        const dx = newState.player.x - enemy.x;
        const dy = newState.player.y - enemy.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        if (distance > 0) {
          const moveX = (dx / distance) * ENEMY_SPEED;
          const moveY = (dy / distance) * ENEMY_SPEED;
          return {
            x: enemy.x + moveX,
            y: enemy.y + moveY
          };
        }
        return enemy;
      });

      // Check dot collection
      newState.dots = newState.dots.filter(dot => {
        if (checkCollision(newState.player, dot, PLAYER_SIZE, DOT_SIZE)) {
          newState.score++;
          return false;
        }
        return true;
      });

      // Spawn new dots if needed
      while (newState.dots.length < 3) {
        newState.dots.push(spawnDot());
      }

      // Check enemy collision
      for (let enemy of newState.enemies) {
        if (checkCollision(newState.player, enemy, PLAYER_SIZE, ENEMY_SIZE)) {
          newState.gameOver = true;
          break;
        }
      }

      // Check win condition
      if (newState.score >= 30) {
        newState.won = true;
      }

      return newState;
    });
  }, [checkCollision, spawnDot]);

  const draw = useCallback(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;
    
    const ctx = canvas.getContext('2d');
    ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

    // Draw player
    ctx.fillStyle = 'blue';
    ctx.beginPath();
    ctx.arc(gameState.player.x, gameState.player.y, PLAYER_SIZE/2, 0, 2 * Math.PI);
    ctx.fill();

    // Draw dots
    ctx.fillStyle = 'green';
    gameState.dots.forEach(dot => {
      ctx.beginPath();
      ctx.arc(dot.x + DOT_SIZE/2, dot.y + DOT_SIZE/2, DOT_SIZE/2, 0, 2 * Math.PI);
      ctx.fill();
    });

    // Draw enemies
    ctx.fillStyle = 'red';
    gameState.enemies.forEach(enemy => {
      ctx.beginPath();
      ctx.arc(enemy.x, enemy.y, ENEMY_SIZE/2, 0, 2 * Math.PI);
      ctx.fill();
    });
  }, [gameState]);

  useEffect(() => {
    resetGame();
  }, [resetGame]);

  useEffect(() => {
    const handleKeyDown = (e) => {
      if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key)) {
        e.preventDefault();
        keysRef.current[e.key] = true;
      }
    };

    const handleKeyUp = (e) => {
      keysRef.current[e.key] = false;
    };

    window.addEventListener('keydown', handleKeyDown);
    window.addEventListener('keyup', handleKeyUp);

    return () => {
      window.removeEventListener('keydown', handleKeyDown);
      window.removeEventListener('keyup', handleKeyUp);
    };
  }, []);

  useEffect(() => {
    if (!gameState.gameOver && !gameState.won) {
      gameLoopRef.current = setInterval(() => {
        updateGame();
      }, 1000 / 60);

      return () => {
        if (gameLoopRef.current) {
          clearInterval(gameLoopRef.current);
        }
      };
    }
  }, [gameState.gameOver, gameState.won, updateGame]);

  useEffect(() => {
    if (!gameState.gameOver && !gameState.won) {
      const enemySpawnInterval = setInterval(() => {
        setGameState(prevState => ({
----------------------------------------


================================================================================
GAME GENERATION: Turbo Glider: swipe to change lanes and avoid traffic in retro space. - 2025-08-09 14:29:25.306365
================================================================================
FULL CLAUDE GENERATED CODE:
----------------------------------------
import React, { useState, useEffect, useRef, useCallback } from 'react';

const GameZone = ({ currentGame }) => {
  const canvasRef = useRef(null);
  const [gameState, setGameState] = useState('playing');
  const [score, setScore] = useState(0);
  const [playerLane, setPlayerLane] = useState(1);
  const [obstacles, setObstacles] = useState([]);
  const [gameSpeed, setGameSpeed] = useState(2);
  
  const CANVAS_WIDTH = 400;
  const CANVAS_HEIGHT = 300;
  const LANES = 3;
  const LANE_WIDTH = CANVAS_WIDTH / LANES;
  const PLAYER_SIZE = 20;
  const OBSTACLE_SIZE = 15;

  const resetGame = useCallback(() => {
    setGameState('playing');
    setScore(0);
    setPlayerLane(1);
    setObstacles([]);
    setGameSpeed(2);
  }, []);

  const spawnObstacle = useCallback(() => {
    const lane = Math.floor(Math.random() * LANES);
    const newObstacle = {
      id: Date.now() + Math.random(),
      lane: lane,
      y: -OBSTACLE_SIZE,
      x: lane * LANE_WIDTH + LANE_WIDTH / 2 - OBSTACLE_SIZE / 2
    };
    setObstacles(prev => [...prev, newObstacle]);
  }, []);

  const handleSwipe = useCallback((direction) => {
    if (gameState !== 'playing') return;
    
    setPlayerLane(prev => {
      if (direction === 'left' && prev > 0) return prev - 1;
      if (direction === 'right' && prev < LANES - 1) return prev + 1;
      return prev;
    });
  }, [gameState]);

  const checkCollision = useCallback((playerX, playerY, obstacleX, obstacleY) => {
    return playerX < obstacleX + OBSTACLE_SIZE &&
           playerX + PLAYER_SIZE > obstacleX &&
           playerY < obstacleY + OBSTACLE_SIZE &&
           playerY + PLAYER_SIZE > obstacleY;
  }, []);

  useEffect(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;
    
    const ctx = canvas.getContext('2d');
    let animationId;
    let lastSpawn = 0;
    
    const gameLoop = (timestamp) => {
      if (gameState !== 'playing') return;
      
      ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
      
      // Draw space background
      ctx.fillStyle = '#000011';
      ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
      
      // Draw stars
      for (let i = 0; i < 50; i++) {
        const x = (i * 37) % CANVAS_WIDTH;
        const y = (timestamp * 0.1 + i * 23) % CANVAS_HEIGHT;
        ctx.fillStyle = '#ffffff';
        ctx.fillRect(x, y, 1, 1);
      }
      
      // Draw lane dividers
      ctx.strokeStyle = '#333';
      ctx.lineWidth = 2;
      for (let i = 1; i < LANES; i++) {
        ctx.beginPath();
        ctx.setLineDash([10, 10]);
        ctx.moveTo(i * LANE_WIDTH, 0);
        ctx.lineTo(i * LANE_WIDTH, CANVAS_HEIGHT);
        ctx.stroke();
      }
      
      // Draw player
      const playerX = playerLane * LANE_WIDTH + LANE_WIDTH / 2 - PLAYER_SIZE / 2;
      const playerY = CANVAS_HEIGHT - 50;
      ctx.fillStyle = '#00ff00';
      ctx.fillRect(playerX, playerY, PLAYER_SIZE, PLAYER_SIZE);
      
      // Update and draw obstacles
      setObstacles(prev => {
        const updated = prev.map(obstacle => ({
          ...obstacle,
          y: obstacle.y + gameSpeed
        })).filter(obstacle => obstacle.y < CANVAS_HEIGHT + OBSTACLE_SIZE);
        
        // Check collisions
        updated.forEach(obstacle => {
          if (checkCollision(playerX, playerY, obstacle.x, obstacle.y)) {
            setGameState('gameOver');
          }
        });
        
        return updated;
      });
      
      obstacles.forEach(obstacle => {
        ctx.fillStyle = '#ff0000';
        ctx.fillRect(obstacle.x, obstacle.y, OBSTACLE_SIZE, OBSTACLE_SIZE);
      });
      
      // Spawn obstacles
      if (timestamp - lastSpawn > 1000) {
        spawnObstacle();
        lastSpawn = timestamp;
      }
      
      // Update score and speed
      setScore(prev => prev + 1);
      if (score > 0 && score % 500 === 0) {
        setGameSpeed(prev => prev + 0.5);
      }
      
      animationId = requestAnimationFrame(gameLoop);
    };
    
    if (gameState === 'playing') {
      animationId = requestAnimationFrame(gameLoop);
    }
    
    return () => {
      if (animationId) {
        cancelAnimationFrame(animationId);
      }
    };
  }, [gameState, obstacles, playerLane, score, gameSpeed, spawnObstacle, checkCollision]);

  useEffect(() => {
    const handleKeyPress = (e) => {
      if (e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'A') {
        handleSwipe('left');
      } else if (e.key === 'ArrowRight' || e.key === 'd' || e.key === 'D') {
        handleSwipe('right');
      }
    };
    
    window.addEventListener('keydown', handleKeyPress);
    return () => window.removeEventListener('keydown', handleKeyPress);
  }, [handleSwipe]);

  const handleCanvasClick = (e) => {
    const rect = canvasRef.current.getBoundingClientRect();
    const x = e.clientX - rect.left;
    
    if (x < CANVAS_WIDTH / 2) {
      handleSwipe('left');
    } else {
      handleSwipe('right');
    }
  };

  return (
    <div style={{ 
      display: 'flex', 
      flexDirection: 'column', 
      alignItems: 'center', 
      padding: '20px',
      backgroundColor: '#111',
      minHeight: '100vh',
      color: '#fff',
      fontFamily: 'monospace'
    }}>
      <h2 style={{ margin: '0 0 10px 0', color: '#00ff00' }}>TURBO GLIDER</h2>
      
      <div style={{ marginBottom: '10px', fontSize: '14px' }}>
        Score: {score} | Speed: {gameSpeed.toFixed(1)}
      </div>
      
      <canvas
        ref={canvasRef}
        width={CANVAS_WIDTH}
        height={CANVAS_HEIGHT}
        onClick={handleCanvasClick}
        style={{
          border: '2px solid #00ff00',
          backgroundColor: '#000',
          cursor: 'pointer'
        }}
      />
      
      <div style={{ marginTop: '10px', textAlign: 'center' }}>
        <div style={{ marginBottom: '10px', fontSize: '12px' }}>
          Click left/right half or use Arrow Keys/A/D to change lanes
        </div>
        
        <div style={{ display: 'flex', gap: '10px', justifyContent: 'center' }}>
          <button
----------------------------------------


================================================================================
GAME GENERATION: Cosmic Knight: tap to dive and resurface to collect treasures inside a cave. - 2025-08-09 14:35:52.007113
================================================================================
FULL CLAUDE GENERATED CODE:
----------------------------------------
import React, { useState, useEffect, useRef } from 'react';

const GameZone = ({ currentGame }) => {
  const [playerY, setPlayerY] = useState(150);
  const [treasures, setTreasures] = useState([]);
  const [score, setScore] = useState(0);
  const [isGameOver, setIsGameOver] = useState(false);
  const [isDiving, setIsDiving] = useState(false);
  const gameLoopRef = useRef(null);

  const resetGame = () => {
    setPlayerY(150);
    setTreasures([]);
    setScore(0);
    setIsGameOver(false);
    setIsDiving(false);
  };

  useEffect(() => {
    const spawnTreasure = () => {
      if (treasures.length < 3) {
        const newTreasure = {
          x: 400,
          y: Math.random() * 200 + 100,
          id: Date.now()
        };
        setTreasures(prev => [...prev, newTreasure]);
      }
    };

    const gameLoop = () => {
      if (!isGameOver) {
        setTreasures(prev => {
          const newTreasures = prev
            .map(t => ({ ...t, x: t.x - 2 }))
            .filter(t => t.x > -20);

          newTreasures.forEach(treasure => {
            if (Math.abs(treasure.x - 50) < 20 && Math.abs(treasure.y - playerY) < 20) {
              setScore(s => s + 10);
              newTreasures.splice(newTreasures.indexOf(treasure), 1);
            }
          });

          return newTreasures;
        });

        if (playerY < 50 || playerY > 250) {
          setIsGameOver(true);
        }
      }
    };

    const interval = setInterval(() => {
      gameLoop();
      if (Math.random() < 0.02) spawnTreasure();
    }, 16);

    return () => clearInterval(interval);
  }, [playerY, isGameOver]);

  useEffect(() => {
    if (isDiving) {
      setPlayerY(y => y + 2);
    } else {
      setPlayerY(y => y - 2);
    }
  }, [isDiving]);

  const handleMouseDown = () => {
    setIsDiving(true);
  };

  const handleMouseUp = () => {
    setIsDiving(false);
  };

  return (
    <div
      style={{
        width: '400px',
        height: '300px',
        border: '2px solid #333',
        position: 'relative',
        backgroundColor: '#87CEEB',
        overflow: 'hidden',
        userSelect: 'none'
      }}
      onMouseDown={handleMouseDown}
      onMouseUp={handleMouseUp}
      onTouchStart={handleMouseDown}
      onTouchEnd={handleMouseUp}
    >
      <div
        style={{
          position: 'absolute',
          left: '50px',
          top: `${playerY}px`,
          width: '20px',
          height: '20px',
          backgroundColor: '#FF4444',
          borderRadius: '50%'
        }}
      />
      {treasures.map(treasure => (
        <div
          key={treasure.id}
          style={{
            position: 'absolute',
            left: `${treasure.x}px`,
            top: `${treasure.y}px`,
            width: '15px',
            height: '15px',
            backgroundColor: '#FFD700',
            borderRadius: '50%'
          }}
        />
      ))}
      <div
        style={{
          position: 'absolute',
          top: '10px',
          left: '10px',
          color: '#333',
          fontSize: '20px'
        }}
      >
        Score: {score}
      </div>
      {isGameOver && (
        <div
          style={{
            position: 'absolute',
            top: '50%',
            left: '50%',
            transform: 'translate(-50%, -50%)',
            textAlign: 'center'
          }}
        >
          <div style={{ fontSize: '24px', marginBottom: '10px' }}>Game Over!</div>
          <button
            style={{
              padding: '8px 16px',
              fontSize: '16px',
              cursor: 'pointer'
            }}
            onClick={resetGame}
          >
            Restart
          </button>
        </div>
      )}
    </div>
  );
};

export default GameZone;
----------------------------------------


================================================================================
GAME GENERATION: Neon Glider: tap to fish and upgrade your rod between runs inside a cave. - 2025-08-09 14:36:27.199308
================================================================================
FULL CLAUDE GENERATED CODE:
----------------------------------------
import React, { useState, useEffect, useRef } from 'react';

const GameZone = ({ currentGame }) => {
  const [score, setScore] = useState(0);
  const [coins, setCoins] = useState(0);
  const [rodLevel, setRodLevel] = useState(1);
  const [isPlaying, setIsPlaying] = useState(false);
  const [position, setPosition] = useState(150);
  const [fish, setFish] = useState([]);
  
  const gameAreaRef = useRef(null);

  const startGame = () => {
    setIsPlaying(true);
    setPosition(150);
    setFish([]);
    spawnFish();
  };

  const resetGame = () => {
    setScore(0);
    setIsPlaying(false);
    setPosition(150);
    setFish([]);
  };

  const spawnFish = () => {
    if (!isPlaying) return;
    
    const newFish = {
      x: 400,
      y: Math.random() * 250,
      speed: 2 + Math.random() * 2
    };
    
    setFish(prev => [...prev, newFish]);
    setTimeout(spawnFish, 2000);
  };

  const handleClick = () => {
    if (!isPlaying) {
      startGame();
      return;
    }
    setPosition(prev => Math.max(20, Math.min(280, prev - 40)));
  };

  const upgradeRod = () => {
    if (coins >= rodLevel * 10) {
      setCoins(prev => prev - rodLevel * 10);
      setRodLevel(prev => prev + 1);
    }
  };

  useEffect(() => {
    if (!isPlaying) return;

    const gameLoop = setInterval(() => {
      setFish(prevFish => {
        const newFish = prevFish.map(fish => ({
          ...fish,
          x: fish.x - fish.speed
        })).filter(fish => fish.x > -20);

        newFish.forEach(fish => {
          if (Math.abs(fish.y - position) < 30 && fish.x < 100 && fish.x > 80) {
            setScore(prev => prev + rodLevel);
            setCoins(prev => prev + 1);
          }
        });

        return newFish;
      });

      setPosition(prev => Math.min(280, prev + 2));
    }, 16);

    return () => clearInterval(gameLoop);
  }, [isPlaying, position, rodLevel]);

  return (
    <div style={{ 
      width: '400px', 
      height: '400px', 
      backgroundColor: '#000', 
      position: 'relative',
      overflow: 'hidden',
      fontFamily: 'Arial',
      color: '#0ff',
      textAlign: 'center',
      border: '2px solid #0ff',
      borderRadius: '10px'
    }}>
      <div style={{ padding: '10px' }}>
        <div style={{ color: '#0ff' }}>Score: {score} | Coins: {coins}</div>
        <div>Rod Level: {rodLevel}</div>
        <button 
          onClick={upgradeRod}
          style={{
            backgroundColor: '#0ff',
            border: 'none',
            padding: '5px 10px',
            margin: '5px',
            cursor: 'pointer',
            borderRadius: '5px'
          }}
        >
          Upgrade Rod ({rodLevel * 10} coins)
        </button>
        <button 
          onClick={resetGame}
          style={{
            backgroundColor: '#0ff',
            border: 'none',
            padding: '5px 10px',
            margin: '5px',
            cursor: 'pointer',
            borderRadius: '5px'
          }}
        >
          Reset
        </button>
      </div>
      <div 
        ref={gameAreaRef}
        onClick={handleClick}
        style={{
          width: '400px',
          height: '300px',
          position: 'relative',
          backgroundColor: '#001',
          cursor: 'pointer'
        }}
      >
        <div style={{
          position: 'absolute',
          left: '80px',
          top: `${position}px`,
          width: '20px',
          height: '4px',
          backgroundColor: '#0ff',
          boxShadow: '0 0 10px #0ff',
          transition: 'top 0.1s'
        }} />
        {fish.map((fish, index) => (
          <div
            key={index}
            style={{
              position: 'absolute',
              left: `${fish.x}px`,
              top: `${fish.y}px`,
              width: '20px',
              height: '10px',
              backgroundColor: '#f0f',
              borderRadius: '50%',
              boxShadow: '0 0 5px #f0f'
            }}
          />
        ))}
      </div>
    </div>
  );
};

export default GameZone;
----------------------------------------


================================================================================
GAME GENERATION:  - 2025-08-09 14:40:34.317624
================================================================================
FULL CLAUDE GENERATED CODE:
----------------------------------------
import React, { useState, useEffect } from 'react';

const GameZone = ({ currentGame }) => {
  const [score, setScore] = useState(0);
  const [position, setPosition] = useState({ x: 200, y: 150 });
  const [target, setTarget] = useState({ x: 100, y: 100 });
  const [gameOver, setGameOver] = useState(false);

  const generateTarget = () => {
    return {
      x: Math.floor(Math.random() * 350),
      y: Math.floor(Math.random() * 250)
    };
  };

  const handleClick = (e) => {
    if (gameOver) return;
    
    const distance = Math.sqrt(
      Math.pow(position.x - target.x, 2) + 
      Math.pow(position.y - target.y, 2)
    );

    if (distance < 30) {
      setScore(score + 1);
      setTarget(generateTarget());
    } else {
      setGameOver(true);
    }
  };

  const resetGame = () => {
    setScore(0);
    setPosition({ x: 200, y: 150 });
    setTarget(generateTarget());
    setGameOver(false);
  };

  useEffect(() => {
    const handleMouseMove = (e) => {
      const rect = e.currentTarget.getBoundingClientRect();
      setPosition({
        x: e.clientX - rect.left,
        y: e.clientY - rect.top
      });
    };

    const gameArea = document.querySelector('#gameArea');
    if (gameArea) {
      gameArea.addEventListener('mousemove', handleMouseMove);
    }

    return () => {
      if (gameArea) {
        gameArea.removeEventListener('mousemove', handleMouseMove);
      }
    };
  }, []);

  return (
    <div style={{ textAlign: 'center' }}>
      <h2>Catch the Target</h2>
      <p>Score: {score}</p>
      <div
        id="gameArea"
        onClick={handleClick}
        style={{
          position: 'relative',
          width: '400px',
          height: '300px',
          border: '2px solid black',
          margin: '0 auto',
          backgroundColor: '#f0f0f0',
          overflow: 'hidden',
          cursor: 'none'
        }}
      >
        <div
          style={{
            position: 'absolute',
            left: target.x,
            top: target.y,
            width: '20px',
            height: '20px',
            backgroundColor: 'red',
            borderRadius: '50%'
          }}
        />
        <div
          style={{
            position: 'absolute',
            left: position.x - 10,
            top: position.y - 10,
            width: '20px',
            height: '20px',
            backgroundColor: 'blue',
            borderRadius: '50%'
          }}
        />
        {gameOver && (
          <div
            style={{
              position: 'absolute',
              top: '50%',
              left: '50%',
              transform: 'translate(-50%, -50%)',
              backgroundColor: 'rgba(0,0,0,0.7)',
              color: 'white',
              padding: '20px',
              borderRadius: '10px'
            }}
          >
            Game Over!
          </div>
        )}
      </div>
      <button
        onClick={resetGame}
        style={{
          marginTop: '10px',
          padding: '8px 16px',
          fontSize: '16px',
          cursor: 'pointer'
        }}
      >
        Reset Game
      </button>
    </div>
  );
};

export default GameZone;
----------------------------------------


================================================================================
GAME GENERATION:  - 2025-08-09 14:41:02.903384
================================================================================
FULL CLAUDE GENERATED CODE:
----------------------------------------
import React, { useState, useEffect } from 'react';

const GameZone = ({ currentGame }) => {
  const [score, setScore] = useState(0);
  const [position, setPosition] = useState({ x: 200, y: 150 });
  const [target, setTarget] = useState({ x: 100, y: 100 });
  const [gameOver, setGameOver] = useState(false);

  const generateTarget = () => {
    return {
      x: Math.floor(Math.random() * 350),
      y: Math.floor(Math.random() * 250)
    };
  };

  const handleClick = (e) => {
    if (gameOver) return;
    
    const distance = Math.sqrt(
      Math.pow(position.x - target.x, 2) + 
      Math.pow(position.y - target.y, 2)
    );

    if (distance < 30) {
      setScore(score + 1);
      setTarget(generateTarget());
    } else {
      setGameOver(true);
    }
  };

  const resetGame = () => {
    setScore(0);
    setPosition({ x: 200, y: 150 });
    setTarget(generateTarget());
    setGameOver(false);
  };

  useEffect(() => {
    const handleMouseMove = (e) => {
      const rect = e.currentTarget.getBoundingClientRect();
      setPosition({
        x: e.clientX - rect.left,
        y: e.clientY - rect.top
      });
    };

    const gameArea = document.querySelector('#gameArea');
    if (gameArea) {
      gameArea.addEventListener('mousemove', handleMouseMove);
    }

    return () => {
      if (gameArea) {
        gameArea.removeEventListener('mousemove', handleMouseMove);
      }
    };
  }, []);

  return (
    <div style={{ textAlign: 'center' }}>
      <h2>Catch the Target</h2>
      <p>Score: {score}</p>
      <div
        id="gameArea"
        onClick={handleClick}
        style={{
          position: 'relative',
          width: '400px',
          height: '300px',
          border: '2px solid black',
          margin: '0 auto',
          backgroundColor: '#f0f0f0',
          overflow: 'hidden',
          cursor: 'none'
        }}
      >
        <div
          style={{
            position: 'absolute',
            left: target.x,
            top: target.y,
            width: '20px',
            height: '20px',
            backgroundColor: 'red',
            borderRadius: '50%'
          }}
        />
        <div
          style={{
            position: 'absolute',
            left: position.x - 10,
            top: position.y - 10,
            width: '20px',
            height: '20px',
            backgroundColor: 'blue',
            borderRadius: '50%'
          }}
        />
        {gameOver && (
          <div
            style={{
              position: 'absolute',
              top: '50%',
              left: '50%',
              transform: 'translate(-50%, -50%)',
              backgroundColor: 'rgba(0,0,0,0.7)',
              color: 'white',
              padding: '20px',
              borderRadius: '10px'
            }}
          >
            Game Over!
          </div>
        )}
      </div>
      <button
        onClick={resetGame}
        style={{
          marginTop: '10px',
          padding: '8px 16px',
          fontSize: '16px',
          cursor: 'pointer'
        }}
      >
        Reset Game
      </button>
    </div>
  );
};

export default GameZone;
----------------------------------------


================================================================================
GAME GENERATION:  - 2025-08-09 14:42:23.789766
================================================================================
FULL CLAUDE GENERATED CODE:
----------------------------------------
import React, { useState, useEffect } from 'react';

const GameZone = ({ currentGame }) => {
  const [score, setScore] = useState(0);
  const [position, setPosition] = useState({ x: 200, y: 150 });
  const [target, setTarget] = useState({ x: 100, y: 100 });
  const [gameOver, setGameOver] = useState(false);

  const generateTarget = () => {
    return {
      x: Math.floor(Math.random() * 350),
      y: Math.floor(Math.random() * 250)
    };
  };

  const handleClick = (e) => {
    if (gameOver) return;
    
    const distance = Math.sqrt(
      Math.pow(position.x - target.x, 2) + 
      Math.pow(position.y - target.y, 2)
    );

    if (distance < 30) {
      setScore(score + 1);
      setTarget(generateTarget());
    } else {
      setGameOver(true);
    }
  };

  const resetGame = () => {
    setScore(0);
    setPosition({ x: 200, y: 150 });
    setTarget(generateTarget());
    setGameOver(false);
  };

  useEffect(() => {
    const handleMouseMove = (e) => {
      const rect = e.currentTarget.getBoundingClientRect();
      setPosition({
        x: e.clientX - rect.left,
        y: e.clientY - rect.top
      });
    };

    const gameArea = document.querySelector('#gameArea');
    if (gameArea) {
      gameArea.addEventListener('mousemove', handleMouseMove);
    }

    return () => {
      if (gameArea) {
        gameArea.removeEventListener('mousemove', handleMouseMove);
      }
    };
  }, []);

  return (
    <div style={{ textAlign: 'center' }}>
      <h2>Target Chase</h2>
      <p>Score: {score}</p>
      <div
        id="gameArea"
        onClick={handleClick}
        style={{
          position: 'relative',
          width: '400px',
          height: '300px',
          border: '2px solid black',
          margin: '0 auto',
          backgroundColor: '#f0f0f0',
          overflow: 'hidden',
          cursor: 'none'
        }}
      >
        <div
          style={{
            position: 'absolute',
            left: target.x,
            top: target.y,
            width: '20px',
            height: '20px',
            backgroundColor: 'red',
            borderRadius: '50%'
          }}
        />
        <div
          style={{
            position: 'absolute',
            left: position.x - 10,
            top: position.y - 10,
            width: '20px',
            height: '20px',
            backgroundColor: 'blue',
            borderRadius: '50%'
          }}
        />
        {gameOver && (
          <div
            style={{
              position: 'absolute',
              top: '50%',
              left: '50%',
              transform: 'translate(-50%, -50%)',
              backgroundColor: 'rgba(0,0,0,0.7)',
              color: 'white',
              padding: '20px',
              borderRadius: '10px'
            }}
          >
            <h3>Game Over!</h3>
            <p>Final Score: {score}</p>
          </div>
        )}
      </div>
      <button
        onClick={resetGame}
        style={{
          marginTop: '10px',
          padding: '8px 16px',
          fontSize: '16px',
          cursor: 'pointer'
        }}
      >
        Reset Game
      </button>
    </div>
  );
};

export default GameZone;
----------------------------------------


================================================================================
GAME GENERATION: shooting game - 2025-08-09 14:42:35.314500
================================================================================
FULL CLAUDE GENERATED CODE:
----------------------------------------
import React, { useState, useEffect, useRef } from 'react';

const GameZone = ({ currentGame }) => {
  const [score, setScore] = useState(0);
  const [gameOver, setGameOver] = useState(false);
  const [targets, setTargets] = useState([]);
  const [mousePos, setMousePos] = useState({ x: 0, y: 0 });

  const gameAreaRef = useRef(null);

  useEffect(() => {
    const spawnTarget = () => {
      if (!gameOver && targets.length < 5) {
        const newTarget = {
          id: Date.now(),
          x: Math.random() * 360,
          y: 0,
          speed: 1 + Math.random() * 2
        };
        setTargets(prev => [...prev, newTarget]);
      }
    };

    const gameLoop = setInterval(() => {
      setTargets(prev => {
        const updated = prev.map(target => ({
          ...target,
          y: target.y + target.speed
        }));
        
        if (updated.some(target => target.y > 280)) {
          setGameOver(true);
          return prev;
        }
        return updated.filter(target => target.y <= 280);
      });
    }, 50);

    const targetSpawner = setInterval(spawnTarget, 1000);

    return () => {
      clearInterval(gameLoop);
      clearInterval(targetSpawner);
    };
  }, [gameOver, targets]);

  const handleMouseMove = (e) => {
    if (gameAreaRef.current) {
      const rect = gameAreaRef.current.getBoundingClientRect();
      setMousePos({
        x: e.clientX - rect.left,
        y: e.clientY - rect.top
      });
    }
  };

  const handleClick = () => {
    if (gameOver) return;
    
    setTargets(prev => {
      const hit = prev.find(target => 
        Math.abs(target.x - mousePos.x) < 20 &&
        Math.abs(target.y - mousePos.y) < 20
      );
      
      if (hit) {
        setScore(s => s + 1);
        return prev.filter(t => t.id !== hit.id);
      }
      return prev;
    });
  };

  const resetGame = () => {
    setScore(0);
    setGameOver(false);
    setTargets([]);
  };

  return (
    <div style={{ textAlign: 'center' }}>
      <div
        ref={gameAreaRef}
        style={{
          width: 400,
          height: 300,
          border: '2px solid black',
          position: 'relative',
          cursor: 'crosshair',
          backgroundColor: '#f0f0f0',
          overflow: 'hidden'
        }}
        onMouseMove={handleMouseMove}
        onClick={handleClick}
      >
        {targets.map(target => (
          <div
            key={target.id}
            style={{
              position: 'absolute',
              left: target.x,
              top: target.y,
              width: 20,
              height: 20,
              borderRadius: '50%',
              backgroundColor: 'red'
            }}
          />
        ))}
        <div
          style={{
            position: 'absolute',
            left: mousePos.x - 10,
            top: mousePos.y - 10,
            width: 20,
            height: 20,
            border: '1px solid black',
            borderRadius: '50%',
            pointerEvents: 'none'
          }}
        />
        {gameOver && (
          <div
            style={{
              position: 'absolute',
              top: '50%',
              left: '50%',
              transform: 'translate(-50%, -50%)',
              backgroundColor: 'rgba(0,0,0,0.7)',
              color: 'white',
              padding: '20px',
              borderRadius: '10px'
            }}
          >
            Game Over!
          </div>
        )}
      </div>
      <div style={{ marginTop: 10 }}>
        <p>Score: {score}</p>
        <button onClick={resetGame}>
          {gameOver ? 'Play Again' : 'Reset Game'}
        </button>
      </div>
    </div>
  );
};

export default GameZone;
----------------------------------------


================================================================================
GAME GENERATION: flappy bird game - 2025-08-09 14:45:38.996417
================================================================================
FULL CLAUDE GENERATED CODE:
----------------------------------------
import React, { useState, useEffect, useRef } from 'react';

const GameZone = ({ currentGame }) => {
  const [birdPosition, setBirdPosition] = useState(150);
  const [gameStarted, setGameStarted] = useState(false);
  const [score, setScore] = useState(0);
  const [gameOver, setGameOver] = useState(false);
  const [pipes, setPipes] = useState([]);
  const gravity = 2;
  const jumpForce = -50;
  const gameLoopRef = useRef();
  const pipeGeneratorRef = useRef();

  const resetGame = () => {
    setBirdPosition(150);
    setGameStarted(false);
    setScore(0);
    setGameOver(false);
    setPipes([]);
    clearInterval(gameLoopRef.current);
    clearInterval(pipeGeneratorRef.current);
  };

  const startGame = () => {
    if (!gameStarted && !gameOver) {
      setGameStarted(true);
      gameLoopRef.current = setInterval(() => {
        setBirdPosition(prev => prev + gravity);
      }, 20);

      pipeGeneratorRef.current = setInterval(() => {
        setPipes(prev => [...prev, {
          x: 400,
          gapStart: Math.random() * 150 + 50
        }]);
      }, 2000);
    }
  };

  const jump = () => {
    if (gameStarted && !gameOver) {
      setBirdPosition(prev => prev + jumpForce);
    }
  };

  useEffect(() => {
    if (gameStarted && !gameOver) {
      const gameLoop = setInterval(() => {
        setPipes(prev => prev
          .map(pipe => ({ ...pipe, x: pipe.x - 2 }))
          .filter(pipe => pipe.x > -50)
        );

        setPipes(prev => {
          prev.forEach(pipe => {
            if (pipe.x < 50 && pipe.x > 0) {
              if (birdPosition < pipe.gapStart || birdPosition > pipe.gapStart + 100) {
                setGameOver(true);
                clearInterval(gameLoopRef.current);
                clearInterval(pipeGeneratorRef.current);
              } else if (pipe.x < 2) {
                setScore(s => s + 1);
              }
            }
          });
          return prev;
        });

        if (birdPosition > 300 || birdPosition < 0) {
          setGameOver(true);
          clearInterval(gameLoopRef.current);
          clearInterval(pipeGeneratorRef.current);
        }
      }, 20);

      return () => clearInterval(gameLoop);
    }
  }, [gameStarted, gameOver, birdPosition]);

  return (
    <div style={{ 
      width: '400px', 
      height: '300px', 
      border: '2px solid black',
      position: 'relative',
      overflow: 'hidden',
      backgroundColor: '#87CEEB'
    }} onClick={gameStarted ? jump : startGame}>
      <div style={{
        width: '30px',
        height: '30px',
        backgroundColor: 'yellow',
        borderRadius: '50%',
        position: 'absolute',
        left: '50px',
        top: `${birdPosition}px`,
        transition: 'top 0.1s'
      }} />
      
      {pipes.map((pipe, index) => (
        <React.Fragment key={index}>
          <div style={{
            position: 'absolute',
            width: '50px',
            height: `${pipe.gapStart}px`,
            backgroundColor: 'green',
            left: `${pipe.x}px`,
            top: 0
          }} />
          <div style={{
            position: 'absolute',
            width: '50px',
            height: `${300 - pipe.gapStart - 100}px`,
            backgroundColor: 'green',
            left: `${pipe.x}px`,
            bottom: 0
          }} />
        </React.Fragment>
      ))}

      {!gameStarted && !gameOver && (
        <div style={{
          position: 'absolute',
          top: '50%',
          left: '50%',
          transform: 'translate(-50%, -50%)',
          textAlign: 'center'
        }}>
          Click to Start
        </div>
      )}

      {gameOver && (
        <div style={{
          position: 'absolute',
          top: '50%',
          left: '50%',
          transform: 'translate(-50%, -50%)',
          textAlign: 'center'
        }}>
          Game Over!<br />
          Score: {score}<br />
          <button onClick={resetGame}>Restart</button>
        </div>
      )}

      <div style={{
        position: 'absolute',
        top: '10px',
        right: '10px',
        fontSize: '20px'
      }}>
        Score: {score}
      </div>
    </div>
  );
};

export default GameZone;
----------------------------------------


================================================================================
GAME GENERATION: flappy bird game - 2025-08-09 14:53:35.946094
================================================================================
FULL CLAUDE GENERATED CODE:
----------------------------------------
import React, { useState, useEffect, useCallback } from 'react';

const GameZone = ({ currentGame }) => {
  const [bird, setBird] = useState({ x: 50, y: 150, velocity: 0 });
  const [pipes, setPipes] = useState([]);
  const [score, setScore] = useState(0);
  const [gameStarted, setGameStarted] = useState(false);
  const [gameOver, setGameOver] = useState(false);

  const GRAVITY = 0.5;
  const JUMP_STRENGTH = -8;
  const PIPE_WIDTH = 50;
  const PIPE_GAP = 120;
  const GAME_WIDTH = 400;
  const GAME_HEIGHT = 300;

  const jump = useCallback(() => {
    if (!gameStarted) {
      setGameStarted(true);
    }
    if (!gameOver) {
      setBird(prev => ({ ...prev, velocity: JUMP_STRENGTH }));
    }
  }, [gameStarted, gameOver]);

  const resetGame = () => {
    setBird({ x: 50, y: 150, velocity: 0 });
    setPipes([]);
    setScore(0);
    setGameStarted(false);
    setGameOver(false);
  };

  useEffect(() => {
    const handleKeyPress = (e) => {
      if (e.code === 'Space') {
        e.preventDefault();
        jump();
      }
    };

    window.addEventListener('keydown', handleKeyPress);
    return () => window.removeEventListener('keydown', handleKeyPress);
  }, [jump]);

  useEffect(() => {
    if (!gameStarted || gameOver) return;

    const gameLoop = setInterval(() => {
      setBird(prev => {
        const newY = prev.y + prev.velocity;
        const newVelocity = prev.velocity + GRAVITY;
        
        if (newY <= 0 || newY >= GAME_HEIGHT - 20) {
          setGameOver(true);
          return prev;
        }
        
        return { ...prev, y: newY, velocity: newVelocity };
      });

      setPipes(prev => {
        let newPipes = prev.map(pipe => ({ ...pipe, x: pipe.x - 2 }));
        
        newPipes = newPipes.filter(pipe => pipe.x > -PIPE_WIDTH);
        
        if (newPipes.length === 0 || newPipes[newPipes.length - 1].x < GAME_WIDTH - 200) {
          const gapY = Math.random() * (GAME_HEIGHT - PIPE_GAP - 40) + 20;
          newPipes.push({
            x: GAME_WIDTH,
            topHeight: gapY,
            bottomY: gapY + PIPE_GAP,
            passed: false
          });
        }
        
        return newPipes;
      });
    }, 16);

    return () => clearInterval(gameLoop);
  }, [gameStarted, gameOver]);

  useEffect(() => {
    if (!gameStarted || gameOver) return;

    pipes.forEach(pipe => {
      if (
        bird.x + 20 > pipe.x &&
        bird.x < pipe.x + PIPE_WIDTH &&
        (bird.y < pipe.topHeight || bird.y + 20 > pipe.bottomY)
      ) {
        setGameOver(true);
      }
      
      if (!pipe.passed && bird.x > pipe.x + PIPE_WIDTH) {
        pipe.passed = true;
        setScore(prev => prev + 1);
      }
    });
  }, [bird, pipes, gameStarted, gameOver]);

  return (
    <div style={{ 
      display: 'flex', 
      flexDirection: 'column', 
      alignItems: 'center', 
      padding: '20px',
      fontFamily: 'Arial, sans-serif'
    }}>
      <h2 style={{ margin: '0 0 10px 0', color: '#333' }}>Flappy Bird</h2>
      
      <div style={{ marginBottom: '10px', fontSize: '18px', fontWeight: 'bold' }}>
        Score: {score}
      </div>
      
      <div 
        onClick={jump}
        style={{
          position: 'relative',
          width: GAME_WIDTH,
          height: GAME_HEIGHT,
          backgroundColor: '#87CEEB',
          border: '2px solid #333',
          cursor: 'pointer',
          overflow: 'hidden'
        }}
      >
        <div
          style={{
            position: 'absolute',
            left: bird.x,
            top: bird.y,
            width: 20,
            height: 20,
            backgroundColor: '#FFD700',
            borderRadius: '50%',
            border: '2px solid #FFA500'
          }}
        />
        
        {pipes.map((pipe, index) => (
          <div key={index}>
            <div
              style={{
                position: 'absolute',
                left: pipe.x,
                top: 0,
                width: PIPE_WIDTH,
                height: pipe.topHeight,
                backgroundColor: '#228B22',
                border: '2px solid #006400'
              }}
            />
            <div
              style={{
                position: 'absolute',
                left: pipe.x,
                top: pipe.bottomY,
                width: PIPE_WIDTH,
                height: GAME_HEIGHT - pipe.bottomY,
                backgroundColor: '#228B22',
                border: '2px solid #006400'
              }}
            />
          </div>
        ))}
        
        {!gameStarted && !gameOver && (
          <div style={{
            position: 'absolute',
            top: '50%',
            left: '50%',
            transform: 'translate(-50%, -50%)',
            textAlign: 'center',
            color: '#333',
            fontSize: '16px',
            backgroundColor: 'rgba(255, 255, 255, 0.9)',
            padding: '10px',
            borderRadius: '5px'
          }}>
            Click or press SPACE to start!
          </div>
        )}
        
        {gameOver && (
          <div style={{
            position: 'absolute',
            top: '50%',
            left: '50%',
            transform: 'translate(-50%, -50%)',
            textAlign: 'center',
            color: '#333',
            fontSize: '16px',
            backgroundColor: 'rgba(255, 255, 255, 0.9)',
            padding: '15px',
            borderRadius: '5px'
          }}>
            <div style={{ marginBottom: '10px', fontSize: '18px', fontWeight: 'bold' }}>
              Game Over!
            </div>
            <div style={{ marginBottom: '10px' }}>
              Final Score: {score}
            </div>
          </div>
        )}
      </div>
      
      <div style={{ marginTop: '10px' }}>
        <button 
          onClick={resetGame}
          style={{
            padding: '10px 20px',
            fontSize: '16px',
            backgroundColor: '#4CAF50',
            color: 'white',
            border: 'none',
            borderRadius: '5px',
            cursor: 'pointer'
          }}
        >
          Reset Game
        </button>
      </div>
      
      <div style={{ 
        marginTop: '10px', 
        fontSize: '12px', 
        color: '#666',
        textAlign: 'center'
      }}>
        Click the game area or press SPACE to jump
      </div>
    </div>
  );
};

export default GameZone;
----------------------------------------


================================================================================
GAME GENERATION: racing car game - 2025-08-09 14:54:16.400366
================================================================================
FULL CLAUDE GENERATED CODE:
----------------------------------------
import React, { useState, useEffect, useCallback } from 'react';

const GameZone = ({ currentGame }) => {
  const [carPosition, setCarPosition] = useState(200);
  const [obstacles, setObstacles] = useState([]);
  const [score, setScore] = useState(0);
  const [gameRunning, setGameRunning] = useState(false);
  const [gameOver, setGameOver] = useState(false);

  const gameWidth = 400;
  const gameHeight = 300;
  const carWidth = 30;
  const carHeight = 20;
  const obstacleWidth = 25;
  const obstacleHeight = 25;

  const resetGame = useCallback(() => {
    setCarPosition(200);
    setObstacles([]);
    setScore(0);
    setGameRunning(false);
    setGameOver(false);
  }, []);

  const startGame = useCallback(() => {
    setGameRunning(true);
    setGameOver(false);
  }, []);

  const handleKeyPress = useCallback((e) => {
    if (!gameRunning || gameOver) return;
    
    if (e.key === 'ArrowLeft' && carPosition > 0) {
      setCarPosition(prev => Math.max(0, prev - 20));
    } else if (e.key === 'ArrowRight' && carPosition < gameWidth - carWidth) {
      setCarPosition(prev => Math.min(gameWidth - carWidth, prev + 20));
    }
  }, [gameRunning, gameOver, carPosition, gameWidth, carWidth]);

  useEffect(() => {
    window.addEventListener('keydown', handleKeyPress);
    return () => window.removeEventListener('keydown', handleKeyPress);
  }, [handleKeyPress]);

  useEffect(() => {
    if (!gameRunning || gameOver) return;

    const gameInterval = setInterval(() => {
      setObstacles(prev => {
        const newObstacles = prev.map(obstacle => ({
          ...obstacle,
          y: obstacle.y + 3
        })).filter(obstacle => obstacle.y < gameHeight);

        if (Math.random() < 0.3) {
          newObstacles.push({
            x: Math.random() * (gameWidth - obstacleWidth),
            y: -obstacleHeight,
            id: Date.now()
          });
        }

        const carRect = {
          x: carPosition,
          y: gameHeight - carHeight - 10,
          width: carWidth,
          height: carHeight
        };

        const collision = newObstacles.some(obstacle => {
          return carRect.x < obstacle.x + obstacleWidth &&
                 carRect.x + carRect.width > obstacle.x &&
                 carRect.y < obstacle.y + obstacleHeight &&
                 carRect.y + carRect.height > obstacle.y;
        });

        if (collision) {
          setGameOver(true);
          setGameRunning(false);
        }

        return newObstacles;
      });

      setScore(prev => prev + 1);
    }, 100);

    return () => clearInterval(gameInterval);
  }, [gameRunning, gameOver, carPosition, gameWidth, gameHeight, carWidth, carHeight, obstacleWidth, obstacleHeight]);

  return (
    <div style={{ 
      display: 'flex', 
      flexDirection: 'column', 
      alignItems: 'center', 
      padding: '20px',
      fontFamily: 'Arial, sans-serif'
    }}>
      <h2 style={{ margin: '0 0 10px 0', color: '#333' }}>Racing Car Game</h2>
      
      <div style={{ marginBottom: '10px' }}>
        <span style={{ marginRight: '20px', fontWeight: 'bold' }}>Score: {score}</span>
        {!gameRunning && !gameOver && (
          <button 
            onClick={startGame}
            style={{
              padding: '8px 16px',
              backgroundColor: '#4CAF50',
              color: 'white',
              border: 'none',
              borderRadius: '4px',
              cursor: 'pointer',
              marginRight: '10px'
            }}
          >
            Start Game
          </button>
        )}
        <button 
          onClick={resetGame}
          style={{
            padding: '8px 16px',
            backgroundColor: '#f44336',
            color: 'white',
            border: 'none',
            borderRadius: '4px',
            cursor: 'pointer'
          }}
        >
          Reset
        </button>
      </div>

      <div 
        style={{
          width: gameWidth,
          height: gameHeight,
          backgroundColor: '#333',
          position: 'relative',
          border: '2px solid #666',
          overflow: 'hidden'
        }}
      >
        <div
          style={{
            position: 'absolute',
            left: carPosition,
            bottom: 10,
            width: carWidth,
            height: carHeight,
            backgroundColor: '#ff4444',
            borderRadius: '3px'
          }}
        />

        {obstacles.map(obstacle => (
          <div
            key={obstacle.id}
            style={{
              position: 'absolute',
              left: obstacle.x,
              top: obstacle.y,
              width: obstacleWidth,
              height: obstacleHeight,
              backgroundColor: '#ffff44',
              borderRadius: '2px'
            }}
          />
        ))}

        {gameOver && (
          <div style={{
            position: 'absolute',
            top: '50%',
            left: '50%',
            transform: 'translate(-50%, -50%)',
            backgroundColor: 'rgba(0,0,0,0.8)',
            color: 'white',
            padding: '20px',
            borderRadius: '8px',
            textAlign: 'center'
          }}>
            <h3 style={{ margin: '0 0 10px 0' }}>Game Over!</h3>
            <p style={{ margin: '0 0 10px 0' }}>Final Score: {score}</p>
          </div>
        )}
      </div>

      <div style={{ marginTop: '10px', textAlign: 'center', fontSize: '14px', color: '#666' }}>
        Use ‚Üê ‚Üí arrow keys to move your car (red) and avoid obstacles (yellow)
      </div>
    </div>
  );
};

export default GameZone;
----------------------------------------


================================================================================
GAME GENERATION: porn app - 2025-08-09 14:54:57.508621
================================================================================
FULL CLAUDE GENERATED CODE:
----------------------------------------
I can't create adult content or pornographic games. Instead, I can help you create other types of games like:

- A simple puzzle game
- A memory matching game
- A word guessing game
- A number guessing game
- A simple arcade-style game
- A trivia game

Would you like me to create one of these alternatives instead? I'd be happy to make a fun, engaging game that meets all your technical requirements.
----------------------------------------


================================================================================
GAME GENERATION: flappy bird game - 2025-08-09 14:58:14.271583
================================================================================
FULL CLAUDE GENERATED CODE:
----------------------------------------
import React, { useState, useEffect, useCallback } from 'react';

const GameZone = ({ currentGame }) => {
  const [birdY, setBirdY] = useState(150);
  const [birdVelocity, setBirdVelocity] = useState(0);
  const [pipes, setPipes] = useState([]);
  const [score, setScore] = useState(0);
  const [gameRunning, setGameRunning] = useState(false);
  const [gameOver, setGameOver] = useState(false);

  const GRAVITY = 0.5;
  const JUMP_STRENGTH = -8;
  const PIPE_WIDTH = 60;
  const PIPE_GAP = 120;
  const BIRD_SIZE = 20;

  const jump = useCallback(() => {
    if (gameRunning && !gameOver) {
      setBirdVelocity(JUMP_STRENGTH);
    }
  }, [gameRunning, gameOver]);

  const startGame = () => {
    setBirdY(150);
    setBirdVelocity(0);
    setPipes([]);
    setScore(0);
    setGameRunning(true);
    setGameOver(false);
  };

  const resetGame = () => {
    setGameRunning(false);
    setGameOver(false);
    setBirdY(150);
    setBirdVelocity(0);
    setPipes([]);
    setScore(0);
  };

  useEffect(() => {
    const handleKeyPress = (e) => {
      if (e.code === 'Space') {
        e.preventDefault();
        jump();
      }
    };

    window.addEventListener('keydown', handleKeyPress);
    return () => window.removeEventListener('keydown', handleKeyPress);
  }, [jump]);

  useEffect(() => {
    if (!gameRunning || gameOver) return;

    const gameLoop = setInterval(() => {
      setBirdY(prev => {
        const newY = prev + birdVelocity;
        if (newY <= 0 || newY >= 280) {
          setGameOver(true);
          setGameRunning(false);
        }
        return newY;
      });

      setBirdVelocity(prev => prev + GRAVITY);

      setPipes(prev => {
        let newPipes = prev.map(pipe => ({
          ...pipe,
          x: pipe.x - 2
        })).filter(pipe => pipe.x > -PIPE_WIDTH);

        if (newPipes.length === 0 || newPipes[newPipes.length - 1].x < 200) {
          const gapY = Math.random() * (200 - PIPE_GAP) + 50;
          newPipes.push({
            x: 400,
            gapY: gapY,
            passed: false
          });
        }

        newPipes.forEach(pipe => {
          if (!pipe.passed && pipe.x + PIPE_WIDTH < 50) {
            pipe.passed = true;
            setScore(s => s + 1);
          }

          const birdLeft = 50;
          const birdRight = 50 + BIRD_SIZE;
          const birdTop = birdY;
          const birdBottom = birdY + BIRD_SIZE;

          if (birdRight > pipe.x && birdLeft < pipe.x + PIPE_WIDTH) {
            if (birdTop < pipe.gapY || birdBottom > pipe.gapY + PIPE_GAP) {
              setGameOver(true);
              setGameRunning(false);
            }
          }
        });

        return newPipes;
      });
    }, 16);

    return () => clearInterval(gameLoop);
  }, [gameRunning, gameOver, birdY, birdVelocity]);

  return (
    <div style={{ 
      display: 'flex', 
      flexDirection: 'column', 
      alignItems: 'center', 
      padding: '20px',
      fontFamily: 'Arial, sans-serif'
    }}>
      <h2>Flappy Bird</h2>
      <div style={{ marginBottom: '10px' }}>
        Score: {score}
      </div>
      
      <div 
        style={{
          position: 'relative',
          width: '400px',
          height: '300px',
          backgroundColor: '#87CEEB',
          border: '2px solid #333',
          overflow: 'hidden',
          cursor: 'pointer'
        }}
        onClick={jump}
      >
        <div
          style={{
            position: 'absolute',
            left: '50px',
            top: `${birdY}px`,
            width: `${BIRD_SIZE}px`,
            height: `${BIRD_SIZE}px`,
            backgroundColor: '#FFD700',
            borderRadius: '50%',
            border: '2px solid #FFA500',
            transition: gameRunning ? 'none' : 'top 0.1s'
          }}
        />

        {pipes.map((pipe, index) => (
          <div key={index}>
            <div
              style={{
                position: 'absolute',
                left: `${pipe.x}px`,
                top: '0px',
                width: `${PIPE_WIDTH}px`,
                height: `${pipe.gapY}px`,
                backgroundColor: '#228B22',
                border: '2px solid #006400'
              }}
            />
            <div
              style={{
                position: 'absolute',
                left: `${pipe.x}px`,
                top: `${pipe.gapY + PIPE_GAP}px`,
                width: `${PIPE_WIDTH}px`,
                height: `${300 - (pipe.gapY + PIPE_GAP)}px`,
                backgroundColor: '#228B22',
                border: '2px solid #006400'
              }}
            />
          </div>
        ))}

        {!gameRunning && !gameOver && (
          <div style={{
            position: 'absolute',
            top: '50%',
            left: '50%',
            transform: 'translate(-50%, -50%)',
            textAlign: 'center',
            backgroundColor: 'rgba(255, 255, 255, 0.9)',
            padding: '20px',
            borderRadius: '10px'
          }}>
            <div style={{ marginBottom: '10px', fontSize: '18px', fontWeight: 'bold' }}>
              Flappy Bird
            </div>
            <div style={{ marginBottom: '15px', fontSize: '14px' }}>
              Click or press Space to flap!
            </div>
            <button 
              onClick={startGame}
              style={{
                padding: '10px 20px',
                fontSize: '16px',
                backgroundColor: '#4CAF50',
                color: 'white',
                border: 'none',
                borderRadius: '5px',
                cursor: 'pointer'
              }}
            >
              Start Game
            </button>
          </div>
        )}

        {gameOver && (
          <div style={{
            position: 'absolute',
            top: '50%',
            left: '50%',
            transform: 'translate(-50%, -50%)',
            textAlign: 'center',
            backgroundColor: 'rgba(255, 255, 255, 0.9)',
            padding: '20px',
            borderRadius: '10px'
          }}>
            <div style={{ marginBottom: '10px', fontSize: '18px', fontWeight: 'bold', color: '#FF0000' }}>
              Game Over!
            </div>
            <div style={{ marginBottom: '10px', fontSize: '16px' }}>
              Final Score: {score}
            </div>
            <button 
              onClick={resetGame}
              style={{
                padding: '10px 20px',
                fontSize: '16px',
                backgroundColor: '#2196F3',
                color: 'white',
                border: 'none',
                borderRadius: '5px',
                cursor: 'pointer'
              }}
            >
              Play Again
            </button>
          </div>
        )}
      </div>

      <div style={{ marginTop: '10px', fontSize: '12px', color: '#666' }}>
        Click the game area or press Space to jump
      </div>
    </div>
  );
};

export default GameZone;
----------------------------------------


================================================================================
GAME GENERATION: cookinggame - 2025-08-09 14:58:55.969185
================================================================================
FULL CLAUDE GENERATED CODE:
----------------------------------------
import React, { useState, useEffect, useRef } from 'react';

const GameZone = ({ currentGame }) => {
  const [score, setScore] = useState(0);
  const [timeLeft, setTimeLeft] = useState(60);
  const [gameActive, setGameActive] = useState(false);
  const [orders, setOrders] = useState([]);
  const [inventory, setInventory] = useState({
    bread: 0,
    meat: 0,
    cheese: 0,
    lettuce: 0
  });
  const [message, setMessage] = useState('Click Start to begin cooking!');

  const ingredients = ['bread', 'meat', 'cheese', 'lettuce'];
  const recipes = [
    { name: 'Sandwich', ingredients: ['bread', 'meat', 'cheese'], points: 10 },
    { name: 'Burger', ingredients: ['bread', 'meat', 'lettuce'], points: 15 },
    { name: 'Club', ingredients: ['bread', 'meat', 'cheese', 'lettuce'], points: 20 }
  ];

  useEffect(() => {
    let timer;
    if (gameActive && timeLeft > 0) {
      timer = setTimeout(() => {
        setTimeLeft(timeLeft - 1);
      }, 1000);
    } else if (timeLeft === 0) {
      setGameActive(false);
      setMessage(`Game Over! Final Score: ${score}`);
    }
    return () => clearTimeout(timer);
  }, [gameActive, timeLeft, score]);

  useEffect(() => {
    let orderTimer;
    if (gameActive && orders.length < 3) {
      orderTimer = setTimeout(() => {
        const randomRecipe = recipes[Math.floor(Math.random() * recipes.length)];
        setOrders(prev => [...prev, { ...randomRecipe, id: Date.now() }]);
      }, Math.random() * 5000 + 2000);
    }
    return () => clearTimeout(orderTimer);
  }, [gameActive, orders]);

  const startGame = () => {
    setScore(0);
    setTimeLeft(60);
    setGameActive(true);
    setOrders([]);
    setInventory({ bread: 0, meat: 0, cheese: 0, lettuce: 0 });
    setMessage('Cook and serve orders to earn points!');
  };

  const addIngredient = (ingredient) => {
    if (gameActive) {
      setInventory(prev => ({
        ...prev,
        [ingredient]: prev[ingredient] + 1
      }));
    }
  };

  const serveOrder = (order) => {
    const hasAllIngredients = order.ingredients.every(ing => inventory[ing] > 0);
    
    if (hasAllIngredients) {
      const newInventory = { ...inventory };
      order.ingredients.forEach(ing => {
        newInventory[ing] -= 1;
      });
      setInventory(newInventory);
      setScore(prev => prev + order.points);
      setOrders(prev => prev.filter(o => o.id !== order.id));
      setMessage(`Served ${order.name}! +${order.points} points`);
    } else {
      setMessage('Missing ingredients for this order!');
    }
  };

  return (
    <div style={{
      width: '400px',
      height: '300px',
      border: '2px solid #8B4513',
      borderRadius: '10px',
      padding: '10px',
      backgroundColor: '#FFF8DC',
      fontFamily: 'Arial, sans-serif',
      position: 'relative'
    }}>
      <div style={{
        display: 'flex',
        justifyContent: 'space-between',
        marginBottom: '10px',
        fontSize: '14px',
        fontWeight: 'bold'
      }}>
        <span>Score: {score}</span>
        <span>Time: {timeLeft}s</span>
      </div>

      <div style={{
        height: '20px',
        fontSize: '12px',
        color: '#333',
        marginBottom: '10px'
      }}>
        {message}
      </div>

      {!gameActive ? (
        <div style={{
          textAlign: 'center',
          marginTop: '50px'
        }}>
          <button
            onClick={startGame}
            style={{
              padding: '10px 20px',
              fontSize: '16px',
              backgroundColor: '#FF6B35',
              color: 'white',
              border: 'none',
              borderRadius: '5px',
              cursor: 'pointer'
            }}
          >
            Start Cooking
          </button>
        </div>
      ) : (
        <div>
          <div style={{
            marginBottom: '10px'
          }}>
            <div style={{ fontSize: '12px', fontWeight: 'bold', marginBottom: '5px' }}>
              Ingredients:
            </div>
            <div style={{ display: 'flex', gap: '5px', flexWrap: 'wrap' }}>
              {ingredients.map(ing => (
                <button
                  key={ing}
                  onClick={() => addIngredient(ing)}
                  style={{
                    padding: '5px 8px',
                    fontSize: '10px',
                    backgroundColor: '#90EE90',
                    border: '1px solid #228B22',
                    borderRadius: '3px',
                    cursor: 'pointer'
                  }}
                >
                  +{ing} ({inventory[ing]})
                </button>
              ))}
            </div>
          </div>

          <div style={{
            marginBottom: '10px'
          }}>
            <div style={{ fontSize: '12px', fontWeight: 'bold', marginBottom: '5px' }}>
              Orders:
            </div>
            <div style={{ 
              height: '80px', 
              overflowY: 'auto',
              border: '1px solid #ccc',
              padding: '5px',
              backgroundColor: 'white'
            }}>
              {orders.map(order => (
                <div
                  key={order.id}
                  style={{
                    display: 'flex',
                    justifyContent: 'space-between',
                    alignItems: 'center',
                    padding: '3px',
                    marginBottom: '3px',
                    backgroundColor: '#FFE4B5',
                    borderRadius: '3px',
                    fontSize: '10px'
                  }}
                >
                  <span>
                    {order.name}: {order.ingredients.join(', ')} ({order.points}pts)
                  </span>
                  <button
                    onClick={() => serveOrder(order)}
                    style={{
                      padding: '2px 6px',
                      fontSize: '9px',
                      backgroundColor: '#FF6B35',
                      color: 'white',
                      border: 'none',
                      borderRadius: '2px',
                      cursor: 'pointer'
                    }}
                  >
                    Serve
                  </button>
                </div>
              ))}
            </div>
          </div>

          <button
            onClick={() => {
              setGameActive(false);
              setMessage('Game stopped. Click Start to play again.');
            }}
            style={{
              padding: '5px 10px',
              fontSize: '12px',
              backgroundColor: '#DC143C',
              color: 'white',
              border: 'none',
              borderRadius: '3px',
              cursor: 'pointer'
            }}
          >
            Stop Game
          </button>
        </div>
      )}
    </div>
  );
};

export default GameZone;
----------------------------------------


================================================================================
GAME GENERATION: racing car game - 2025-08-09 14:59:45.325825
================================================================================
FULL CLAUDE GENERATED CODE:
----------------------------------------
import React, { useState, useEffect, useCallback } from 'react';

const GameZone = ({ currentGame }) => {
  const [carPosition, setCarPosition] = useState(200);
  const [obstacles, setObstacles] = useState([]);
  const [score, setScore] = useState(0);
  const [gameRunning, setGameRunning] = useState(false);
  const [gameOver, setGameOver] = useState(false);

  const gameWidth = 400;
  const gameHeight = 300;
  const carWidth = 30;
  const carHeight = 20;
  const obstacleWidth = 25;
  const obstacleHeight = 25;

  const resetGame = useCallback(() => {
    setCarPosition(200);
    setObstacles([]);
    setScore(0);
    setGameRunning(false);
    setGameOver(false);
  }, []);

  const startGame = useCallback(() => {
    setGameRunning(true);
    setGameOver(false);
  }, []);

  useEffect(() => {
    if (!gameRunning || gameOver) return;

    const gameLoop = setInterval(() => {
      setObstacles(prev => {
        const newObstacles = prev.map(obs => ({
          ...obs,
          y: obs.y + 3
        })).filter(obs => obs.y < gameHeight);

        if (Math.random() < 0.02) {
          newObstacles.push({
            x: Math.random() * (gameWidth - obstacleWidth),
            y: -obstacleHeight,
            id: Date.now()
          });
        }

        return newObstacles;
      });

      setScore(prev => prev + 1);
    }, 50);

    return () => clearInterval(gameLoop);
  }, [gameRunning, gameOver, gameWidth, gameHeight, obstacleWidth, obstacleHeight]);

  useEffect(() => {
    if (!gameRunning || gameOver) return;

    const checkCollisions = () => {
      obstacles.forEach(obstacle => {
        const carLeft = carPosition;
        const carRight = carPosition + carWidth;
        const carTop = gameHeight - 50;
        const carBottom = gameHeight - 30;

        const obsLeft = obstacle.x;
        const obsRight = obstacle.x + obstacleWidth;
        const obsTop = obstacle.y;
        const obsBottom = obstacle.y + obstacleHeight;

        if (carLeft < obsRight && carRight > obsLeft && carTop < obsBottom && carBottom > obsTop) {
          setGameOver(true);
          setGameRunning(false);
        }
      });
    };

    checkCollisions();
  }, [obstacles, carPosition, gameRunning, gameOver, carWidth, gameHeight, obstacleWidth, obstacleHeight]);

  useEffect(() => {
    if (!gameRunning) return;

    const handleKeyPress = (e) => {
      if (e.key === 'ArrowLeft' && carPosition > 0) {
        setCarPosition(prev => Math.max(0, prev - 15));
      } else if (e.key === 'ArrowRight' && carPosition < gameWidth - carWidth) {
        setCarPosition(prev => Math.min(gameWidth - carWidth, prev + 15));
      }
    };

    window.addEventListener('keydown', handleKeyPress);
    return () => window.removeEventListener('keydown', handleKeyPress);
  }, [gameRunning, carPosition, gameWidth, carWidth]);

  return (
    <div style={{ 
      display: 'flex', 
      flexDirection: 'column', 
      alignItems: 'center', 
      padding: '20px',
      fontFamily: 'Arial, sans-serif'
    }}>
      <h2 style={{ margin: '0 0 10px 0', color: '#333' }}>Racing Car Game</h2>
      
      <div style={{ marginBottom: '10px', fontSize: '18px', fontWeight: 'bold' }}>
        Score: {score}
      </div>

      <div style={{
        position: 'relative',
        width: `${gameWidth}px`,
        height: `${gameHeight}px`,
        backgroundColor: '#333',
        border: '2px solid #000',
        overflow: 'hidden'
      }}>
        <div style={{
          position: 'absolute',
          left: '50%',
          top: '0',
          width: '4px',
          height: '100%',
          backgroundColor: '#fff',
          transform: 'translateX(-50%)'
        }} />

        <div style={{
          position: 'absolute',
          left: `${carPosition}px`,
          bottom: '30px',
          width: `${carWidth}px`,
          height: `${carHeight}px`,
          backgroundColor: '#ff4444',
          borderRadius: '3px'
        }} />

        {obstacles.map(obstacle => (
          <div
            key={obstacle.id}
            style={{
              position: 'absolute',
              left: `${obstacle.x}px`,
              top: `${obstacle.y}px`,
              width: `${obstacleWidth}px`,
              height: `${obstacleHeight}px`,
              backgroundColor: '#ffaa00',
              borderRadius: '2px'
            }}
          />
        ))}

        {gameOver && (
          <div style={{
            position: 'absolute',
            top: '50%',
            left: '50%',
            transform: 'translate(-50%, -50%)',
            backgroundColor: 'rgba(0,0,0,0.8)',
            color: 'white',
            padding: '20px',
            borderRadius: '10px',
            textAlign: 'center'
          }}>
            <div style={{ fontSize: '24px', marginBottom: '10px' }}>Game Over!</div>
            <div style={{ fontSize: '16px' }}>Final Score: {score}</div>
          </div>
        )}
      </div>

      <div style={{ marginTop: '15px', display: 'flex', gap: '10px' }}>
        {!gameRunning && !gameOver && (
          <button
            onClick={startGame}
            style={{
              padding: '10px 20px',
              fontSize: '16px',
              backgroundColor: '#4CAF50',
              color: 'white',
              border: 'none',
              borderRadius: '5px',
              cursor: 'pointer'
            }}
          >
            Start Game
          </button>
        )}
        
        <button
          onClick={resetGame}
          style={{
            padding: '10px 20px',
            fontSize: '16px',
            backgroundColor: '#f44336',
            color: 'white',
            border: 'none',
            borderRadius: '5px',
            cursor: 'pointer'
          }}
        >
          Reset
        </button>
      </div>

      {gameRunning && (
        <div style={{ marginTop: '10px', fontSize: '14px', color: '#666' }}>
          Use ‚Üê ‚Üí arrow keys to move
        </div>
      )}
    </div>
  );
};

export default GameZone;
----------------------------------------


================================================================================
GAME GENERATION: flappy bird game - 2025-08-09 15:16:10.579504
================================================================================
FULL CLAUDE GENERATED CODE:
----------------------------------------
import React, { useState, useEffect, useCallback } from 'react';

const GameZone = ({ currentGame }) => {
  const [bird, setBird] = useState({ y: 150, velocity: 0 });
  const [pipes, setPipes] = useState([]);
  const [score, setScore] = useState(0);
  const [gameStarted, setGameStarted] = useState(false);
  const [gameOver, setGameOver] = useState(false);

  const GRAVITY = 0.5;
  const JUMP_FORCE = -8;
  const PIPE_WIDTH = 50;
  const PIPE_GAP = 120;
  const GAME_WIDTH = 400;
  const GAME_HEIGHT = 300;

  const jump = useCallback(() => {
    if (!gameStarted) {
      setGameStarted(true);
    }
    if (!gameOver) {
      setBird(prev => ({ ...prev, velocity: JUMP_FORCE }));
    }
  }, [gameStarted, gameOver]);

  const resetGame = () => {
    setBird({ y: 150, velocity: 0 });
    setPipes([]);
    setScore(0);
    setGameStarted(false);
    setGameOver(false);
  };

  useEffect(() => {
    const handleKeyPress = (e) => {
      if (e.code === 'Space') {
        e.preventDefault();
        jump();
      }
    };

    window.addEventListener('keydown', handleKeyPress);
    return () => window.removeEventListener('keydown', handleKeyPress);
  }, [jump]);

  useEffect(() => {
    if (!gameStarted || gameOver) return;

    const gameLoop = setInterval(() => {
      setBird(prev => {
        const newY = prev.y + prev.velocity;
        const newVelocity = prev.velocity + GRAVITY;
        
        if (newY < 0 || newY > GAME_HEIGHT - 20) {
          setGameOver(true);
          return prev;
        }
        
        return { y: newY, velocity: newVelocity };
      });

      setPipes(prev => {
        let newPipes = prev.map(pipe => ({ ...pipe, x: pipe.x - 2 }))
          .filter(pipe => pipe.x > -PIPE_WIDTH);

        if (newPipes.length === 0 || newPipes[newPipes.length - 1].x < GAME_WIDTH - 200) {
          const gapY = Math.random() * (GAME_HEIGHT - PIPE_GAP - 40) + 20;
          newPipes.push({
            x: GAME_WIDTH,
            topHeight: gapY,
            bottomY: gapY + PIPE_GAP,
            scored: false
          });
        }

        return newPipes;
      });
    }, 16);

    return () => clearInterval(gameLoop);
  }, [gameStarted, gameOver]);

  useEffect(() => {
    if (!gameStarted || gameOver) return;

    pipes.forEach(pipe => {
      if (!pipe.scored && pipe.x + PIPE_WIDTH < 50) {
        pipe.scored = true;
        setScore(prev => prev + 1);
      }

      const birdLeft = 50;
      const birdRight = 70;
      const birdTop = bird.y;
      const birdBottom = bird.y + 20;

      if (birdRight > pipe.x && birdLeft < pipe.x + PIPE_WIDTH) {
        if (birdTop < pipe.topHeight || birdBottom > pipe.bottomY) {
          setGameOver(true);
        }
      }
    });
  }, [bird, pipes, gameStarted, gameOver]);

  return (
    <div style={{ 
      display: 'flex', 
      flexDirection: 'column', 
      alignItems: 'center', 
      padding: '20px',
      fontFamily: 'Arial, sans-serif'
    }}>
      <h2 style={{ margin: '0 0 10px 0' }}>Flappy Bird</h2>
      <div style={{ marginBottom: '10px' }}>Score: {score}</div>
      
      <div 
        onClick={jump}
        style={{
          position: 'relative',
          width: GAME_WIDTH,
          height: GAME_HEIGHT,
          backgroundColor: '#87CEEB',
          border: '2px solid #333',
          cursor: 'pointer',
          overflow: 'hidden'
        }}
      >
        <div
          style={{
            position: 'absolute',
            left: '50px',
            top: `${bird.y}px`,
            width: '20px',
            height: '20px',
            backgroundColor: '#FFD700',
            borderRadius: '50%',
            border: '2px solid #FFA500'
          }}
        />

        {pipes.map((pipe, index) => (
          <div key={index}>
            <div
              style={{
                position: 'absolute',
                left: `${pipe.x}px`,
                top: '0px',
                width: `${PIPE_WIDTH}px`,
                height: `${pipe.topHeight}px`,
                backgroundColor: '#228B22',
                border: '2px solid #006400'
              }}
            />
            <div
              style={{
                position: 'absolute',
                left: `${pipe.x}px`,
                top: `${pipe.bottomY}px`,
                width: `${PIPE_WIDTH}px`,
                height: `${GAME_HEIGHT - pipe.bottomY}px`,
                backgroundColor: '#228B22',
                border: '2px solid #006400'
              }}
            />
          </div>
        ))}

        {!gameStarted && (
          <div style={{
            position: 'absolute',
            top: '50%',
            left: '50%',
            transform: 'translate(-50%, -50%)',
            textAlign: 'center',
            color: '#333',
            fontSize: '18px',
            fontWeight: 'bold'
          }}>
            Click or Press Space to Start
          </div>
        )}

        {gameOver && (
          <div style={{
            position: 'absolute',
            top: '50%',
            left: '50%',
            transform: 'translate(-50%, -50%)',
            textAlign: 'center',
            backgroundColor: 'rgba(255, 255, 255, 0.9)',
            padding: '20px',
            borderRadius: '10px',
            border: '2px solid #333'
          }}>
            <div style={{ fontSize: '24px', fontWeight: 'bold', marginBottom: '10px' }}>
              Game Over!
            </div>
            <div style={{ marginBottom: '15px' }}>Final Score: {score}</div>
            <button 
              onClick={resetGame}
              style={{
                padding: '10px 20px',
                fontSize: '16px',
                backgroundColor: '#4CAF50',
                color: 'white',
                border: 'none',
                borderRadius: '5px',
                cursor: 'pointer'
              }}
            >
              Play Again
            </button>
          </div>
        )}
      </div>

      <div style={{ marginTop: '10px', textAlign: 'center', fontSize: '14px', color: '#666' }}>
        Click the game area or press Space to jump
      </div>
    </div>
  );
};

export default GameZone;
----------------------------------------


================================================================================
GAME GENERATION: puzzle platformer game - 2025-08-09 15:16:50.138028
================================================================================
FULL CLAUDE GENERATED CODE:
----------------------------------------
import React, { useState, useEffect, useCallback } from 'react';

const GameZone = ({ currentGame }) => {
  const [player, setPlayer] = useState({ x: 50, y: 200, width: 20, height: 20 });
  const [platforms] = useState([
    { x: 0, y: 250, width: 150, height: 20 },
    { x: 200, y: 200, width: 100, height: 20 },
    { x: 350, y: 150, width: 50, height: 20 },
    { x: 150, y: 100, width: 100, height: 20 },
    { x: 300, y: 50, width: 100, height: 20 }
  ]);
  const [goal] = useState({ x: 350, y: 20, width: 30, height: 30 });
  const [velocity, setVelocity] = useState({ x: 0, y: 0 });
  const [keys, setKeys] = useState({});
  const [gameWon, setGameWon] = useState(false);
  const [gameOver, setGameOver] = useState(false);

  const GRAVITY = 0.5;
  const JUMP_FORCE = -12;
  const MOVE_SPEED = 5;
  const GAME_WIDTH = 400;
  const GAME_HEIGHT = 300;

  const checkCollision = (rect1, rect2) => {
    return rect1.x < rect2.x + rect2.width &&
           rect1.x + rect1.width > rect2.x &&
           rect1.y < rect2.y + rect2.height &&
           rect1.y + rect1.height > rect2.y;
  };

  const resetGame = () => {
    setPlayer({ x: 50, y: 200, width: 20, height: 20 });
    setVelocity({ x: 0, y: 0 });
    setGameWon(false);
    setGameOver(false);
  };

  const gameLoop = useCallback(() => {
    if (gameWon || gameOver) return;

    setPlayer(prevPlayer => {
      setVelocity(prevVelocity => {
        let newVelocity = { ...prevVelocity };
        let newPlayer = { ...prevPlayer };

        // Handle input
        if (keys['ArrowLeft'] || keys['a']) {
          newVelocity.x = -MOVE_SPEED;
        } else if (keys['ArrowRight'] || keys['d']) {
          newVelocity.x = MOVE_SPEED;
        } else {
          newVelocity.x = 0;
        }

        if ((keys['ArrowUp'] || keys[' ']) && Math.abs(newVelocity.y) < 1) {
          // Check if on platform
          const futurePlayer = { ...newPlayer, y: newPlayer.y + 1 };
          const onPlatform = platforms.some(platform => checkCollision(futurePlayer, platform));
          if (onPlatform) {
            newVelocity.y = JUMP_FORCE;
          }
        }

        // Apply gravity
        newVelocity.y += GRAVITY;

        // Update position
        newPlayer.x += newVelocity.x;
        newPlayer.y += newVelocity.y;

        // Platform collision
        platforms.forEach(platform => {
          if (checkCollision(newPlayer, platform)) {
            // Landing on top
            if (prevPlayer.y + prevPlayer.height <= platform.y && newVelocity.y > 0) {
              newPlayer.y = platform.y - newPlayer.height;
              newVelocity.y = 0;
            }
            // Hitting from below
            else if (prevPlayer.y >= platform.y + platform.height && newVelocity.y < 0) {
              newPlayer.y = platform.y + platform.height;
              newVelocity.y = 0;
            }
            // Side collision
            else {
              if (prevPlayer.x + prevPlayer.width <= platform.x) {
                newPlayer.x = platform.x - newPlayer.width;
              } else if (prevPlayer.x >= platform.x + platform.width) {
                newPlayer.x = platform.x + platform.width;
              }
              newVelocity.x = 0;
            }
          }
        });

        // Boundary collision
        if (newPlayer.x < 0) {
          newPlayer.x = 0;
          newVelocity.x = 0;
        }
        if (newPlayer.x + newPlayer.width > GAME_WIDTH) {
          newPlayer.x = GAME_WIDTH - newPlayer.width;
          newVelocity.x = 0;
        }

        // Check if fell off screen
        if (newPlayer.y > GAME_HEIGHT) {
          setGameOver(true);
        }

        // Check goal collision
        if (checkCollision(newPlayer, goal)) {
          setGameWon(true);
        }

        setVelocity(newVelocity);
        return newPlayer;
      });
      return prevPlayer;
    });
  }, [keys, gameWon, gameOver, platforms, goal]);

  useEffect(() => {
    const handleKeyDown = (e) => {
      setKeys(prev => ({ ...prev, [e.key]: true }));
    };

    const handleKeyUp = (e) => {
      setKeys(prev => ({ ...prev, [e.key]: false }));
    };

    window.addEventListener('keydown', handleKeyDown);
    window.addEventListener('keyup', handleKeyUp);

    return () => {
      window.removeEventListener('keydown', handleKeyDown);
      window.removeEventListener('keyup', handleKeyUp);
    };
  }, []);

  useEffect(() => {
    const interval = setInterval(gameLoop, 16);
    return () => clearInterval(interval);
  }, [gameLoop]);

  return (
    <div style={{ textAlign: 'center', padding: '20px' }}>
      <h2>Puzzle Platformer</h2>
      <div style={{ 
        position: 'relative', 
        width: GAME_WIDTH, 
        height: GAME_HEIGHT, 
        border: '2px solid #333', 
        margin: '0 auto',
        backgroundColor: '#87CEEB',
        overflow: 'hidden'
      }}>
        {/* Player */}
        <div style={{
          position: 'absolute',
          left: player.x,
          top: player.y,
          width: player.width,
          height: player.height,
          backgroundColor: '#FF6B6B',
          border: '1px solid #000'
        }} />

        {/* Platforms */}
        {platforms.map((platform, index) => (
          <div key={index} style={{
            position: 'absolute',
            left: platform.x,
            top: platform.y,
            width: platform.width,
            height: platform.height,
            backgroundColor: '#8B4513',
            border: '1px solid #000'
          }} />
        ))}

        {/* Goal */}
        <div style={{
          position: 'absolute',
          left: goal.x,
          top: goal.y,
          width: goal.width,
          height: goal.height,
          backgroundColor: '#FFD700',
          border: '2px solid #FFA500',
          borderRadius: '50%'
        }} />

        {/* Game Over Overlay */}
        {(gameWon || gameOver) && (
          <div style={{
            position: 'absolute',
            top: 0,
            left: 0,
            width: '100%',
            height: '100%',
            backgroundColor: 'rgba(0, 0, 0, 0.8)',
            display: 'flex',
            flexDirection: 'column',
            justifyContent: 'center',
            alignItems: 'center',
            color: 'white',
            fontSize: '24px'
          }}>
            <div>{gameWon ? 'You Win!' : 'Game Over!'}</div>
            <button 
              onClick={resetGame}
              style={{
                marginTop: '20px',
                padding: '10px 20px',
                fontSize: '16px',
                backgroundColor: '#4CAF50',
                color: 'white',
                border: 'none',
                borderRadius: '5px',
                cursor: 'pointer'
              }}
            >
              Play Again
            </button>
          </div>
        )}
      </div>
      
      <div style={{ marginTop: '10px', fontSize: '14px' }}>
        <p>Use Arrow Keys or WASD to move and jump</p>
        <p>Reach the golden circle to win!</p>
        <button 
          onClick={resetGame}
          style={{
            padding: '8px 16px',
            fontSize: '14px',
            backgroundColor: '#2196F3',
            color: 'white',
            border: 'none',
            borderRadius: '3px',
            cursor: 'pointer',
            marginTop: '5px'
          }}
        >
          Restart Game
        </button>
      </div>
    </div>
  );
};

export default GameZone;
----------------------------------------


================================================================================
GAME GENERATION: tower defense game - 2025-08-09 15:17:45.613763
================================================================================
FULL CLAUDE GENERATED CODE:
----------------------------------------
import React, { useState, useEffect, useRef } from 'react';

const GameZone = ({ currentGame }) => {
  const canvasRef = useRef(null);
  const [gameState, setGameState] = useState('playing');
  const [score, setScore] = useState(0);
  const [lives, setLives] = useState(10);
  const [money, setMoney] = useState(100);
  const [towers, setTowers] = useState([]);
  const [enemies, setEnemies] = useState([]);
  const [projectiles, setProjectiles] = useState([]);
  const [selectedTower, setSelectedTower] = useState(null);
  const [wave, setWave] = useState(1);
  const [enemiesSpawned, setEnemiesSpawned] = useState(0);
  const [waveInProgress, setWaveInProgress] = useState(false);

  const CANVAS_WIDTH = 400;
  const CANVAS_HEIGHT = 300;
  const TOWER_COST = 50;
  const TOWER_RANGE = 60;
  const TOWER_DAMAGE = 25;

  const path = [
    { x: 0, y: 150 },
    { x: 100, y: 150 },
    { x: 100, y: 100 },
    { x: 200, y: 100 },
    { x: 200, y: 200 },
    { x: 300, y: 200 },
    { x: 300, y: 150 },
    { x: 400, y: 150 }
  ];

  const resetGame = () => {
    setGameState('playing');
    setScore(0);
    setLives(10);
    setMoney(100);
    setTowers([]);
    setEnemies([]);
    setProjectiles([]);
    setSelectedTower(null);
    setWave(1);
    setEnemiesSpawned(0);
    setWaveInProgress(false);
  };

  const spawnEnemy = () => {
    const newEnemy = {
      id: Date.now() + Math.random(),
      x: path[0].x,
      y: path[0].y,
      health: 50 + wave * 10,
      maxHealth: 50 + wave * 10,
      speed: 1 + wave * 0.1,
      pathIndex: 0,
      reward: 10 + wave * 2
    };
    setEnemies(prev => [...prev, newEnemy]);
  };

  const startWave = () => {
    setWaveInProgress(true);
    setEnemiesSpawned(0);
  };

  const distance = (a, b) => {
    return Math.sqrt((a.x - b.x) ** 2 + (a.y - b.y) ** 2);
  };

  const handleCanvasClick = (e) => {
    if (gameState !== 'playing') return;
    
    const rect = canvasRef.current.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;

    if (money >= TOWER_COST) {
      const canPlace = towers.every(tower => distance(tower, { x, y }) > 30);
      const onPath = path.some(point => distance(point, { x, y }) < 25);
      
      if (canPlace && !onPath) {
        const newTower = {
          id: Date.now(),
          x,
          y,
          range: TOWER_RANGE,
          damage: TOWER_DAMAGE,
          lastShot: 0
        };
        setTowers(prev => [...prev, newTower]);
        setMoney(prev => prev - TOWER_COST);
      }
    }
  };

  useEffect(() => {
    const gameLoop = setInterval(() => {
      if (gameState !== 'playing') return;

      // Spawn enemies
      if (waveInProgress && enemiesSpawned < wave * 5) {
        if (Date.now() % 1000 < 50) {
          spawnEnemy();
          setEnemiesSpawned(prev => prev + 1);
        }
      }

      // Move enemies
      setEnemies(prev => prev.map(enemy => {
        if (enemy.pathIndex >= path.length - 1) {
          setLives(lives => lives - 1);
          return null;
        }

        const target = path[enemy.pathIndex + 1];
        const dx = target.x - enemy.x;
        const dy = target.y - enemy.y;
        const dist = Math.sqrt(dx * dx + dy * dy);

        if (dist < 5) {
          return { ...enemy, pathIndex: enemy.pathIndex + 1 };
        }

        return {
          ...enemy,
          x: enemy.x + (dx / dist) * enemy.speed,
          y: enemy.y + (dy / dist) * enemy.speed
        };
      }).filter(Boolean));

      // Tower shooting
      const now = Date.now();
      setProjectiles(prev => [...prev]);
      
      towers.forEach(tower => {
        if (now - tower.lastShot > 500) {
          const target = enemies.find(enemy => 
            distance(tower, enemy) <= tower.range
          );
          
          if (target) {
            tower.lastShot = now;
            setProjectiles(prev => [...prev, {
              id: Date.now() + Math.random(),
              x: tower.x,
              y: tower.y,
              targetX: target.x,
              targetY: target.y,
              damage: tower.damage,
              speed: 5
            }]);
          }
        }
      });

      // Move projectiles
      setProjectiles(prev => prev.map(proj => {
        const dx = proj.targetX - proj.x;
        const dy = proj.targetY - proj.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        
        if (dist < 5) {
          setEnemies(enemies => enemies.map(enemy => {
            if (distance(enemy, proj) < 15) {
              const newHealth = enemy.health - proj.damage;
              if (newHealth <= 0) {
                setScore(score => score + 10);
                setMoney(money => money + enemy.reward);
                return null;
              }
              return { ...enemy, health: newHealth };
            }
            return enemy;
          }).filter(Boolean));
          return null;
        }

        return {
          ...proj,
          x: proj.x + (dx / dist) * proj.speed,
          y: proj.y + (dy / dist) * proj.speed
        };
      }).filter(Boolean));

      // Check wave completion
      if (waveInProgress && enemiesSpawned >= wave * 5 && enemies.length === 0) {
        setWaveInProgress(false);
        setWave(prev => prev + 1);
        setMoney(prev => prev + 50);
      }

      // Check game over
      if (lives <= 0) {
        setGameState('gameOver');
      }
    }, 50);

    return () => clearInterval(gameLoop);
  }, [gameState, enemies, towers, projectiles, lives, wave, waveInProgress, enemiesSpawned, money]);

  useEffect(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;
    
    const ctx = canvas.getContext('2d');
    ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

    // Draw path
    ctx.strokeStyle = '#8B4513';
    ctx.lineWidth = 20;
    ctx.beginPath();
    ctx.moveTo(path[0].x, path[0].y);
    path.forEach(point => ctx.lineTo(point.x, point.y));
    ctx.stroke();

    // Draw towers
    towers.forEach(tower => {
      ctx.fillStyle = '#4169E1';
      ctx.fillRect(tower.x - 10, tower.y - 10, 20, 20);
      
      ctx.strokeStyle = '#87CEEB';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.arc(tower.x, tower.y, tower.range, 0, Math.PI * 2);
      ctx.stroke();
    });

    // Draw enemies
    enemies.forEach(enemy => {
      ctx.fillStyle = '#FF4500';
      ctx.fillRect(enemy.x - 8, enemy.y - 8, 16, 16);
      
      // Health bar
      ctx.fillStyle = '#FF0000';
      ctx.fillRect(enemy.x - 10, enemy.y - 15, 20, 3);
      ctx.fillStyle = '#00FF00';
      ctx.fillRect(enemy.x - 10, enemy.y - 15, 20 * (enemy.health / enemy.maxHealth), 3);
    });

    // Draw projectiles
    projectiles.forEach(proj => {
      ctx.fillStyle = '#FFD700';
      ctx.beginPath();
      ctx.arc(proj.x, proj.y, 3, 0, Math.PI * 2);
      ctx.fill();
    });
  });

  return (
    <div style={{ padding: '20px', fontFamily: 'Arial, sans-serif' }}>
      <div style={{ marginBottom: '10px', display: 'flex', gap: '20px', alignItems: 'center' }}>
        <div>Score: {score}</div>
        <div>Lives: {lives}</div>
        <div>Money: ${money}</div>
        <div>Wave: {wave}</div>
        <button 
          onClick={startWave} 
          disabled={waveInProgress}
          style={{ padding: '5px 10px', backgroundColor: waveInProgress ? '#ccc' : '#4CAF50', color: 'white', border: 'none', borderRadius: '3px' }}
        >
          {waveInProgress ? 'Wave in Progress' : 'Start Wave'}
        </button>
        <button 
          onClick={resetGame}
          style={{ padding: '5px 10px', backgroundColor: '#f44336', color: 'white', border: 'none', borderRadius: '3px' }}
        >
          Reset
        </button>
      </div>
      
      <canvas
        ref={canvasRef}
        width={CANVAS_WIDTH}
        height={CANVAS_HEIGHT}
        onClick={handleCanvasClick}
        style={{ 
          border: '2px solid #333', 
          backgroundColor: '#90EE90',
          cursor: money >= TOWER_COST ? 'crosshair' : 'default'
        }}
      />
      
      <div style={{ marginTop: '10px' }}>
        <div>Tower Cost: ${TOWER_COST}</div>
        <div>Click on empty ground to place towers</div>
        {gameState === 'gameOver' && (
          <div style={{ color: 'red', fontSize: '18px', fontWeight: 'bold' }}>
            Game Over! Final Score: {score}
          </div>
        )}
      </div>
    </div>
  );
};

export default GameZone;
----------------------------------------


================================================================================
GAME GENERATION: flappy bird game - 2025-08-09 15:23:48.334695
================================================================================
FULL CLAUDE GENERATED CODE:
----------------------------------------
import React, { useState, useEffect, useCallback } from 'react';

const GameZone = ({ currentGame }) => {
  const [bird, setBird] = useState({ x: 50, y: 150, velocity: 0 });
  const [pipes, setPipes] = useState([]);
  const [score, setScore] = useState(0);
  const [gameStarted, setGameStarted] = useState(false);
  const [gameOver, setGameOver] = useState(false);

  const GRAVITY = 0.5;
  const JUMP_FORCE = -8;
  const PIPE_WIDTH = 50;
  const PIPE_GAP = 120;
  const GAME_WIDTH = 400;
  const GAME_HEIGHT = 300;

  const jump = useCallback(() => {
    if (!gameStarted) {
      setGameStarted(true);
    }
    if (!gameOver) {
      setBird(prev => ({ ...prev, velocity: JUMP_FORCE }));
    }
  }, [gameStarted, gameOver]);

  const resetGame = () => {
    setBird({ x: 50, y: 150, velocity: 0 });
    setPipes([]);
    setScore(0);
    setGameStarted(false);
    setGameOver(false);
  };

  useEffect(() => {
    const handleKeyPress = (e) => {
      if (e.code === 'Space') {
        e.preventDefault();
        jump();
      }
    };

    window.addEventListener('keydown', handleKeyPress);
    return () => window.removeEventListener('keydown', handleKeyPress);
  }, [jump]);

  useEffect(() => {
    if (!gameStarted || gameOver) return;

    const gameLoop = setInterval(() => {
      setBird(prev => {
        const newY = prev.y + prev.velocity;
        const newVelocity = prev.velocity + GRAVITY;
        
        if (newY <= 0 || newY >= GAME_HEIGHT - 20) {
          setGameOver(true);
          return prev;
        }
        
        return { ...prev, y: newY, velocity: newVelocity };
      });

      setPipes(prev => {
        let newPipes = prev.map(pipe => ({ ...pipe, x: pipe.x - 2 }));
        
        newPipes = newPipes.filter(pipe => pipe.x > -PIPE_WIDTH);
        
        if (newPipes.length === 0 || newPipes[newPipes.length - 1].x < GAME_WIDTH - 200) {
          const gapY = Math.random() * (GAME_HEIGHT - PIPE_GAP - 100) + 50;
          newPipes.push({
            x: GAME_WIDTH,
            topHeight: gapY,
            bottomY: gapY + PIPE_GAP,
            passed: false
          });
        }
        
        return newPipes;
      });
    }, 16);

    return () => clearInterval(gameLoop);
  }, [gameStarted, gameOver]);

  useEffect(() => {
    if (!gameStarted || gameOver) return;

    pipes.forEach(pipe => {
      if (!pipe.passed && bird.x > pipe.x + PIPE_WIDTH) {
        pipe.passed = true;
        setScore(prev => prev + 1);
      }

      const birdLeft = bird.x;
      const birdRight = bird.x + 20;
      const birdTop = bird.y;
      const birdBottom = bird.y + 20;
      
      const pipeLeft = pipe.x;
      const pipeRight = pipe.x + PIPE_WIDTH;
      
      if (birdRight > pipeLeft && birdLeft < pipeRight) {
        if (birdTop < pipe.topHeight || birdBottom > pipe.bottomY) {
          setGameOver(true);
        }
      }
    });
  }, [bird, pipes, gameStarted, gameOver]);

  return (
    <div style={{ 
      display: 'flex', 
      flexDirection: 'column', 
      alignItems: 'center', 
      padding: '20px',
      fontFamily: 'Arial, sans-serif'
    }}>
      <h2>Flappy Bird</h2>
      <div style={{ marginBottom: '10px' }}>
        Score: {score}
      </div>
      
      <div 
        onClick={jump}
        style={{
          position: 'relative',
          width: GAME_WIDTH,
          height: GAME_HEIGHT,
          backgroundColor: '#87CEEB',
          border: '2px solid #333',
          cursor: 'pointer',
          overflow: 'hidden'
        }}
      >
        <div
          style={{
            position: 'absolute',
            left: bird.x,
            top: bird.y,
            width: 20,
            height: 20,
            backgroundColor: '#FFD700',
            borderRadius: '50%',
            border: '2px solid #FFA500'
          }}
        />
        
        {pipes.map((pipe, index) => (
          <div key={index}>
            <div
              style={{
                position: 'absolute',
                left: pipe.x,
                top: 0,
                width: PIPE_WIDTH,
                height: pipe.topHeight,
                backgroundColor: '#228B22',
                border: '2px solid #006400'
              }}
            />
            <div
              style={{
                position: 'absolute',
                left: pipe.x,
                top: pipe.bottomY,
                width: PIPE_WIDTH,
                height: GAME_HEIGHT - pipe.bottomY,
                backgroundColor: '#228B22',
                border: '2px solid #006400'
              }}
            />
          </div>
        ))}
        
        {!gameStarted && (
          <div style={{
            position: 'absolute',
            top: '50%',
            left: '50%',
            transform: 'translate(-50%, -50%)',
            textAlign: 'center',
            color: '#333',
            fontSize: '18px',
            fontWeight: 'bold'
          }}>
            Click or Press Space to Start
          </div>
        )}
        
        {gameOver && (
          <div style={{
            position: 'absolute',
            top: '50%',
            left: '50%',
            transform: 'translate(-50%, -50%)',
            textAlign: 'center',
            color: '#FF0000',
            fontSize: '24px',
            fontWeight: 'bold',
            backgroundColor: 'rgba(255, 255, 255, 0.9)',
            padding: '20px',
            borderRadius: '10px'
          }}>
            Game Over!<br />
            Score: {score}
          </div>
        )}
      </div>
      
      <div style={{ marginTop: '10px' }}>
        <button 
          onClick={resetGame}
          style={{
            padding: '10px 20px',
            fontSize: '16px',
            backgroundColor: '#4CAF50',
            color: 'white',
            border: 'none',
            borderRadius: '5px',
            cursor: 'pointer'
          }}
        >
          Reset Game
        </button>
      </div>
      
      <div style={{ marginTop: '10px', textAlign: 'center', fontSize: '14px', color: '#666' }}>
        Click the game area or press Space to jump
      </div>
    </div>
  );
};

export default GameZone;
----------------------------------------


================================================================================
GAME GENERATION: tower defense game - 2025-08-09 15:24:29.339099
================================================================================
FULL CLAUDE GENERATED CODE:
----------------------------------------
import React, { useState, useEffect, useRef } from 'react';

const GameZone = ({ currentGame }) => {
  const canvasRef = useRef(null);
  const animationRef = useRef(null);
  const gameStateRef = useRef({
    towers: [],
    enemies: [],
    projectiles: [],
    money: 100,
    lives: 10,
    wave: 1,
    enemySpawnTimer: 0,
    enemiesInWave: 5,
    enemiesSpawned: 0,
    gameOver: false,
    paused: false
  });

  const [gameState, setGameState] = useState(gameStateRef.current);
  const [selectedTowerType, setSelectedTowerType] = useState('basic');

  const CANVAS_WIDTH = 400;
  const CANVAS_HEIGHT = 300;
  const TOWER_COST = 50;
  const ENEMY_PATH = [
    { x: 0, y: 150 },
    { x: 100, y: 150 },
    { x: 100, y: 100 },
    { x: 200, y: 100 },
    { x: 200, y: 200 },
    { x: 300, y: 200 },
    { x: 300, y: 150 },
    { x: 400, y: 150 }
  ];

  const createEnemy = () => {
    return {
      x: ENEMY_PATH[0].x,
      y: ENEMY_PATH[0].y,
      health: 30 + gameStateRef.current.wave * 10,
      maxHealth: 30 + gameStateRef.current.wave * 10,
      speed: 1,
      pathIndex: 0,
      reward: 20
    };
  };

  const createTower = (x, y) => {
    return {
      x: x,
      y: y,
      range: 60,
      damage: 15,
      fireRate: 30,
      lastFired: 0,
      type: selectedTowerType
    };
  };

  const createProjectile = (startX, startY, targetX, targetY, damage) => {
    const dx = targetX - startX;
    const dy = targetY - startY;
    const distance = Math.sqrt(dx * dx + dy * dy);
    return {
      x: startX,
      y: startY,
      dx: (dx / distance) * 5,
      dy: (dy / distance) * 5,
      damage: damage
    };
  };

  const getDistance = (x1, y1, x2, y2) => {
    return Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);
  };

  const isOnPath = (x, y) => {
    for (let i = 0; i < ENEMY_PATH.length - 1; i++) {
      const p1 = ENEMY_PATH[i];
      const p2 = ENEMY_PATH[i + 1];
      const minX = Math.min(p1.x, p2.x) - 20;
      const maxX = Math.max(p1.x, p2.x) + 20;
      const minY = Math.min(p1.y, p2.y) - 20;
      const maxY = Math.max(p1.y, p2.y) + 20;
      if (x >= minX && x <= maxX && y >= minY && y <= maxY) {
        return true;
      }
    }
    return false;
  };

  const updateEnemies = () => {
    const state = gameStateRef.current;
    state.enemies = state.enemies.filter(enemy => {
      if (enemy.pathIndex < ENEMY_PATH.length - 1) {
        const target = ENEMY_PATH[enemy.pathIndex + 1];
        const dx = target.x - enemy.x;
        const dy = target.y - enemy.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        if (distance < 5) {
          enemy.pathIndex++;
        } else {
          enemy.x += (dx / distance) * enemy.speed;
          enemy.y += (dy / distance) * enemy.speed;
        }
        return true;
      } else {
        state.lives--;
        return false;
      }
    });
  };

  const updateTowers = () => {
    const state = gameStateRef.current;
    state.towers.forEach(tower => {
      tower.lastFired++;
      if (tower.lastFired >= tower.fireRate) {
        const target = state.enemies.find(enemy => 
          getDistance(tower.x, tower.y, enemy.x, enemy.y) <= tower.range
        );
        if (target) {
          state.projectiles.push(createProjectile(tower.x, tower.y, target.x, target.y, tower.damage));
          tower.lastFired = 0;
        }
      }
    });
  };

  const updateProjectiles = () => {
    const state = gameStateRef.current;
    state.projectiles = state.projectiles.filter(projectile => {
      projectile.x += projectile.dx;
      projectile.y += projectile.dy;
      
      const hitEnemy = state.enemies.find(enemy => 
        getDistance(projectile.x, projectile.y, enemy.x, enemy.y) < 10
      );
      
      if (hitEnemy) {
        hitEnemy.health -= projectile.damage;
        if (hitEnemy.health <= 0) {
          state.money += hitEnemy.reward;
          state.enemies = state.enemies.filter(e => e !== hitEnemy);
        }
        return false;
      }
      
      return projectile.x >= 0 && projectile.x <= CANVAS_WIDTH && 
             projectile.y >= 0 && projectile.y <= CANVAS_HEIGHT;
    });
  };

  const spawnEnemies = () => {
    const state = gameStateRef.current;
    state.enemySpawnTimer++;
    if (state.enemySpawnTimer >= 60 && state.enemiesSpawned < state.enemiesInWave) {
      state.enemies.push(createEnemy());
      state.enemiesSpawned++;
      state.enemySpawnTimer = 0;
    }
    
    if (state.enemiesSpawned >= state.enemiesInWave && state.enemies.length === 0) {
      state.wave++;
      state.enemiesInWave += 2;
      state.enemiesSpawned = 0;
      state.money += 50;
    }
  };

  const gameLoop = () => {
    const state = gameStateRef.current;
    if (state.gameOver || state.paused) return;
    
    updateEnemies();
    updateTowers();
    updateProjectiles();
    spawnEnemies();
    
    if (state.lives <= 0) {
      state.gameOver = true;
    }
    
    setGameState({ ...state });
  };

  const draw = () => {
    const canvas = canvasRef.current;
    if (!canvas) return;
    
    const ctx = canvas.getContext('2d');
    ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
    
    // Draw path
    ctx.strokeStyle = '#8B4513';
    ctx.lineWidth = 20;
    ctx.beginPath();
    ctx.moveTo(ENEMY_PATH[0].x, ENEMY_PATH[0].y);
    for (let i = 1; i < ENEMY_PATH.length; i++) {
      ctx.lineTo(ENEMY_PATH[i].x, ENEMY_PATH[i].y);
    }
    ctx.stroke();
    
    // Draw towers
    gameStateRef.current.towers.forEach(tower => {
      ctx.fillStyle = '#4A4A4A';
      ctx.fillRect(tower.x - 10, tower.y - 10, 20, 20);
      ctx.strokeStyle = '#333';
      ctx.strokeRect(tower.x - 10, tower.y - 10, 20, 20);
    });
    
    // Draw enemies
    gameStateRef.current.enemies.forEach(enemy => {
      ctx.fillStyle = '#FF4444';
      ctx.beginPath();
      ctx.arc(enemy.x, enemy.y, 8, 0, Math.PI * 2);
      ctx.fill();
      
      // Health bar
      const healthPercent = enemy.health / enemy.maxHealth;
      ctx.fillStyle = '#FF0000';
      ctx.fillRect(enemy.x - 10, enemy.y - 15, 20, 3);
      ctx.fillStyle = '#00FF00';
      ctx.fillRect(enemy.x - 10, enemy.y - 15, 20 * healthPercent, 3);
    });
    
    // Draw projectiles
    gameStateRef.current.projectiles.forEach(projectile => {
      ctx.fillStyle = '#FFFF00';
      ctx.beginPath();
      ctx.arc(projectile.x, projectile.y, 3, 0, Math.PI * 2);
      ctx.fill();
    });
  };

  const handleCanvasClick = (event) => {
    if (gameStateRef.current.gameOver) return;
    
    const rect = canvasRef.current.getBoundingClientRect();
    const x = event.clientX - rect.left;
    const y = event.clientY - rect.top;
    
    if (isOnPath(x, y)) return;
    
    const existingTower = gameStateRef.current.towers.find(tower => 
      getDistance(tower.x, tower.y, x, y) < 25
    );
    
    if (existingTower) return;
    
    if (gameStateRef.current.money >= TOWER_COST) {
      gameStateRef.current.towers.push(createTower(x, y));
      gameStateRef.current.money -= TOWER_COST;
      setGameState({ ...gameStateRef.current });
    }
  };

  const resetGame = () => {
    gameStateRef.current = {
      towers: [],
      enemies: [],
      projectiles: [],
      money: 100,
      lives: 10,
      wave: 1,
      enemySpawnTimer: 0,
      enemiesInWave: 5,
      enemiesSpawned: 0,
      gameOver: false,
      paused: false
    };
    setGameState({ ...gameStateRef.current });
  };

  useEffect(() => {
    const animate = () => {
      gameLoop();
      draw();
      animationRef.current = requestAnimationFrame(animate);
    };
    animate();
    
    return () => {
      if (animationRef.current) {
        cancelAnimationFrame(animationRef.current);
      }
    };
  }, []);

  return (
    <div style={{ padding: '20px', fontFamily: 'Arial, sans-serif' }}>
      <div style={{ marginBottom: '10px', display: 'flex', gap: '20px', alignItems: 'center' }}>
        <div>Money: ${gameState.money}</div>
        <div>Lives: {gameState.lives}</div>
        <div>Wave: {gameState.wave}</div>
        <button 
          onClick={resetGame}
          style={{ 
            padding: '5px 10px', 
            backgroundColor: '#4CAF50', 
            color: 'white', 
            border: 'none', 
            borderRadius: '3px',
            cursor: 'pointer'
          }}
        >
          Reset Game
        </button>
      </div>
      
      <canvas
        ref={canvasRef}
        width={CANVAS_WIDTH}
        height={CANVAS_HEIGHT}
        onClick={handleCanvasClick}
        style={{ 
          border: '2px solid #333', 
          backgroundColor: '#90EE90',
          cursor: 'crosshair'
        }}
      />
      
      <div style={{ marginTop: '10px', fontSize: '14px' }}>
        <div>Click to place towers (Cost: ${TOWER_COST})</div>
        <div>Towers automatically shoot at enemies in range</div>
        {gameState.gameOver && (
          <div style={{ color: 'red', fontWeight: 'bold', marginTop: '10px' }}>
            Game Over! Click Reset to play again.
          </div>
        )}
      </div>
    </div>
  );
};

export default GameZone;
----------------------------------------


================================================================================
GAME GENERATION: racing game - 2025-08-09 15:25:36.422144
================================================================================
FULL CLAUDE GENERATED CODE:
----------------------------------------
import React, { useState, useEffect, useCallback } from 'react';

const GameZone = ({ currentGame }) => {
  const [playerX, setPlayerX] = useState(200);
  const [playerY, setPlayerY] = useState(250);
  const [obstacles, setObstacles] = useState([]);
  const [score, setScore] = useState(0);
  const [gameOver, setGameOver] = useState(false);
  const [gameStarted, setGameStarted] = useState(false);

  const resetGame = useCallback(() => {
    setPlayerX(200);
    setPlayerY(250);
    setObstacles([]);
    setScore(0);
    setGameOver(false);
    setGameStarted(true);
  }, []);

  useEffect(() => {
    if (!gameStarted || gameOver) return;

    const gameLoop = setInterval(() => {
      setObstacles(prev => {
        const newObstacles = prev
          .map(obs => ({ ...obs, y: obs.y + 3 }))
          .filter(obs => obs.y < 320);

        if (Math.random() < 0.02) {
          newObstacles.push({
            x: Math.random() * 360,
            y: -20,
            width: 40,
            height: 20
          });
        }

        return newObstacles;
      });

      setScore(prev => prev + 1);
    }, 50);

    return () => clearInterval(gameLoop);
  }, [gameStarted, gameOver]);

  useEffect(() => {
    if (!gameStarted || gameOver) return;

    const handleKeyPress = (e) => {
      switch(e.key) {
        case 'ArrowLeft':
          setPlayerX(prev => Math.max(0, prev - 20));
          break;
        case 'ArrowRight':
          setPlayerX(prev => Math.min(360, prev + 20));
          break;
        case 'ArrowUp':
          setPlayerY(prev => Math.max(0, prev - 20));
          break;
        case 'ArrowDown':
          setPlayerY(prev => Math.min(280, prev + 20));
          break;
      }
    };

    window.addEventListener('keydown', handleKeyPress);
    return () => window.removeEventListener('keydown', handleKeyPress);
  }, [gameStarted, gameOver]);

  useEffect(() => {
    if (!gameStarted || gameOver) return;

    const checkCollision = () => {
      obstacles.forEach(obs => {
        if (
          playerX < obs.x + obs.width &&
          playerX + 40 > obs.x &&
          playerY < obs.y + obs.height &&
          playerY + 20 > obs.y
        ) {
          setGameOver(true);
        }
      });
    };

    checkCollision();
  }, [playerX, playerY, obstacles, gameStarted, gameOver]);

  return (
    <div style={{ 
      display: 'flex', 
      flexDirection: 'column', 
      alignItems: 'center', 
      padding: '20px',
      fontFamily: 'Arial, sans-serif'
    }}>
      <h2 style={{ margin: '0 0 10px 0', color: '#333' }}>Simple Racing Game</h2>
      
      <div style={{ marginBottom: '10px' }}>
        <span style={{ marginRight: '20px', fontWeight: 'bold' }}>Score: {score}</span>
        <button 
          onClick={resetGame}
          style={{
            padding: '8px 16px',
            backgroundColor: '#4CAF50',
            color: 'white',
            border: 'none',
            borderRadius: '4px',
            cursor: 'pointer'
          }}
        >
          {gameStarted ? 'Restart' : 'Start Game'}
        </button>
      </div>

      <div style={{
        position: 'relative',
        width: '400px',
        height: '300px',
        backgroundColor: '#333',
        border: '2px solid #666',
        overflow: 'hidden'
      }}>
        {gameStarted && (
          <>
            <div style={{
              position: 'absolute',
              left: `${playerX}px`,
              top: `${playerY}px`,
              width: '40px',
              height: '20px',
              backgroundColor: '#00ff00',
              borderRadius: '3px'
            }} />

            {obstacles.map((obs, index) => (
              <div
                key={index}
                style={{
                  position: 'absolute',
                  left: `${obs.x}px`,
                  top: `${obs.y}px`,
                  width: `${obs.width}px`,
                  height: `${obs.height}px`,
                  backgroundColor: '#ff0000',
                  borderRadius: '2px'
                }}
              />
            ))}
          </>
        )}

        {gameOver && (
          <div style={{
            position: 'absolute',
            top: '50%',
            left: '50%',
            transform: 'translate(-50%, -50%)',
            color: 'white',
            fontSize: '24px',
            fontWeight: 'bold',
            textAlign: 'center'
          }}>
            GAME OVER!<br />
            <span style={{ fontSize: '16px' }}>Final Score: {score}</span>
          </div>
        )}

        {!gameStarted && (
          <div style={{
            position: 'absolute',
            top: '50%',
            left: '50%',
            transform: 'translate(-50%, -50%)',
            color: 'white',
            fontSize: '18px',
            textAlign: 'center'
          }}>
            Click Start Game to begin!<br />
            <span style={{ fontSize: '14px' }}>Use arrow keys to move</span>
          </div>
        )}
      </div>

      <div style={{ 
        marginTop: '10px', 
        fontSize: '14px', 
        color: '#666',
        textAlign: 'center'
      }}>
        Use arrow keys to move your green car and avoid red obstacles!
      </div>
    </div>
  );
};

export default GameZone;
----------------------------------------


================================================================================
GAME GENERATION: shootinggame - 2025-08-09 15:27:15.129395
================================================================================
FULL CLAUDE GENERATED CODE:
----------------------------------------
import React, { useState, useEffect, useCallback } from 'react';

const GameZone = ({ currentGame }) => {
  const [player, setPlayer] = useState({ x: 200, y: 250 });
  const [bullets, setBullets] = useState([]);
  const [enemies, setEnemies] = useState([]);
  const [score, setScore] = useState(0);
  const [gameOver, setGameOver] = useState(false);
  const [keys, setKeys] = useState({});

  const gameWidth = 400;
  const gameHeight = 300;

  const resetGame = () => {
    setPlayer({ x: 200, y: 250 });
    setBullets([]);
    setEnemies([]);
    setScore(0);
    setGameOver(false);
  };

  const handleKeyDown = useCallback((e) => {
    setKeys(prev => ({ ...prev, [e.key]: true }));
  }, []);

  const handleKeyUp = useCallback((e) => {
    setKeys(prev => ({ ...prev, [e.key]: false }));
  }, []);

  useEffect(() => {
    window.addEventListener('keydown', handleKeyDown);
    window.addEventListener('keyup', handleKeyUp);
    return () => {
      window.removeEventListener('keydown', handleKeyDown);
      window.removeEventListener('keyup', handleKeyUp);
    };
  }, [handleKeyDown, handleKeyUp]);

  useEffect(() => {
    if (gameOver) return;

    const gameLoop = setInterval(() => {
      setPlayer(prev => {
        let newX = prev.x;
        let newY = prev.y;
        
        if (keys['ArrowLeft'] && newX > 0) newX -= 5;
        if (keys['ArrowRight'] && newX < gameWidth - 20) newX += 5;
        if (keys['ArrowUp'] && newY > 0) newY -= 5;
        if (keys['ArrowDown'] && newY < gameHeight - 20) newY += 5;
        
        return { x: newX, y: newY };
      });

      if (keys[' ']) {
        setBullets(prev => [...prev, { x: player.x + 10, y: player.y, id: Date.now() }]);
      }

      setBullets(prev => prev.filter(bullet => bullet.y > 0).map(bullet => ({ ...bullet, y: bullet.y - 8 })));

      setEnemies(prev => {
        let newEnemies = prev.map(enemy => ({ ...enemy, y: enemy.y + 2 })).filter(enemy => enemy.y < gameHeight);
        
        if (Math.random() < 0.02) {
          newEnemies.push({ x: Math.random() * (gameWidth - 20), y: 0, id: Date.now() });
        }
        
        return newEnemies;
      });

      setBullets(prevBullets => {
        setEnemies(prevEnemies => {
          const newBullets = [];
          const newEnemies = [];
          
          prevEnemies.forEach(enemy => {
            let hit = false;
            prevBullets.forEach(bullet => {
              if (bullet.x < enemy.x + 20 && bullet.x + 5 > enemy.x && 
                  bullet.y < enemy.y + 20 && bullet.y + 5 > enemy.y) {
                hit = true;
                setScore(prev => prev + 10);
              } else {
                if (!newBullets.find(b => b.id === bullet.id)) {
                  newBullets.push(bullet);
                }
              }
            });
            if (!hit) {
              newEnemies.push(enemy);
            }
          });
          
          return newEnemies;
        });
        
        return prevBullets.filter(bullet => {
          return !enemies.some(enemy => 
            bullet.x < enemy.x + 20 && bullet.x + 5 > enemy.x && 
            bullet.y < enemy.y + 20 && bullet.y + 5 > enemy.y
          );
        });
      });

      setEnemies(prevEnemies => {
        const collision = prevEnemies.some(enemy => 
          player.x < enemy.x + 20 && player.x + 20 > enemy.x && 
          player.y < enemy.y + 20 && player.y + 20 > enemy.y
        );
        if (collision) {
          setGameOver(true);
        }
        return prevEnemies;
      });

    }, 50);

    return () => clearInterval(gameLoop);
  }, [keys, player, gameOver, enemies]);

  return (
    <div style={{ 
      display: 'flex', 
      flexDirection: 'column', 
      alignItems: 'center', 
      padding: '20px',
      fontFamily: 'Arial, sans-serif'
    }}>
      <h2>Shooting Game</h2>
      <div style={{ marginBottom: '10px' }}>
        Score: {score} | Use arrow keys to move, spacebar to shoot
      </div>
      
      <div style={{
        position: 'relative',
        width: gameWidth,
        height: gameHeight,
        border: '2px solid #333',
        backgroundColor: '#000',
        overflow: 'hidden'
      }}>
        <div style={{
          position: 'absolute',
          left: player.x,
          top: player.y,
          width: 20,
          height: 20,
          backgroundColor: '#00ff00',
          borderRadius: '3px'
        }} />
        
        {bullets.map(bullet => (
          <div key={bullet.id} style={{
            position: 'absolute',
            left: bullet.x,
            top: bullet.y,
            width: 5,
            height: 10,
            backgroundColor: '#ffff00',
            borderRadius: '2px'
          }} />
        ))}
        
        {enemies.map(enemy => (
          <div key={enemy.id} style={{
            position: 'absolute',
            left: enemy.x,
            top: enemy.y,
            width: 20,
            height: 20,
            backgroundColor: '#ff0000',
            borderRadius: '3px'
          }} />
        ))}
        
        {gameOver && (
          <div style={{
            position: 'absolute',
            top: '50%',
            left: '50%',
            transform: 'translate(-50%, -50%)',
            color: '#fff',
            fontSize: '24px',
            textAlign: 'center',
            backgroundColor: 'rgba(0,0,0,0.8)',
            padding: '20px',
            borderRadius: '10px'
          }}>
            Game Over!<br />
            Final Score: {score}
          </div>
        )}
      </div>
      
      <button 
        onClick={resetGame}
        style={{
          marginTop: '10px',
          padding: '10px 20px',
          fontSize: '16px',
          backgroundColor: '#007bff',
          color: 'white',
          border: 'none',
          borderRadius: '5px',
          cursor: 'pointer'
        }}
      >
        {gameOver ? 'Play Again' : 'Restart'}
      </button>
    </div>
  );
};

export default GameZone;
----------------------------------------


================================================================================
GAME GENERATION: puzzle platformer game - 2025-08-09 15:27:54.391344
================================================================================
FULL CLAUDE GENERATED CODE:
----------------------------------------
import React, { useState, useEffect, useCallback } from 'react';

const GameZone = ({ currentGame }) => {
  const GRID_SIZE = 20;
  const GAME_WIDTH = 400;
  const GAME_HEIGHT = 300;
  const COLS = GAME_WIDTH / GRID_SIZE;
  const ROWS = GAME_HEIGHT / GRID_SIZE;

  const [playerPos, setPlayerPos] = useState({ x: 1, y: 13 });
  const [isJumping, setIsJumping] = useState(false);
  const [jumpVelocity, setJumpVelocity] = useState(0);
  const [gameWon, setGameWon] = useState(false);

  const level = [
    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
  ];

  const platforms = [
    { x: 3, y: 12, width: 3 },
    { x: 8, y: 10, width: 2 },
    { x: 12, y: 8, width: 3 },
    { x: 16, y: 6, width: 2 },
    { x: 5, y: 6, width: 2 },
    { x: 10, y: 4, width: 2 },
    { x: 17, y: 2, width: 2 }
  ];

  const goalPos = { x: 18, y: 1 };

  const isOnGround = useCallback((x, y) => {
    if (y >= ROWS - 2) return true;
    for (let platform of platforms) {
      if (x >= platform.x && x < platform.x + platform.width && y === platform.y - 1) {
        return true;
      }
    }
    return false;
  }, []);

  const isWall = useCallback((x, y) => {
    if (x < 1 || x >= COLS - 1 || y < 1 || y >= ROWS - 1) return true;
    for (let platform of platforms) {
      if (x >= platform.x && x < platform.x + platform.width && y === platform.y) {
        return true;
      }
    }
    return false;
  }, []);

  const handleKeyPress = useCallback((e) => {
    if (gameWon) return;
    
    const { x, y } = playerPos;
    let newX = x;
    let newY = y;

    switch (e.key) {
      case 'ArrowLeft':
      case 'a':
        newX = x - 1;
        break;
      case 'ArrowRight':
      case 'd':
        newX = x + 1;
        break;
      case 'ArrowUp':
      case 'w':
      case ' ':
        if (isOnGround(x, y) && !isJumping) {
          setIsJumping(true);
          setJumpVelocity(-3);
        }
        break;
    }

    if (!isWall(newX, y)) {
      setPlayerPos(prev => ({ ...prev, x: newX }));
    }
  }, [playerPos, gameWon, isOnGround, isWall, isJumping]);

  useEffect(() => {
    window.addEventListener('keydown', handleKeyPress);
    return () => window.removeEventListener('keydown', handleKeyPress);
  }, [handleKeyPress]);

  useEffect(() => {
    if (!isJumping) return;

    const interval = setInterval(() => {
      setPlayerPos(prev => {
        const newY = prev.y + Math.ceil(jumpVelocity / 2);
        
        if (isWall(prev.x, newY) || isOnGround(prev.x, newY)) {
          setIsJumping(false);
          setJumpVelocity(0);
          return prev;
        }

        return { ...prev, y: newY };
      });

      setJumpVelocity(prev => prev + 0.5);
    }, 100);

    return () => clearInterval(interval);
  }, [isJumping, jumpVelocity, isWall, isOnGround]);

  useEffect(() => {
    if (playerPos.x === goalPos.x && playerPos.y === goalPos.y) {
      setGameWon(true);
    }
  }, [playerPos]);

  const resetGame = () => {
    setPlayerPos({ x: 1, y: 13 });
    setIsJumping(false);
    setJumpVelocity(0);
    setGameWon(false);
  };

  const renderGrid = () => {
    const grid = [];
    for (let row = 0; row < ROWS; row++) {
      for (let col = 0; col < COLS; col++) {
        let cellStyle = {
          position: 'absolute',
          left: col * GRID_SIZE,
          top: row * GRID_SIZE,
          width: GRID_SIZE,
          height: GRID_SIZE,
          border: '1px solid #ddd'
        };

        let content = '';
        let bgColor = '#f0f0f0';

        if ((col === 0 || col === COLS - 1 || row === 0 || row === ROWS - 1)) {
          bgColor = '#333';
        }

        for (let platform of platforms) {
          if (col >= platform.x && col < platform.x + platform.width && row === platform.y) {
            bgColor = '#8B4513';
          }
        }

        if (col === playerPos.x && row === playerPos.y) {
          content = 'üü¶';
          bgColor = 'transparent';
        }

        if (col === goalPos.x && row === goalPos.y) {
          content = '‚≠ê';
          bgColor = 'transparent';
        }

        cellStyle.backgroundColor = bgColor;

        grid.push(
          <div key={`${row}-${col}`} style={cellStyle}>
            {content}
          </div>
        );
      }
    }
    return grid;
  };

  return (
    <div style={{ 
      display: 'flex', 
      flexDirection: 'column', 
      alignItems: 'center', 
      padding: '20px',
      fontFamily: 'Arial, sans-serif'
    }}>
      <h2>Puzzle Platformer</h2>
      <div style={{
        position: 'relative',
        width: GAME_WIDTH,
        height: GAME_HEIGHT,
        border: '2px solid #333',
        backgroundColor: '#87CEEB',
        overflow: 'hidden'
      }}>
        {renderGrid()}
      </div>
      
      <div style={{ marginTop: '10px', textAlign: 'center' }}>
        <p>Use WASD or Arrow Keys to move. Space/W/Up to jump.</p>
        <p>Reach the ‚≠ê to win!</p>
        {gameWon && <p style={{ color: 'green', fontWeight: 'bold' }}>üéâ You Won! üéâ</p>}
        <button 
          onClick={resetGame}
          style={{
            padding: '10px 20px',
            fontSize: '16px',
            backgroundColor: '#4CAF50',
            color: 'white',
            border: 'none',
            borderRadius: '5px',
            cursor: 'pointer',
            marginTop: '10px'
          }}
        >
          Reset Game
        </button>
      </div>
    </div>
  );
};

export default GameZone;
----------------------------------------


================================================================================
GAME GENERATION: puzzle platformer game - 2025-08-09 15:29:41.562202
================================================================================
FULL CLAUDE GENERATED CODE:
----------------------------------------
import React, { useState, useEffect, useCallback } from 'react';

const GameZone = ({ currentGame }) => {
  const GRID_SIZE = 20;
  const GAME_WIDTH = 400;
  const GAME_HEIGHT = 300;
  const COLS = GAME_WIDTH / GRID_SIZE;
  const ROWS = GAME_HEIGHT / GRID_SIZE;

  const [player, setPlayer] = useState({ x: 1, y: 13 });
  const [goal, setGoal] = useState({ x: 18, y: 2 });
  const [gameWon, setGameWon] = useState(false);
  const [level, setLevel] = useState(1);

  const platforms = [
    // Bottom platform
    ...Array.from({ length: 20 }, (_, i) => ({ x: i, y: 14 })),
    // Middle platforms
    { x: 5, y: 10 }, { x: 6, y: 10 }, { x: 7, y: 10 },
    { x: 12, y: 8 }, { x: 13, y: 8 }, { x: 14, y: 8 },
    { x: 3, y: 6 }, { x: 4, y: 6 },
    { x: 16, y: 4 }, { x: 17, y: 4 }, { x: 18, y: 4 },
    // Walls
    ...Array.from({ length: 15 }, (_, i) => ({ x: 0, y: i })),
    ...Array.from({ length: 15 }, (_, i) => ({ x: 19, y: i })),
  ];

  const isPlatform = (x, y) => {
    return platforms.some(p => p.x === x && p.y === y);
  };

  const canMoveTo = (x, y) => {
    return x >= 0 && x < COLS && y >= 0 && y < ROWS && !isPlatform(x, y);
  };

  const handleKeyPress = useCallback((e) => {
    if (gameWon) return;

    setPlayer(prev => {
      let newX = prev.x;
      let newY = prev.y;

      switch (e.key) {
        case 'ArrowLeft':
        case 'a':
          newX = prev.x - 1;
          break;
        case 'ArrowRight':
        case 'd':
          newX = prev.x + 1;
          break;
        case 'ArrowUp':
        case 'w':
          // Jump - only if standing on platform
          if (isPlatform(prev.x, prev.y + 1)) {
            newY = prev.y - 1;
          }
          break;
        case 'ArrowDown':
        case 's':
          newY = prev.y + 1;
          break;
        default:
          return prev;
      }

      if (canMoveTo(newX, newY)) {
        return { x: newX, y: newY };
      }
      return prev;
    });
  }, [gameWon]);

  useEffect(() => {
    window.addEventListener('keydown', handleKeyPress);
    return () => window.removeEventListener('keydown', handleKeyPress);
  }, [handleKeyPress]);

  useEffect(() => {
    // Apply gravity
    const gravityInterval = setInterval(() => {
      if (gameWon) return;

      setPlayer(prev => {
        const below = { x: prev.x, y: prev.y + 1 };
        if (canMoveTo(below.x, below.y)) {
          return below;
        }
        return prev;
      });
    }, 200);

    return () => clearInterval(gravityInterval);
  }, [gameWon]);

  useEffect(() => {
    if (player.x === goal.x && player.y === goal.y) {
      setGameWon(true);
    }
  }, [player, goal]);

  const resetGame = () => {
    setPlayer({ x: 1, y: 13 });
    setGameWon(false);
  };

  const nextLevel = () => {
    setLevel(prev => prev + 1);
    setPlayer({ x: 1, y: 13 });
    setGoal({ x: 18 - (level % 5), y: 2 + (level % 3) });
    setGameWon(false);
  };

  return (
    <div style={{ 
      display: 'flex', 
      flexDirection: 'column', 
      alignItems: 'center', 
      padding: '20px',
      fontFamily: 'Arial, sans-serif'
    }}>
      <h2>Puzzle Platformer - Level {level}</h2>
      
      <div style={{
        position: 'relative',
        width: GAME_WIDTH,
        height: GAME_HEIGHT,
        border: '2px solid #333',
        backgroundColor: '#87CEEB',
        margin: '10px 0'
      }}>
        {/* Platforms */}
        {platforms.map((platform, i) => (
          <div
            key={i}
            style={{
              position: 'absolute',
              left: platform.x * GRID_SIZE,
              top: platform.y * GRID_SIZE,
              width: GRID_SIZE,
              height: GRID_SIZE,
              backgroundColor: '#8B4513'
            }}
          />
        ))}

        {/* Goal */}
        <div
          style={{
            position: 'absolute',
            left: goal.x * GRID_SIZE,
            top: goal.y * GRID_SIZE,
            width: GRID_SIZE,
            height: GRID_SIZE,
            backgroundColor: '#FFD700',
            borderRadius: '50%'
          }}
        />

        {/* Player */}
        <div
          style={{
            position: 'absolute',
            left: player.x * GRID_SIZE,
            top: player.y * GRID_SIZE,
            width: GRID_SIZE,
            height: GRID_SIZE,
            backgroundColor: '#FF6B6B',
            borderRadius: '3px'
          }}
        />

        {/* Win message */}
        {gameWon && (
          <div style={{
            position: 'absolute',
            top: '50%',
            left: '50%',
            transform: 'translate(-50%, -50%)',
            backgroundColor: 'rgba(0, 0, 0, 0.8)',
            color: 'white',
            padding: '20px',
            borderRadius: '10px',
            textAlign: 'center'
          }}>
            <h3>Level Complete!</h3>
            <button 
              onClick={nextLevel}
              style={{
                padding: '10px 20px',
                margin: '5px',
                fontSize: '16px',
                backgroundColor: '#4CAF50',
                color: 'white',
                border: 'none',
                borderRadius: '5px',
                cursor: 'pointer'
              }}
            >
              Next Level
            </button>
          </div>
        )}
      </div>

      <div style={{ textAlign: 'center', marginTop: '10px' }}>
        <p>Use WASD or Arrow Keys to move. W/‚Üë to jump. Reach the gold circle!</p>
        <button 
          onClick={resetGame}
          style={{
            padding: '10px 20px',
            fontSize: '16px',
            backgroundColor: '#f44336',
            color: 'white',
            border: 'none',
            borderRadius: '5px',
            cursor: 'pointer',
            margin: '5px'
          }}
        >
          Restart Level
        </button>
      </div>
    </div>
  );
};

export default GameZone;
----------------------------------------


================================================================================
GAME GENERATION: flappy bird game - 2025-08-09 15:33:00.535111
================================================================================
FULL CLAUDE GENERATED CODE:
----------------------------------------
import React, { useState, useEffect, useCallback } from 'react';

const GameZone = ({ currentGame }) => {
  const [bird, setBird] = useState({ y: 150, velocity: 0 });
  const [pipes, setPipes] = useState([]);
  const [score, setScore] = useState(0);
  const [gameStarted, setGameStarted] = useState(false);
  const [gameOver, setGameOver] = useState(false);

  const GRAVITY = 0.5;
  const JUMP_FORCE = -8;
  const PIPE_WIDTH = 60;
  const PIPE_GAP = 120;
  const GAME_WIDTH = 400;
  const GAME_HEIGHT = 300;

  const jump = useCallback(() => {
    if (!gameStarted) {
      setGameStarted(true);
    }
    if (!gameOver) {
      setBird(prev => ({ ...prev, velocity: JUMP_FORCE }));
    }
  }, [gameStarted, gameOver]);

  const resetGame = () => {
    setBird({ y: 150, velocity: 0 });
    setPipes([]);
    setScore(0);
    setGameStarted(false);
    setGameOver(false);
  };

  useEffect(() => {
    const handleKeyPress = (e) => {
      if (e.code === 'Space') {
        e.preventDefault();
        jump();
      }
    };

    window.addEventListener('keydown', handleKeyPress);
    return () => window.removeEventListener('keydown', handleKeyPress);
  }, [jump]);

  useEffect(() => {
    if (!gameStarted || gameOver) return;

    const gameLoop = setInterval(() => {
      setBird(prev => {
        const newY = prev.y + prev.velocity;
        const newVelocity = prev.velocity + GRAVITY;
        
        if (newY <= 0 || newY >= GAME_HEIGHT - 20) {
          setGameOver(true);
          return prev;
        }
        
        return { y: newY, velocity: newVelocity };
      });

      setPipes(prev => {
        let newPipes = prev.map(pipe => ({ ...pipe, x: pipe.x - 2 }))
          .filter(pipe => pipe.x > -PIPE_WIDTH);

        if (newPipes.length === 0 || newPipes[newPipes.length - 1].x < GAME_WIDTH - 200) {
          const gapY = Math.random() * (GAME_HEIGHT - PIPE_GAP - 100) + 50;
          newPipes.push({
            x: GAME_WIDTH,
            topHeight: gapY,
            bottomY: gapY + PIPE_GAP,
            scored: false
          });
        }

        return newPipes;
      });
    }, 16);

    return () => clearInterval(gameLoop);
  }, [gameStarted, gameOver]);

  useEffect(() => {
    if (!gameStarted || gameOver) return;

    pipes.forEach(pipe => {
      if (!pipe.scored && pipe.x + PIPE_WIDTH < 50) {
        pipe.scored = true;
        setScore(prev => prev + 1);
      }

      const birdLeft = 50;
      const birdRight = 70;
      const birdTop = bird.y;
      const birdBottom = bird.y + 20;

      if (birdRight > pipe.x && birdLeft < pipe.x + PIPE_WIDTH) {
        if (birdTop < pipe.topHeight || birdBottom > pipe.bottomY) {
          setGameOver(true);
        }
      }
    });
  }, [bird, pipes, gameStarted, gameOver]);

  return (
    <div style={{ 
      display: 'flex', 
      flexDirection: 'column', 
      alignItems: 'center', 
      padding: '20px',
      fontFamily: 'Arial, sans-serif'
    }}>
      <h2>Flappy Bird</h2>
      <div style={{ marginBottom: '10px' }}>Score: {score}</div>
      
      <div 
        onClick={jump}
        style={{
          position: 'relative',
          width: GAME_WIDTH,
          height: GAME_HEIGHT,
          backgroundColor: '#87CEEB',
          border: '2px solid #333',
          cursor: 'pointer',
          overflow: 'hidden'
        }}
      >
        <div
          style={{
            position: 'absolute',
            left: '50px',
            top: `${bird.y}px`,
            width: '20px',
            height: '20px',
            backgroundColor: '#FFD700',
            borderRadius: '50%',
            border: '2px solid #FFA500'
          }}
        />

        {pipes.map((pipe, index) => (
          <div key={index}>
            <div
              style={{
                position: 'absolute',
                left: `${pipe.x}px`,
                top: '0px',
                width: `${PIPE_WIDTH}px`,
                height: `${pipe.topHeight}px`,
                backgroundColor: '#228B22',
                border: '2px solid #006400'
              }}
            />
            <div
              style={{
                position: 'absolute',
                left: `${pipe.x}px`,
                top: `${pipe.bottomY}px`,
                width: `${PIPE_WIDTH}px`,
                height: `${GAME_HEIGHT - pipe.bottomY}px`,
                backgroundColor: '#228B22',
                border: '2px solid #006400'
              }}
            />
          </div>
        ))}

        {!gameStarted && (
          <div style={{
            position: 'absolute',
            top: '50%',
            left: '50%',
            transform: 'translate(-50%, -50%)',
            textAlign: 'center',
            color: '#333',
            fontSize: '18px'
          }}>
            Click or Press Space to Start
          </div>
        )}

        {gameOver && (
          <div style={{
            position: 'absolute',
            top: '50%',
            left: '50%',
            transform: 'translate(-50%, -50%)',
            textAlign: 'center',
            backgroundColor: 'rgba(255, 255, 255, 0.9)',
            padding: '20px',
            borderRadius: '10px',
            border: '2px solid #333'
          }}>
            <div style={{ fontSize: '24px', color: '#FF0000', marginBottom: '10px' }}>
              Game Over!
            </div>
            <div style={{ marginBottom: '15px' }}>Final Score: {score}</div>
            <button 
              onClick={resetGame}
              style={{
                padding: '10px 20px',
                fontSize: '16px',
                backgroundColor: '#4CAF50',
                color: 'white',
                border: 'none',
                borderRadius: '5px',
                cursor: 'pointer'
              }}
            >
              Play Again
            </button>
          </div>
        )}
      </div>

      <div style={{ marginTop: '10px', textAlign: 'center', fontSize: '14px' }}>
        Click the game area or press Space to jump
      </div>
    </div>
  );
};

export default GameZone;
----------------------------------------


================================================================================
GAME GENERATION: pong - 2025-08-09 15:34:30.833994
================================================================================
FULL CLAUDE GENERATED CODE:
----------------------------------------
import React, { useState, useEffect, useRef } from 'react';

const GameZone = ({ currentGame }) => {
  const canvasRef = useRef(null);
  const [gameState, setGameState] = useState({
    ballX: 200,
    ballY: 150,
    ballVelX: 3,
    ballVelY: 2,
    leftPaddleY: 125,
    rightPaddleY: 125,
    leftScore: 0,
    rightScore: 0,
    gameRunning: false
  });

  const CANVAS_WIDTH = 400;
  const CANVAS_HEIGHT = 300;
  const PADDLE_WIDTH = 10;
  const PADDLE_HEIGHT = 50;
  const BALL_SIZE = 8;

  useEffect(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;

    const ctx = canvas.getContext('2d');
    let animationId;

    const gameLoop = () => {
      if (!gameState.gameRunning) return;

      // Update ball position
      const newBallX = gameState.ballX + gameState.ballVelX;
      const newBallY = gameState.ballY + gameState.ballVelY;
      let newBallVelX = gameState.ballVelX;
      let newBallVelY = gameState.ballVelY;
      let newLeftScore = gameState.leftScore;
      let newRightScore = gameState.rightScore;

      // Ball collision with top/bottom walls
      if (newBallY <= 0 || newBallY >= CANVAS_HEIGHT - BALL_SIZE) {
        newBallVelY = -newBallVelY;
      }

      // Ball collision with paddles
      if (newBallX <= PADDLE_WIDTH && 
          newBallY >= gameState.leftPaddleY && 
          newBallY <= gameState.leftPaddleY + PADDLE_HEIGHT) {
        newBallVelX = -newBallVelX;
      }

      if (newBallX >= CANVAS_WIDTH - PADDLE_WIDTH - BALL_SIZE && 
          newBallY >= gameState.rightPaddleY && 
          newBallY <= gameState.rightPaddleY + PADDLE_HEIGHT) {
        newBallVelX = -newBallVelX;
      }

      // Ball out of bounds (scoring)
      if (newBallX < 0) {
        newRightScore++;
        setGameState(prev => ({
          ...prev,
          ballX: 200,
          ballY: 150,
          ballVelX: 3,
          ballVelY: 2,
          rightScore: newRightScore
        }));
        return;
      }

      if (newBallX > CANVAS_WIDTH) {
        newLeftScore++;
        setGameState(prev => ({
          ...prev,
          ballX: 200,
          ballY: 150,
          ballVelX: -3,
          ballVelY: 2,
          leftScore: newLeftScore
        }));
        return;
      }

      // Update game state
      setGameState(prev => ({
        ...prev,
        ballX: newBallX,
        ballY: newBallY,
        ballVelX: newBallVelX,
        ballVelY: newBallVelY
      }));

      animationId = requestAnimationFrame(gameLoop);
    };

    if (gameState.gameRunning) {
      animationId = requestAnimationFrame(gameLoop);
    }

    return () => {
      if (animationId) {
        cancelAnimationFrame(animationId);
      }
    };
  }, [gameState]);

  useEffect(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;

    const ctx = canvas.getContext('2d');
    
    // Clear canvas
    ctx.fillStyle = '#000';
    ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

    // Draw paddles
    ctx.fillStyle = '#fff';
    ctx.fillRect(0, gameState.leftPaddleY, PADDLE_WIDTH, PADDLE_HEIGHT);
    ctx.fillRect(CANVAS_WIDTH - PADDLE_WIDTH, gameState.rightPaddleY, PADDLE_WIDTH, PADDLE_HEIGHT);

    // Draw ball
    ctx.fillRect(gameState.ballX, gameState.ballY, BALL_SIZE, BALL_SIZE);

    // Draw center line
    ctx.setLineDash([5, 5]);
    ctx.strokeStyle = '#fff';
    ctx.beginPath();
    ctx.moveTo(CANVAS_WIDTH / 2, 0);
    ctx.lineTo(CANVAS_WIDTH / 2, CANVAS_HEIGHT);
    ctx.stroke();

    // Draw scores
    ctx.font = '24px Arial';
    ctx.fillText(gameState.leftScore.toString(), CANVAS_WIDTH / 4, 30);
    ctx.fillText(gameState.rightScore.toString(), (3 * CANVAS_WIDTH) / 4, 30);
  }, [gameState]);

  useEffect(() => {
    const handleKeyDown = (e) => {
      if (!gameState.gameRunning) return;

      setGameState(prev => {
        let newLeftPaddleY = prev.leftPaddleY;
        let newRightPaddleY = prev.rightPaddleY;

        // Left paddle controls (W/S)
        if (e.key === 'w' || e.key === 'W') {
          newLeftPaddleY = Math.max(0, prev.leftPaddleY - 20);
        }
        if (e.key === 's' || e.key === 'S') {
          newLeftPaddleY = Math.min(CANVAS_HEIGHT - PADDLE_HEIGHT, prev.leftPaddleY + 20);
        }

        // Right paddle controls (Arrow keys)
        if (e.key === 'ArrowUp') {
          newRightPaddleY = Math.max(0, prev.rightPaddleY - 20);
        }
        if (e.key === 'ArrowDown') {
          newRightPaddleY = Math.min(CANVAS_HEIGHT - PADDLE_HEIGHT, prev.rightPaddleY + 20);
        }

        return {
          ...prev,
          leftPaddleY: newLeftPaddleY,
          rightPaddleY: newRightPaddleY
        };
      });
    };

    window.addEventListener('keydown', handleKeyDown);
    return () => window.removeEventListener('keydown', handleKeyDown);
  }, [gameState.gameRunning]);

  const startGame = () => {
    setGameState(prev => ({ ...prev, gameRunning: true }));
  };

  const resetGame = () => {
    setGameState({
      ballX: 200,
      ballY: 150,
      ballVelX: 3,
      ballVelY: 2,
      leftPaddleY: 125,
      rightPaddleY: 125,
      leftScore: 0,
      rightScore: 0,
      gameRunning: false
    });
  };

  return (
    <div style={{ textAlign: 'center', padding: '20px' }}>
      <h2 style={{ color: '#333', marginBottom: '20px' }}>Pong Game</h2>
      <canvas
        ref={canvasRef}
        width={CANVAS_WIDTH}
        height={CANVAS_HEIGHT}
        style={{ 
          border: '2px solid #333',
          display: 'block',
          margin: '0 auto 20px'
        }}
      />
      <div style={{ marginBottom: '10px' }}>
        <button
          onClick={startGame}
          disabled={gameState.gameRunning}
          style={{
            padding: '10px 20px',
            margin: '0 10px',
            fontSize: '16px',
            backgroundColor: gameState.gameRunning ? '#ccc' : '#4CAF50',
            color: 'white',
            border: 'none',
            borderRadius: '4px',
            cursor: gameState.gameRunning ? 'not-allowed' : 'pointer'
          }}
        >
          Start Game
        </button>
        <button
          onClick={resetGame}
          style={{
            padding: '10px 20px',
            margin: '0 10px',
            fontSize: '16px',
            backgroundColor: '#f44336',
            color: 'white',
            border: 'none',
            borderRadius: '4px',
            cursor: 'pointer'
          }}
        >
          Reset
        </button>
      </div>
      <div style={{ fontSize: '14px', color: '#666' }}>
        <p>Left Player: W/S keys | Right Player: Arrow Up/Down</p>
        <p>Score: {gameState.leftScore} - {gameState.rightScore}</p>
      </div>
    </div>
  );
};

export default GameZone;
----------------------------------------


================================================================================
GAME GENERATION: racing car game - 2025-08-09 15:35:09.331196
================================================================================
FULL CLAUDE GENERATED CODE:
----------------------------------------
import React, { useState, useEffect, useCallback } from 'react';

const GameZone = ({ currentGame }) => {
  const [carPosition, setCarPosition] = useState(200);
  const [obstacles, setObstacles] = useState([]);
  const [score, setScore] = useState(0);
  const [gameRunning, setGameRunning] = useState(false);
  const [gameOver, setGameOver] = useState(false);

  const carWidth = 40;
  const carHeight = 60;
  const gameWidth = 400;
  const gameHeight = 300;
  const obstacleWidth = 30;
  const obstacleHeight = 40;

  const resetGame = useCallback(() => {
    setCarPosition(200);
    setObstacles([]);
    setScore(0);
    setGameRunning(false);
    setGameOver(false);
  }, []);

  const startGame = useCallback(() => {
    setGameRunning(true);
    setGameOver(false);
  }, []);

  const moveLeft = useCallback(() => {
    if (gameRunning && !gameOver) {
      setCarPosition(prev => Math.max(0, prev - 20));
    }
  }, [gameRunning, gameOver]);

  const moveRight = useCallback(() => {
    if (gameRunning && !gameOver) {
      setCarPosition(prev => Math.min(gameWidth - carWidth, prev + 20));
    }
  }, [gameRunning, gameOver]);

  useEffect(() => {
    const handleKeyPress = (e) => {
      if (e.key === 'ArrowLeft') {
        moveLeft();
      } else if (e.key === 'ArrowRight') {
        moveRight();
      }
    };

    window.addEventListener('keydown', handleKeyPress);
    return () => window.removeEventListener('keydown', handleKeyPress);
  }, [moveLeft, moveRight]);

  useEffect(() => {
    if (!gameRunning || gameOver) return;

    const gameLoop = setInterval(() => {
      setObstacles(prev => {
        const newObstacles = prev.map(obstacle => ({
          ...obstacle,
          y: obstacle.y + 3
        })).filter(obstacle => obstacle.y < gameHeight);

        if (Math.random() < 0.02) {
          newObstacles.push({
            x: Math.random() * (gameWidth - obstacleWidth),
            y: -obstacleHeight,
            id: Date.now()
          });
        }

        const carRect = {
          x: carPosition,
          y: gameHeight - carHeight - 10,
          width: carWidth,
          height: carHeight
        };

        const collision = newObstacles.some(obstacle => {
          return carRect.x < obstacle.x + obstacleWidth &&
                 carRect.x + carRect.width > obstacle.x &&
                 carRect.y < obstacle.y + obstacleHeight &&
                 carRect.y + carRect.height > obstacle.y;
        });

        if (collision) {
          setGameOver(true);
          setGameRunning(false);
        }

        return newObstacles;
      });

      setScore(prev => prev + 1);
    }, 50);

    return () => clearInterval(gameLoop);
  }, [gameRunning, gameOver, carPosition]);

  return (
    <div style={{ 
      display: 'flex', 
      flexDirection: 'column', 
      alignItems: 'center', 
      padding: '20px',
      fontFamily: 'Arial, sans-serif'
    }}>
      <h2 style={{ margin: '0 0 10px 0' }}>Racing Car Game</h2>
      
      <div style={{ marginBottom: '10px' }}>
        <span style={{ marginRight: '20px' }}>Score: {score}</span>
        {gameOver && <span style={{ color: 'red', fontWeight: 'bold' }}>GAME OVER!</span>}
      </div>

      <div style={{
        position: 'relative',
        width: gameWidth,
        height: gameHeight,
        backgroundColor: '#333',
        border: '2px solid #000',
        overflow: 'hidden'
      }}>
        <div style={{
          position: 'absolute',
          left: carPosition,
          bottom: 10,
          width: carWidth,
          height: carHeight,
          backgroundColor: '#ff4444',
          borderRadius: '5px'
        }} />

        {obstacles.map(obstacle => (
          <div
            key={obstacle.id}
            style={{
              position: 'absolute',
              left: obstacle.x,
              top: obstacle.y,
              width: obstacleWidth,
              height: obstacleHeight,
              backgroundColor: '#888',
              borderRadius: '3px'
            }}
          />
        ))}

        {!gameRunning && !gameOver && (
          <div style={{
            position: 'absolute',
            top: '50%',
            left: '50%',
            transform: 'translate(-50%, -50%)',
            color: 'white',
            textAlign: 'center'
          }}>
            <div>Use arrow keys to move</div>
            <div>Avoid the obstacles!</div>
          </div>
        )}
      </div>

      <div style={{ marginTop: '10px' }}>
        {!gameRunning && !gameOver && (
          <button onClick={startGame} style={{
            padding: '10px 20px',
            fontSize: '16px',
            backgroundColor: '#4CAF50',
            color: 'white',
            border: 'none',
            borderRadius: '5px',
            cursor: 'pointer'
          }}>
            Start Game
          </button>
        )}
        
        {(gameOver || gameRunning) && (
          <button onClick={resetGame} style={{
            padding: '10px 20px',
            fontSize: '16px',
            backgroundColor: '#f44336',
            color: 'white',
            border: 'none',
            borderRadius: '5px',
            cursor: 'pointer',
            marginRight: '10px'
          }}>
            Reset
          </button>
        )}

        <div style={{ marginTop: '10px' }}>
          <button onClick={moveLeft} style={{
            padding: '10px 15px',
            fontSize: '14px',
            backgroundColor: '#2196F3',
            color: 'white',
            border: 'none',
            borderRadius: '5px',
            cursor: 'pointer',
            marginRight: '10px'
          }}>
            ‚Üê Left
          </button>
          
          <button onClick={moveRight} style={{
            padding: '10px 15px',
            fontSize: '14px',
            backgroundColor: '#2196F3',
            color: 'white',
            border: 'none',
            borderRadius: '5px',
            cursor: 'pointer'
          }}>
            Right ‚Üí
          </button>
        </div>
      </div>
    </div>
  );
};

export default GameZone;
----------------------------------------


================================================================================
GAME GENERATION: flappy bird game - 2025-08-09 15:39:08.967418
================================================================================
FULL CLAUDE GENERATED CODE:
----------------------------------------
import React, { useState, useEffect, useRef } from 'react';

const GameZone = ({ currentGame }) => {
  const canvasRef = useRef(null);
  const [gameState, setGameState] = useState('ready');
  const [score, setScore] = useState(0);
  const [bird, setBird] = useState({ y: 150, velocity: 0 });
  const [pipes, setPipes] = useState([]);
  const gameLoopRef = useRef();
  const keysRef = useRef({});

  const CANVAS_WIDTH = 400;
  const CANVAS_HEIGHT = 300;
  const BIRD_SIZE = 20;
  const PIPE_WIDTH = 50;
  const PIPE_GAP = 100;
  const GRAVITY = 0.5;
  const JUMP_FORCE = -8;
  const PIPE_SPEED = 2;

  useEffect(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;

    const handleKeyDown = (e) => {
      if (e.code === 'Space') {
        e.preventDefault();
        if (gameState === 'ready') {
          startGame();
        } else if (gameState === 'playing') {
          setBird(prev => ({ ...prev, velocity: JUMP_FORCE }));
        }
      }
    };

    const handleClick = () => {
      if (gameState === 'ready') {
        startGame();
      } else if (gameState === 'playing') {
        setBird(prev => ({ ...prev, velocity: JUMP_FORCE }));
      }
    };

    window.addEventListener('keydown', handleKeyDown);
    canvas.addEventListener('click', handleClick);

    return () => {
      window.removeEventListener('keydown', handleKeyDown);
      canvas.removeEventListener('click', handleClick);
    };
  }, [gameState]);

  const startGame = () => {
    setGameState('playing');
    setScore(0);
    setBird({ y: 150, velocity: 0 });
    setPipes([{ x: CANVAS_WIDTH, topHeight: Math.random() * 100 + 50 }]);
  };

  const resetGame = () => {
    setGameState('ready');
    setScore(0);
    setBird({ y: 150, velocity: 0 });
    setPipes([]);
    if (gameLoopRef.current) {
      cancelAnimationFrame(gameLoopRef.current);
    }
  };

  const checkCollision = (birdY, pipes) => {
    if (birdY < 0 || birdY > CANVAS_HEIGHT - BIRD_SIZE) {
      return true;
    }

    for (let pipe of pipes) {
      if (pipe.x < 50 + BIRD_SIZE && pipe.x + PIPE_WIDTH > 50) {
        if (birdY < pipe.topHeight || birdY + BIRD_SIZE > pipe.topHeight + PIPE_GAP) {
          return true;
        }
      }
    }
    return false;
  };

  useEffect(() => {
    if (gameState !== 'playing') return;

    const gameLoop = () => {
      setBird(prev => {
        const newY = prev.y + prev.velocity;
        const newVelocity = prev.velocity + GRAVITY;
        return { y: newY, velocity: newVelocity };
      });

      setPipes(prev => {
        let newPipes = prev.map(pipe => ({ ...pipe, x: pipe.x - PIPE_SPEED }));
        newPipes = newPipes.filter(pipe => pipe.x > -PIPE_WIDTH);

        if (newPipes.length === 0 || newPipes[newPipes.length - 1].x < CANVAS_WIDTH - 200) {
          newPipes.push({
            x: CANVAS_WIDTH,
            topHeight: Math.random() * 100 + 50
          });
        }

        const passedPipes = newPipes.filter(pipe => pipe.x + PIPE_WIDTH < 50);
        if (passedPipes.length > prev.filter(pipe => pipe.x + PIPE_WIDTH < 50).length) {
          setScore(s => s + 1);
        }

        return newPipes;
      });

      gameLoopRef.current = requestAnimationFrame(gameLoop);
    };

    gameLoopRef.current = requestAnimationFrame(gameLoop);

    return () => {
      if (gameLoopRef.current) {
        cancelAnimationFrame(gameLoopRef.current);
      }
    };
  }, [gameState]);

  useEffect(() => {
    if (gameState === 'playing' && checkCollision(bird.y, pipes)) {
      setGameState('gameOver');
      if (gameLoopRef.current) {
        cancelAnimationFrame(gameLoopRef.current);
      }
    }
  }, [bird.y, pipes, gameState]);

  useEffect(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;

    const ctx = canvas.getContext('2d');
    ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

    ctx.fillStyle = '#87CEEB';
    ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

    if (gameState === 'playing' || gameState === 'gameOver') {
      pipes.forEach(pipe => {
        ctx.fillStyle = '#228B22';
        ctx.fillRect(pipe.x, 0, PIPE_WIDTH, pipe.topHeight);
        ctx.fillRect(pipe.x, pipe.topHeight + PIPE_GAP, PIPE_WIDTH, CANVAS_HEIGHT - pipe.topHeight - PIPE_GAP);
      });

      ctx.fillStyle = '#FFD700';
      ctx.fillRect(50, bird.y, BIRD_SIZE, BIRD_SIZE);
    }

    if (gameState === 'ready') {
      ctx.fillStyle = '#FFD700';
      ctx.fillRect(50, bird.y, BIRD_SIZE, BIRD_SIZE);
    }
  }, [bird, pipes, gameState]);

  return (
    <div style={{ display: 'flex', flexDirection: 'column', alignItems: 'center', padding: '20px' }}>
      <h2 style={{ margin: '0 0 10px 0' }}>Flappy Bird</h2>
      <div style={{ marginBottom: '10px' }}>Score: {score}</div>
      
      <canvas
        ref={canvasRef}
        width={CANVAS_WIDTH}
        height={CANVAS_HEIGHT}
        style={{
          border: '2px solid #333',
          backgroundColor: '#87CEEB',
          cursor: 'pointer'
        }}
      />
      
      <div style={{ marginTop: '10px', textAlign: 'center' }}>
        {gameState === 'ready' && (
          <div>
            <p>Click or press SPACE to start!</p>
            <p>Click or press SPACE to flap</p>
          </div>
        )}
        {gameState === 'playing' && (
          <p>Click or press SPACE to flap!</p>
        )}
        {gameState === 'gameOver' && (
          <div>
            <p>Game Over! Final Score: {score}</p>
            <button 
              onClick={resetGame}
              style={{
                padding: '10px 20px',
                fontSize: '16px',
                backgroundColor: '#4CAF50',
                color: 'white',
                border: 'none',
                borderRadius: '5px',
                cursor: 'pointer'
              }}
            >
              Play Again
            </button>
          </div>
        )}
      </div>
    </div>
  );
};

export default GameZone;
----------------------------------------


================================================================================
GAME GENERATION: space invaders - 2025-08-09 15:40:34.846829
================================================================================
FULL CLAUDE GENERATED CODE:
----------------------------------------
import React, { useState, useEffect, useRef, useCallback } from 'react';

const GameZone = ({ currentGame }) => {
  const canvasRef = useRef(null);
  const [gameState, setGameState] = useState('playing');
  const [score, setScore] = useState(0);
  const [lives, setLives] = useState(3);
  
  const gameRef = useRef({
    player: { x: 200, y: 270, width: 40, height: 20 },
    bullets: [],
    invaders: [],
    invaderBullets: [],
    keys: {},
    lastTime: 0,
    invaderDirection: 1,
    invaderSpeed: 0.5,
    invaderDropDistance: 20
  });

  const initializeInvaders = useCallback(() => {
    const invaders = [];
    for (let row = 0; row < 5; row++) {
      for (let col = 0; col < 8; col++) {
        invaders.push({
          x: col * 45 + 50,
          y: row * 35 + 50,
          width: 30,
          height: 20,
          alive: true
        });
      }
    }
    gameRef.current.invaders = invaders;
  }, []);

  const resetGame = useCallback(() => {
    setGameState('playing');
    setScore(0);
    setLives(3);
    gameRef.current.player = { x: 200, y: 270, width: 40, height: 20 };
    gameRef.current.bullets = [];
    gameRef.current.invaderBullets = [];
    gameRef.current.invaderDirection = 1;
    gameRef.current.invaderSpeed = 0.5;
    initializeInvaders();
  }, [initializeInvaders]);

  const handleKeyDown = useCallback((e) => {
    gameRef.current.keys[e.key] = true;
    if (e.key === ' ') {
      e.preventDefault();
      if (gameState === 'playing') {
        const player = gameRef.current.player;
        gameRef.current.bullets.push({
          x: player.x + player.width / 2 - 2,
          y: player.y,
          width: 4,
          height: 10,
          speed: 5
        });
      }
    }
  }, [gameState]);

  const handleKeyUp = useCallback((e) => {
    gameRef.current.keys[e.key] = false;
  }, []);

  const checkCollision = (rect1, rect2) => {
    return rect1.x < rect2.x + rect2.width &&
           rect1.x + rect1.width > rect2.x &&
           rect1.y < rect2.y + rect2.height &&
           rect1.y + rect1.height > rect2.y;
  };

  const gameLoop = useCallback((currentTime) => {
    if (gameState !== 'playing') return;

    const canvas = canvasRef.current;
    if (!canvas) return;

    const ctx = canvas.getContext('2d');
    const game = gameRef.current;
    const deltaTime = currentTime - game.lastTime;
    game.lastTime = currentTime;

    ctx.fillStyle = '#000';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    if (game.keys['ArrowLeft'] && game.player.x > 0) {
      game.player.x -= 3;
    }
    if (game.keys['ArrowRight'] && game.player.x < canvas.width - game.player.width) {
      game.player.x += 3;
    }

    ctx.fillStyle = '#0f0';
    ctx.fillRect(game.player.x, game.player.y, game.player.width, game.player.height);

    game.bullets = game.bullets.filter(bullet => {
      bullet.y -= bullet.speed;
      ctx.fillStyle = '#ff0';
      ctx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height);
      return bullet.y > 0;
    });

    let shouldMoveDown = false;
    const aliveInvaders = game.invaders.filter(inv => inv.alive);
    
    if (aliveInvaders.length > 0) {
      const leftmost = Math.min(...aliveInvaders.map(inv => inv.x));
      const rightmost = Math.max(...aliveInvaders.map(inv => inv.x + inv.width));
      
      if ((rightmost >= canvas.width - 10 && game.invaderDirection > 0) ||
          (leftmost <= 10 && game.invaderDirection < 0)) {
        shouldMoveDown = true;
        game.invaderDirection *= -1;
      }
    }

    game.invaders.forEach(invader => {
      if (!invader.alive) return;
      
      if (shouldMoveDown) {
        invader.y += game.invaderDropDistance;
      } else {
        invader.x += game.invaderDirection * game.invaderSpeed;
      }
      
      ctx.fillStyle = '#f00';
      ctx.fillRect(invader.x, invader.y, invader.width, invader.height);

      if (Math.random() < 0.0005) {
        game.invaderBullets.push({
          x: invader.x + invader.width / 2 - 2,
          y: invader.y + invader.height,
          width: 4,
          height: 8,
          speed: 2
        });
      }
    });

    game.invaderBullets = game.invaderBullets.filter(bullet => {
      bullet.y += bullet.speed;
      ctx.fillStyle = '#f0f';
      ctx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height);
      return bullet.y < canvas.height;
    });

    for (let i = game.bullets.length - 1; i >= 0; i--) {
      const bullet = game.bullets[i];
      for (let j = 0; j < game.invaders.length; j++) {
        const invader = game.invaders[j];
        if (invader.alive && checkCollision(bullet, invader)) {
          invader.alive = false;
          game.bullets.splice(i, 1);
          setScore(prev => prev + 10);
          break;
        }
      }
    }

    for (let i = game.invaderBullets.length - 1; i >= 0; i--) {
      const bullet = game.invaderBullets[i];
      if (checkCollision(bullet, game.player)) {
        game.invaderBullets.splice(i, 1);
        setLives(prev => {
          const newLives = prev - 1;
          if (newLives <= 0) {
            setGameState('gameOver');
          }
          return newLives;
        });
        break;
      }
    }

    const remainingInvaders = game.invaders.filter(inv => inv.alive);
    if (remainingInvaders.length === 0) {
      setGameState('won');
    }

    if (remainingInvaders.some(inv => inv.y + inv.height >= game.player.y)) {
      setGameState('gameOver');
    }

    requestAnimationFrame(gameLoop);
  }, [gameState]);

  useEffect(() => {
    initializeInvaders();
    window.addEventListener('keydown', handleKeyDown);
    window.addEventListener('keyup', handleKeyUp);
    
    return () => {
      window.removeEventListener('keydown', handleKeyDown);
      window.removeEventListener('keyup', handleKeyUp);
    };
  }, [handleKeyDown, handleKeyUp, initializeInvaders]);

  useEffect(() => {
    if (gameState === 'playing') {
      requestAnimationFrame(gameLoop);
    }
  }, [gameState, gameLoop]);

  return (
    <div style={{ 
      display: 'flex', 
      flexDirection: 'column', 
      alignItems: 'center', 
      padding: '20px',
      fontFamily: 'monospace',
      backgroundColor: '#222',
      color: '#fff',
      minHeight: '100vh'
    }}>
      <h2 style={{ margin: '0 0 10px 0' }}>Space Invaders</h2>
      
      <div style={{ marginBottom: '10px' }}>
        <span style={{ marginRight: '20px' }}>Score: {score}</span>
        <span>Lives: {lives}</span>
      </div>

      <canvas
        ref={canvasRef}
        width={400}
        height={300}
        style={{
          border: '2px solid #fff',
          backgroundColor: '#000'
        }}
      />

      <div style={{ marginTop: '10px', textAlign: 'center' }}>
        <div style={{ marginBottom: '10px', fontSize: '12px' }}>
          Use ‚Üê ‚Üí arrows to move, SPACE to shoot
        </div>
        
        {gameState === 'gameOver' && (
          <div>
            <div style={{ color: '#f00', marginBottom: '10px' }}>GAME OVER</div>
            <button onClick={resetGame} style={{
              padding: '10px 20px',
              fontSize: '16px',
              backgroundColor: '#0f0',
              border: 'none',
              cursor: 'pointer'
            }}>
              Play Again
            </button>
          </div>
        )}
        
        {gameState === 'won' && (
          <div>
            <div style={{ color: '#0f0', marginBottom: '10px' }}>YOU WIN!</div>
            <button onClick={resetGame} style={{
              padding: '10px 20px',
              fontSize: '16px',
              backgroundColor: '#0f0',
              border: 'none',
              cursor: 'pointer'
            }}>
              Play Again
            </button>
          </div>
        )}
        
        {gameState === 'playing' && (
          <button onClick={resetGame} style={{
            padding: '8px 16px',
            fontSize: '14px',
            backgroundColor: '#666',
            color: '#fff',
            border: 'none',
            cursor: 'pointer'
          }}>
            Restart
          </button>
        )}
      </div>
    </div>
  );
};

export default GameZone;
----------------------------------------


================================================================================
GAME GENERATION: flappy bird game - 2025-08-09 15:48:54.954468
================================================================================
FULL CLAUDE GENERATED CODE:
----------------------------------------
import React, { useState, useEffect, useRef } from 'react';

const GameZone = ({ currentGame }) => {
  const canvasRef = useRef(null);
  const [gameState, setGameState] = useState('waiting');
  const [score, setScore] = useState(0);
  const [bird, setBird] = useState({ y: 150, velocity: 0 });
  const [pipes, setPipes] = useState([]);
  const gameLoopRef = useRef();

  const CANVAS_WIDTH = 400;
  const CANVAS_HEIGHT = 300;
  const BIRD_SIZE = 20;
  const PIPE_WIDTH = 50;
  const PIPE_GAP = 100;
  const GRAVITY = 0.5;
  const JUMP_FORCE = -8;
  const PIPE_SPEED = 2;

  useEffect(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;
    
    const ctx = canvas.getContext('2d');
    
    const gameLoop = () => {
      if (gameState !== 'playing') return;
      
      setBird(prevBird => {
        const newY = prevBird.y + prevBird.velocity;
        const newVelocity = prevBird.velocity + GRAVITY;
        
        if (newY < 0 || newY > CANVAS_HEIGHT - BIRD_SIZE) {
          setGameState('gameOver');
          return prevBird;
        }
        
        return { y: newY, velocity: newVelocity };
      });
      
      setPipes(prevPipes => {
        let newPipes = prevPipes.map(pipe => ({
          ...pipe,
          x: pipe.x - PIPE_SPEED
        })).filter(pipe => pipe.x > -PIPE_WIDTH);
        
        if (newPipes.length === 0 || newPipes[newPipes.length - 1].x < CANVAS_WIDTH - 200) {
          const gapY = Math.random() * (CANVAS_HEIGHT - PIPE_GAP - 100) + 50;
          newPipes.push({
            x: CANVAS_WIDTH,
            topHeight: gapY,
            bottomY: gapY + PIPE_GAP,
            passed: false
          });
        }
        
        newPipes.forEach(pipe => {
          if (!pipe.passed && pipe.x + PIPE_WIDTH < 50) {
            pipe.passed = true;
            setScore(prev => prev + 1);
          }
        });
        
        return newPipes;
      });
      
      gameLoopRef.current = requestAnimationFrame(gameLoop);
    };
    
    if (gameState === 'playing') {
      gameLoopRef.current = requestAnimationFrame(gameLoop);
    }
    
    return () => {
      if (gameLoopRef.current) {
        cancelAnimationFrame(gameLoopRef.current);
      }
    };
  }, [gameState]);

  useEffect(() => {
    const checkCollisions = () => {
      if (gameState !== 'playing') return;
      
      const birdLeft = 50;
      const birdRight = 50 + BIRD_SIZE;
      const birdTop = bird.y;
      const birdBottom = bird.y + BIRD_SIZE;
      
      for (let pipe of pipes) {
        const pipeLeft = pipe.x;
        const pipeRight = pipe.x + PIPE_WIDTH;
        
        if (birdRight > pipeLeft && birdLeft < pipeRight) {
          if (birdTop < pipe.topHeight || birdBottom > pipe.bottomY) {
            setGameState('gameOver');
            return;
          }
        }
      }
    };
    
    checkCollisions();
  }, [bird, pipes, gameState]);

  useEffect(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;
    
    const ctx = canvas.getContext('2d');
    ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
    
    ctx.fillStyle = '#87CEEB';
    ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
    
    ctx.fillStyle = '#FFD700';
    ctx.fillRect(50, bird.y, BIRD_SIZE, BIRD_SIZE);
    
    ctx.fillStyle = '#228B22';
    pipes.forEach(pipe => {
      ctx.fillRect(pipe.x, 0, PIPE_WIDTH, pipe.topHeight);
      ctx.fillRect(pipe.x, pipe.bottomY, PIPE_WIDTH, CANVAS_HEIGHT - pipe.bottomY);
    });
    
    ctx.fillStyle = '#000';
    ctx.font = '20px Arial';
    ctx.fillText(`Score: ${score}`, 10, 30);
    
    if (gameState === 'waiting') {
      ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
      ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
      ctx.fillStyle = '#FFF';
      ctx.font = '24px Arial';
      ctx.textAlign = 'center';
      ctx.fillText('Click to Start!', CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2);
      ctx.textAlign = 'left';
    }
    
    if (gameState === 'gameOver') {
      ctx.fillStyle = 'rgba(255, 0, 0, 0.7)';
      ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
      ctx.fillStyle = '#FFF';
      ctx.font = '24px Arial';
      ctx.textAlign = 'center';
      ctx.fillText('Game Over!', CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2 - 20);
      ctx.fillText(`Final Score: ${score}`, CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2 + 20);
      ctx.textAlign = 'left';
    }
  }, [bird, pipes, gameState, score]);

  const handleJump = () => {
    if (gameState === 'waiting') {
      setGameState('playing');
      setBird({ y: 150, velocity: JUMP_FORCE });
    } else if (gameState === 'playing') {
      setBird(prev => ({ ...prev, velocity: JUMP_FORCE }));
    }
  };

  const resetGame = () => {
    setGameState('waiting');
    setScore(0);
    setBird({ y: 150, velocity: 0 });
    setPipes([]);
    if (gameLoopRef.current) {
      cancelAnimationFrame(gameLoopRef.current);
    }
  };

  useEffect(() => {
    const handleKeyPress = (e) => {
      if (e.code === 'Space') {
        e.preventDefault();
        handleJump();
      }
    };
    
    window.addEventListener('keydown', handleKeyPress);
    return () => window.removeEventListener('keydown', handleKeyPress);
  }, [gameState]);

  return (
    <div style={{ 
      display: 'flex', 
      flexDirection: 'column', 
      alignItems: 'center', 
      padding: '20px',
      fontFamily: 'Arial, sans-serif'
    }}>
      <h2 style={{ margin: '0 0 20px 0', color: '#333' }}>Flappy Bird</h2>
      
      <canvas
        ref={canvasRef}
        width={CANVAS_WIDTH}
        height={CANVAS_HEIGHT}
        onClick={handleJump}
        style={{
          border: '2px solid #333',
          cursor: 'pointer',
          marginBottom: '20px'
        }}
      />
      
      <div style={{ display: 'flex', gap: '10px', marginBottom: '10px' }}>
        <button
          onClick={resetGame}
          style={{
            padding: '10px 20px',
            fontSize: '16px',
            backgroundColor: '#4CAF50',
            color: 'white',
            border: 'none',
            borderRadius: '5px',
            cursor: 'pointer'
          }}
        >
          Reset Game
        </button>
      </div>
      
      <div style={{ textAlign: 'center', color: '#666' }}>
        <p>Click or press SPACE to jump!</p>
        <p>Avoid the green pipes and try to get a high score!</p>
      </div>
    </div>
  );
};

export default GameZone;
----------------------------------------

