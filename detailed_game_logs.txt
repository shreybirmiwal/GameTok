
================================================================================
GAME GENERATION: tiktactoe - 2025-08-09 13:07:10.523781
================================================================================
FULL CLAUDE GENERATED CODE:
----------------------------------------
```
<div style="text-align: center; padding: 20px;">
  <h3>üéÆ Tic Tac Toe</h3>
  <canvas id="game_tiktactoe_canvas" width="400" height="300" style="border: 2px solid #333; background: #fff; cursor: pointer;"></canvas>
  <div style="margin: 10px 0;">
    <strong>Current Player: <span id="game_tiktactoe_player">X</span></strong>
  </div>
  <div style="font-size: 12px; color: #666;">
    Controls: Click on squares to place X or O
  </div>
</div>
<script>
const tiktactoe_canvas = document.getElementById('game_tiktactoe_canvas');
const tiktactoe_ctx = tiktactoe_canvas.getContext('2d');
const tiktactoe_playerSpan = document.getElementById('game_tiktactoe_player');

let tiktactoe_board = [['', '', ''], ['', '', ''], ['', '', '']];
let tiktactoe_currentPlayer = 'X';
let tiktactoe_gameOver = false;

function tiktactoe_drawBoard() {
  tiktactoe_ctx.clearRect(0, 0, 400, 300);
  
  // Draw grid lines
  tiktactoe_ctx.strokeStyle = '#333';
  tiktactoe_ctx.lineWidth = 3;
  
  // Vertical lines
  tiktactoe_ctx.beginPath();
  tiktactoe_ctx.moveTo(133, 0);
  tiktactoe_ctx.lineTo(133, 300);
  tiktactoe_ctx.moveTo(267, 0);
  tiktactoe_ctx.lineTo(267, 300);
  tiktactoe_ctx.stroke();
  
  // Horizontal lines
  tiktactoe_ctx.beginPath();
  tiktactoe_ctx.moveTo(0, 100);
  tiktactoe_ctx.lineTo(400, 100);
  tiktactoe_ctx.moveTo(0, 200);
  tiktactoe_ctx.lineTo(400, 200);
  tiktactoe_ctx.stroke();
  
  // Draw X's and O's
  tiktactoe_ctx.font = '60px Arial';
  tiktactoe_ctx.textAlign = 'center';
  tiktactoe_ctx.textBaseline = 'middle';
  
  for (let row = 0; row < 3; row++) {
    for (let col = 0; col < 3; col++) {
      if (tiktactoe_board[row][col] === 'X') {
        tiktactoe_ctx.fillStyle = '#e74c3c';
        tiktactoe_ctx.fillText('X', col * 133 + 66, row * 100 + 50);
      } else if (tiktactoe_board[row][col] === 'O') {
        tiktactoe_ctx.fillStyle = '#3498db';
        tiktactoe_ctx.fillText('O', col * 133 + 66, row * 100 + 50);
      }
    }
  }
}

function tiktactoe_checkWinner() {
  // Check rows
  for (let row = 0; row < 3; row++) {
    if (tiktactoe_board[row][0] && tiktactoe_board[row][0] === tiktactoe_board[row][1] && tiktactoe_board[row][1] === tiktactoe_board[row][2]) {
      return tiktactoe_board[row][0];
    }
  }
  
  // Check columns
  for (let col = 0; col < 3; col++) {
    if (tiktactoe_board[0][col] && tiktactoe_board[0][col] === tiktactoe_board[1][col] && tiktactoe_board[1][col] === tiktactoe_board[2][col]) {
      return tiktactoe_board[0][col];
    }
  }
  
  // Check diagonals
  if (tiktactoe_board[0][0] && tiktactoe_board[0][0] === tiktactoe_board[1][1] && tiktactoe_board[1][1] === tiktactoe_board[2][2]) {
    return tiktactoe_board[0][0];
  }
  if (tiktactoe_board[0][2] && tiktactoe_board[0][2] === tiktactoe_board[1][1] && tiktactoe_board[1][1] === tiktactoe_board[2][0]) {
    return tiktactoe_board[0][2];
  }
  
  // Check for tie
  let isFull = true;
  for (let row = 0; row < 3; row++) {
    for (let col = 0; col < 3; col++) {
      if (tiktactoe_board[row][col] === '') {
        isFull = false;
        break;
      }
    }
  }
  
  return isFull ? 'tie' : null;
}

function tiktactoe_resetGame() {
  tiktactoe_board = [['', '', ''], ['', '', ''], ['', '', '']];
  tiktactoe_currentPlayer = 'X';
  tiktactoe_gameOver = false;
  tiktactoe_playerSpan.textContent = 'X';
  tiktactoe_drawBoard();
}

tiktactoe_canvas.addEventListener('click', function(e) {
  if (tiktactoe_gameOver) {
    tiktactoe_resetGame();
    return;
  }
  
  const rect = tiktactoe_canvas.getBoundingClientRect();
  const x = e.clientX - rect.left;
  const y = e.clientY - rect.top;
  
  const col = Math.floor(x / 133);
  const row = Math.floor(y / 100);
  
  if (row >= 0 && row < 3 && col >= 0 && col < 3 && tiktactoe_board[row][col] === '') {
    tiktactoe_board[row][col] = tiktactoe_currentPlayer;
    
    const winner = tiktactoe_checkWinner();
    if (winner) {
      tiktactoe_gameOver = true;
      if (winner === 'tie') {
        tiktactoe_playerSpan.textContent = "It's a Tie! Click to restart";
      } else {
        tiktactoe_playerSpan.textContent = winner + " Wins! Click to restart";
      }
    } else {
      tiktactoe_currentPlayer = tiktactoe_currentPlayer === 'X' ? 'O' : 'X';
      tiktactoe_playerSpan.textContent = tiktactoe_currentPlayer;
    }
    
    tiktactoe_drawBoard();
  }
});

tiktactoe_drawBoard();
</script>
```
----------------------------------------

MORPH BEFORE/AFTER COMPARISON:
----------------------------------------
BEFORE (GameZone.js):
import React from 'react';

const GameZone = ({ currentGame }) => {
  // Simple HTML content zone - perfect for Morph apply!
  // Just put your HTML game content here and it will render
  // this is the html content that will be rendered in the game zone ONLY CHANGE THIS ZONE
  // MORPH: ONLY replace the content between these backticks - keep everything else the same
  const htmlContent = `
    <div style="text-align: center; padding: 20px;">
      <h2>üéÆ HTML Game Zone</h2>
      <p>This is where your HTML5 Canvas games will appear!</p>
      <div style="background: linear-gradient(45deg, #ff6b6b, #4ecdc4); padding: 20px; border-radius: 10px; color: white; margin: 20px 0;">
        <strong>Perfect for Morph Apply!</strong><br/>
        Just replace the htmlContent variable above with your generated HTML5 game code
      </div>
      <div style="border: 2px dashed #ccc; padding: 40px; margin: 20px 0; border-radius: 8px;">
        <p style="color: #666; font-style: italic;">
          üéØ Game content will render here<br/>
          üìù Use Morph to apply HTML5 Canvas games directly<br/>
          üöÄ No complex React components needed!
        </p>
      </div>
      <p style="font-size: 12px; color: #888;">
        Current game: ${currentGame || 'None selected'}
      </p>
    </div>
  `;

  return (
    <div className="game-zone">
      <div className="game-content">
        <div dangerouslySetInnerHTML={{ __html: htmlContent }} />
      </div>
    </div>
  );
};

export default GameZone;

AFTER (GameZone.js):
import React from 'react';

const GameZone = ({ currentGame }) => {
  // Simple HTML content zone - perfect for Morph apply!
  // Just put your HTML game content here and it will render
  // this is the html content that will be rendered in the game zone ONLY CHANGE THIS ZONE
  // MORPH: ONLY replace the content between these backticks - keep everything else the same
  const htmlContent = `
<div style="text-align: center; padding: 20px;">
  <h3>üéÆ Tic Tac Toe</h3>
  <canvas id="game_tiktactoe_canvas" width="400" height="300" style="border: 2px solid #333; background: #fff; cursor: pointer;"></canvas>
  <div style="margin: 10px 0;">
    <strong>Current Player: <span id="game_tiktactoe_player">X</span></strong>
  </div>
  <div style="font-size: 12px; color: #666;">
    Controls: Click on squares to place X or O
  </div>
</div>
<script>
const tiktactoe_canvas = document.getElementById('game_tiktactoe_canvas');
const tiktactoe_ctx = tiktactoe_canvas.getContext('2d');
const tiktactoe_playerSpan = document.getElementById('game_tiktactoe_player');

let tiktactoe_board = [['', '', ''], ['', '', ''], ['', '', '']];
let tiktactoe_currentPlayer = 'X';
let tiktactoe_gameOver = false;

function tiktactoe_drawBoard() {
  tiktactoe_ctx.clearRect(0, 0, 400, 300);
  
  // Draw grid lines
  tiktactoe_ctx.strokeStyle = '#333';
  tiktactoe_ctx.lineWidth = 3;
  
  // Vertical lines
  tiktactoe_ctx.beginPath();
  tiktactoe_ctx.moveTo(133, 0);
  tiktactoe_ctx.lineTo(133, 300);
  tiktactoe_ctx.moveTo(267, 0);
  tiktactoe_ctx.lineTo(267, 300);
  tiktactoe_ctx.stroke();
  
  // Horizontal lines
  tiktactoe_ctx.beginPath();
  tiktactoe_ctx.moveTo(0, 100);
  tiktactoe_ctx.lineTo(400, 100);
  tiktactoe_ctx.moveTo(0, 200);
  tiktactoe_ctx.lineTo(400, 200);
  tiktactoe_ctx.stroke();
  
  // Draw X's and O's
  tiktactoe_ctx.font = '60px Arial';
  tiktactoe_ctx.textAlign = 'center';
  tiktactoe_ctx.textBaseline = 'middle';
  
  for (let row = 0; row < 3; row++) {
    for (let col = 0; col < 3; col++) {
      if (tiktactoe_board[row][col] === 'X') {
        tiktactoe_ctx.fillStyle = '#e74c3c';
        tiktactoe_ctx.fillText('X', col * 133 + 66, row * 100 + 50);
      } else if (tiktactoe_board[row][col] === 'O') {
        tiktactoe_ctx.fillStyle = '#3498db';
        tiktactoe_ctx.fillText('O', col * 133 + 66, row * 100 + 50);
      }
    }
  }
}

function tiktactoe_checkWinner() {
  // Check rows
  for (let row = 0; row < 3; row++) {
    if (tiktactoe_board[row][0] && tiktactoe_board[row][0] === tiktactoe_board[row][1] && tiktactoe_board[row][1] === tiktactoe_board[row][2]) {
      return tiktactoe_board[row][0];
    }
  }
  
  // Check columns
  for (let col = 0; col < 3; col++) {
    if (tiktactoe_board[0][col] && tiktactoe_board[0][col] === tiktactoe_board[1][col] && tiktactoe_board[1][col] === tiktactoe_board[2][col]) {
      return tiktactoe_board[0][col];
    }
  }
  
  // Check diagonals
  if (tiktactoe_board[0][0] && tiktactoe_board[0][0] === tiktactoe_board[1][1] && tiktactoe_board[1][1] === tiktactoe_board[2][2]) {
    return tiktactoe_board[0][0];
  }
  if (tiktactoe_board[0][2] && tiktactoe_board[0][2] === tiktactoe_board[1][1] && tiktactoe_board[1][1] === tiktactoe_board[2][0]) {
    return tiktactoe_board[0][2];
  }
  
  // Check for tie
  let isFull = true;
  for (let row = 0; row < 3; row++) {
    for (let col = 0; col < 3; col++) {
      if (tiktactoe_board[row][col] === '') {
        isFull = false;
        break;
      }
    }
  }
  
  return isFull ? 'tie' : null;
}

function tiktactoe_resetGame() {
  tiktactoe_board = [['', '', ''], ['', '', ''], ['', '', '']];
  tiktactoe_currentPlayer = 'X';
  tiktactoe_gameOver = false;
  tiktactoe_playerSpan.textContent = 'X';
  tiktactoe_drawBoard();
}

tiktactoe_canvas.addEventListener('click', function(e) {
  if (tiktactoe_gameOver) {
    tiktactoe_resetGame();
    return;
  }
  
  const rect = tiktactoe_canvas.getBoundingClientRect();
  const x = e.clientX - rect.left;
  const y = e.clientY - rect.top;
  
  const col = Math.floor(x / 133);
  const row = Math.floor(y / 100);
  
  if (row >= 0 && row < 3 && col >= 0 && col < 3 && tiktactoe_board[row][col] === '') {
    tiktactoe_board[row][col] = tiktactoe_currentPlayer;
    
    const winner = tiktactoe_checkWinner();
    if (winner) {
      tiktactoe_gameOver = true;
      if (winner === 'tie') {
        tiktactoe_playerSpan.textContent = "It's a Tie! Click to restart";
      } else {
        tiktactoe_playerSpan.textContent = winner + " Wins! Click to restart";
      }
    } else {
      tiktactoe_currentPlayer = tiktactoe_currentPlayer === 'X' ? 'O' : 'X';
      tiktactoe_playerSpan.textContent = tiktactoe_currentPlayer;
    }
    
    tiktactoe_drawBoard();
  }
});

tiktactoe_drawBoard();
</script>
`;

  return (
    <div className="game-zone">
      <div className="game-content">
        <div dangerouslySetInnerHTML={{ __html: htmlContent }} />
      </div>
    </div>
  );
};

export default GameZone;

================================================================================


================================================================================
GAME GENERATION: tik tak toe - 2025-08-09 13:18:54.732414
================================================================================
FULL CLAUDE GENERATED CODE:
----------------------------------------
```javascript
import React, { useState } from 'react';

const GameZone = ({ currentGame }) => {
  const [board, setBoard] = useState(Array(9).fill(null));
  const [isXNext, setIsXNext] = useState(true);
  const [winner, setWinner] = useState(null);

  const checkWinner = (squares) => {
    const lines = [
      [0, 1, 2],
      [3, 4, 5],
      [6, 7, 8],
      [0, 3, 6],
      [1, 4, 7],
      [2, 5, 8],
      [0, 4, 8],
      [2, 4, 6],
    ];
    for (let i = 0; i < lines.length; i++) {
      const [a, b, c] = lines[i];
      if (squares[a] && squares[a] === squares[b] && squares[a] === squares[c]) {
        return squares[a];
      }
    }
    return null;
  };

  const handleClick = (index) => {
    if (board[index] || winner) return;
    
    const newBoard = [...board];
    newBoard[index] = isXNext ? 'X' : 'O';
    setBoard(newBoard);
    
    const gameWinner = checkWinner(newBoard);
    if (gameWinner) {
      setWinner(gameWinner);
    } else {
      setIsXNext(!isXNext);
    }
  };

  const resetGame = () => {
    setBoard(Array(9).fill(null));
    setIsXNext(true);
    setWinner(null);
  };

  const isDraw = !winner && board.every(square => square !== null);

  const renderSquare = (index) => (
    <button
      key={index}
      onClick={() => handleClick(index)}
      style={{
        width: '80px',
        height: '80px',
        fontSize: '24px',
        fontWeight: 'bold',
        border: '2px solid #333',
        backgroundColor: '#fff',
        cursor: 'pointer',
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'center'
      }}
    >
      {board[index]}
    </button>
  );

  return (
    <div style={{
      display: 'flex',
      flexDirection: 'column',
      alignItems: 'center',
      padding: '20px',
      fontFamily: 'Arial, sans-serif'
    }}>
      <h2 style={{ marginBottom: '20px' }}>Tic Tac Toe</h2>
      
      <div style={{
        display: 'grid',
        gridTemplate: 'repeat(3, 80px) / repeat(3, 80px)',
        gap: '2px',
        marginBottom: '20px',
        border: '2px solid #333'
      }}>
        {Array(9).fill(null).map((_, index) => renderSquare(index))}
      </div>

      <div style={{ textAlign: 'center', marginBottom: '20px' }}>
        {winner ? (
          <h3 style={{ color: 'green' }}>Winner: {winner}!</h3>
        ) : isDraw ? (
          <h3 style={{ color: 'orange' }}>It's a Draw!</h3>
        ) : (
          <h3>Next Player: {isXNext ? 'X' : 'O'}</h3>
        )}
      </div>

      <button
        onClick={resetGame}
        style={{
          padding: '10px 20px',
          fontSize: '16px',
          backgroundColor: '#007bff',
          color: 'white',
          border: 'none',
          borderRadius: '5px',
          cursor: 'pointer'
        }}
      >
        Reset Game
      </button>
    </div>
  );
};

export default GameZone;
```
----------------------------------------


================================================================================
GAME GENERATION: car game - 2025-08-09 13:26:47.780186
================================================================================
FULL CLAUDE GENERATED CODE:
----------------------------------------
import React, { useState, useEffect, useRef, useCallback } from 'react';

const GameZone = ({ currentGame }) => {
  const canvasRef = useRef(null);
  const [gameState, setGameState] = useState('playing');
  const [score, setScore] = useState(0);
  const [car, setCar] = useState({ x: 175, y: 250, width: 50, height: 30 });
  const [obstacles, setObstacles] = useState([]);
  const [keys, setKeys] = useState({});

  const gameWidth = 400;
  const gameHeight = 300;
  const carSpeed = 5;
  const obstacleSpeed = 3;

  const resetGame = useCallback(() => {
    setCar({ x: 175, y: 250, width: 50, height: 30 });
    setObstacles([]);
    setScore(0);
    setGameState('playing');
  }, []);

  const checkCollision = (rect1, rect2) => {
    return rect1.x < rect2.x + rect2.width &&
           rect1.x + rect1.width > rect2.x &&
           rect1.y < rect2.y + rect2.height &&
           rect1.y + rect1.height > rect2.y;
  };

  const gameLoop = useCallback(() => {
    if (gameState !== 'playing') return;

    setCar(prevCar => {
      let newX = prevCar.x;
      if (keys['ArrowLeft'] && newX > 0) newX -= carSpeed;
      if (keys['ArrowRight'] && newX < gameWidth - prevCar.width) newX += carSpeed;
      return { ...prevCar, x: newX };
    });

    setObstacles(prevObstacles => {
      let newObstacles = prevObstacles.map(obs => ({
        ...obs,
        y: obs.y + obstacleSpeed
      })).filter(obs => obs.y < gameHeight);

      if (Math.random() < 0.02) {
        newObstacles.push({
          x: Math.random() * (gameWidth - 40),
          y: -30,
          width: 40,
          height: 30
        });
      }

      return newObstacles;
    });

    setScore(prevScore => prevScore + 1);
  }, [gameState, keys]);

  useEffect(() => {
    const handleKeyDown = (e) => {
      setKeys(prev => ({ ...prev, [e.key]: true }));
    };

    const handleKeyUp = (e) => {
      setKeys(prev => ({ ...prev, [e.key]: false }));
    };

    window.addEventListener('keydown', handleKeyDown);
    window.addEventListener('keyup', handleKeyUp);

    return () => {
      window.removeEventListener('keydown', handleKeyDown);
      window.removeEventListener('keyup', handleKeyUp);
    };
  }, []);

  useEffect(() => {
    const interval = setInterval(gameLoop, 50);
    return () => clearInterval(interval);
  }, [gameLoop]);

  useEffect(() => {
    obstacles.forEach(obstacle => {
      if (checkCollision(car, obstacle)) {
        setGameState('gameOver');
      }
    });
  }, [car, obstacles]);

  useEffect(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;

    const ctx = canvas.getContext('2d');
    ctx.clearRect(0, 0, gameWidth, gameHeight);

    ctx.fillStyle = '#333';
    ctx.fillRect(0, 0, gameWidth, gameHeight);

    for (let i = 0; i < gameWidth; i += 40) {
      ctx.fillStyle = '#666';
      ctx.fillRect(i + 18, 0, 4, gameHeight);
    }

    ctx.fillStyle = '#00ff00';
    ctx.fillRect(car.x, car.y, car.width, car.height);

    ctx.fillStyle = '#ff0000';
    obstacles.forEach(obstacle => {
      ctx.fillRect(obstacle.x, obstacle.y, obstacle.width, obstacle.height);
    });
  });

  return (
    <div style={{ 
      display: 'flex', 
      flexDirection: 'column', 
      alignItems: 'center', 
      padding: '20px',
      fontFamily: 'Arial, sans-serif'
    }}>
      <h2 style={{ margin: '0 0 10px 0' }}>Simple Car Game</h2>
      <div style={{ marginBottom: '10px' }}>
        Score: {score} | Status: {gameState}
      </div>
      
      <canvas
        ref={canvasRef}
        width={gameWidth}
        height={gameHeight}
        style={{
          border: '2px solid #000',
          backgroundColor: '#333'
        }}
      />
      
      <div style={{ marginTop: '15px' }}>
        <button 
          onClick={resetGame}
          style={{
            padding: '10px 20px',
            fontSize: '16px',
            backgroundColor: '#4CAF50',
            color: 'white',
            border: 'none',
            borderRadius: '5px',
            cursor: 'pointer',
            marginRight: '10px'
          }}
        >
          {gameState === 'gameOver' ? 'Play Again' : 'Restart'}
        </button>
      </div>
      
      <div style={{ 
        marginTop: '15px', 
        textAlign: 'center',
        fontSize: '14px',
        color: '#666'
      }}>
        Use arrow keys to move left and right<br/>
        Avoid the red obstacles!
      </div>
      
      {gameState === 'gameOver' && (
        <div style={{
          marginTop: '15px',
          padding: '10px',
          backgroundColor: '#ffebee',
          border: '1px solid #f44336',
          borderRadius: '5px',
          color: '#d32f2f',
          fontWeight: 'bold'
        }}>
          Game Over! Final Score: {score}
        </div>
      )}
    </div>
  );
};

export default GameZone;
----------------------------------------


================================================================================
GAME GENERATION: pacman - 2025-08-09 13:28:01.148852
================================================================================
FULL CLAUDE GENERATED CODE:
----------------------------------------
import React, { useState, useEffect, useCallback } from 'react';

const GameZone = ({ currentGame }) => {
  const GRID_SIZE = 20;
  const ROWS = 15;
  const COLS = 20;
  
  const initialMaze = [
    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
    [1,2,2,2,2,2,2,2,2,1,1,2,2,2,2,2,2,2,2,1],
    [1,2,1,1,2,1,1,1,2,1,1,2,1,1,1,2,1,1,2,1],
    [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1],
    [1,2,1,1,2,1,2,1,1,1,1,1,1,2,1,2,1,1,2,1],
    [1,2,2,2,2,1,2,2,2,1,1,2,2,2,1,2,2,2,2,1],
    [1,1,1,1,2,1,1,1,0,1,1,0,1,1,1,2,1,1,1,1],
    [0,0,0,1,2,1,0,0,0,0,0,0,0,0,1,2,1,0,0,0],
    [1,1,1,1,2,1,0,1,1,0,0,1,1,0,1,2,1,1,1,1],
    [1,2,2,2,2,2,0,1,0,0,0,0,1,0,2,2,2,2,2,1],
    [1,2,1,1,2,1,0,1,1,1,1,1,1,0,1,2,1,1,2,1],
    [1,2,2,2,2,1,2,2,2,1,1,2,2,2,1,2,2,2,2,1],
    [1,1,1,2,2,2,2,1,2,1,1,2,1,2,2,2,2,1,1,1],
    [1,2,2,2,2,2,2,1,2,2,2,2,1,2,2,2,2,2,2,1],
    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
  ];

  const [maze, setMaze] = useState(initialMaze);
  const [pacmanPos, setPacmanPos] = useState({ x: 1, y: 1 });
  const [ghosts, setGhosts] = useState([
    { x: 9, y: 8, color: 'red' },
    { x: 10, y: 8, color: 'pink' }
  ]);
  const [score, setScore] = useState(0);
  const [gameOver, setGameOver] = useState(false);
  const [direction, setDirection] = useState({ x: 0, y: 0 });

  const isValidMove = (x, y) => {
    return x >= 0 && x < COLS && y >= 0 && y < ROWS && maze[y][x] !== 1;
  };

  const moveGhosts = useCallback(() => {
    setGhosts(prevGhosts => 
      prevGhosts.map(ghost => {
        const directions = [
          { x: 0, y: -1 },
          { x: 0, y: 1 },
          { x: -1, y: 0 },
          { x: 1, y: 0 }
        ];
        
        const validMoves = directions.filter(dir => 
          isValidMove(ghost.x + dir.x, ghost.y + dir.y)
        );
        
        if (validMoves.length > 0) {
          const randomMove = validMoves[Math.floor(Math.random() * validMoves.length)];
          return {
            ...ghost,
            x: ghost.x + randomMove.x,
            y: ghost.y + randomMove.y
          };
        }
        return ghost;
      })
    );
  }, [maze]);

  const checkCollision = useCallback(() => {
    const collision = ghosts.some(ghost => 
      ghost.x === pacmanPos.x && ghost.y === pacmanPos.y
    );
    if (collision) {
      setGameOver(true);
    }
  }, [ghosts, pacmanPos]);

  const movePacman = useCallback(() => {
    if (direction.x === 0 && direction.y === 0) return;
    
    const newX = pacmanPos.x + direction.x;
    const newY = pacmanPos.y + direction.y;
    
    if (isValidMove(newX, newY)) {
      setPacmanPos({ x: newX, y: newY });
      
      if (maze[newY][newX] === 2) {
        setScore(prev => prev + 10);
        setMaze(prev => {
          const newMaze = [...prev];
          newMaze[newY] = [...newMaze[newY]];
          newMaze[newY][newX] = 0;
          return newMaze;
        });
      }
    }
  }, [direction, pacmanPos, maze]);

  useEffect(() => {
    const handleKeyPress = (e) => {
      if (gameOver) return;
      
      switch(e.key) {
        case 'ArrowUp':
          setDirection({ x: 0, y: -1 });
          break;
        case 'ArrowDown':
          setDirection({ x: 0, y: 1 });
          break;
        case 'ArrowLeft':
          setDirection({ x: -1, y: 0 });
          break;
        case 'ArrowRight':
          setDirection({ x: 1, y: 0 });
          break;
        default:
          break;
      }
    };

    window.addEventListener('keydown', handleKeyPress);
    return () => window.removeEventListener('keydown', handleKeyPress);
  }, [gameOver]);

  useEffect(() => {
    if (gameOver) return;
    
    const gameLoop = setInterval(() => {
      movePacman();
      moveGhosts();
    }, 200);

    return () => clearInterval(gameLoop);
  }, [movePacman, moveGhosts, gameOver]);

  useEffect(() => {
    checkCollision();
  }, [checkCollision]);

  const resetGame = () => {
    setMaze(initialMaze);
    setPacmanPos({ x: 1, y: 1 });
    setGhosts([
      { x: 9, y: 8, color: 'red' },
      { x: 10, y: 8, color: 'pink' }
    ]);
    setScore(0);
    setGameOver(false);
    setDirection({ x: 0, y: 0 });
  };

  const getCellContent = (x, y) => {
    if (pacmanPos.x === x && pacmanPos.y === y) {
      return 'üü°';
    }
    
    const ghost = ghosts.find(g => g.x === x && g.y === y);
    if (ghost) {
      return ghost.color === 'red' ? 'üëª' : 'üëπ';
    }
    
    switch(maze[y][
----------------------------------------


================================================================================
GAME GENERATION: shooter game - 2025-08-09 13:31:51.192977
================================================================================
FULL CLAUDE GENERATED CODE:
----------------------------------------
import React, { useState, useEffect, useCallback } from 'react';

const GameZone = ({ currentGame }) => {
  const [player, setPlayer] = useState({ x: 200, y: 250 });
  const [bullets, setBullets] = useState([]);
  const [enemies, setEnemies] = useState([]);
  const [score, setScore] = useState(0);
  const [gameRunning, setGameRunning] = useState(false);
  const [keys, setKeys] = useState({});

  const gameWidth = 400;
  const gameHeight = 300;

  const startGame = () => {
    setPlayer({ x: 200, y: 250 });
    setBullets([]);
    setEnemies([]);
    setScore(0);
    setGameRunning(true);
  };

  const resetGame = () => {
    setGameRunning(false);
    setPlayer({ x: 200, y: 250 });
    setBullets([]);
    setEnemies([]);
    setScore(0);
  };

  const handleKeyDown = useCallback((e) => {
    setKeys(prev => ({ ...prev, [e.key]: true }));
    if (e.key === ' ') {
      e.preventDefault();
      if (gameRunning) {
        setBullets(prev => [...prev, { x: player.x, y: player.y - 10, id: Date.now() }]);
      }
    }
  }, [gameRunning, player.x, player.y]);

  const handleKeyUp = useCallback((e) => {
    setKeys(prev => ({ ...prev, [e.key]: false }));
  }, []);

  useEffect(() => {
    window.addEventListener('keydown', handleKeyDown);
    window.addEventListener('keyup', handleKeyUp);
    return () => {
      window.removeEventListener('keydown', handleKeyDown);
      window.removeEventListener('keyup', handleKeyUp);
    };
  }, [handleKeyDown, handleKeyUp]);

  useEffect(() => {
    if (!gameRunning) return;

    const gameLoop = setInterval(() => {
      setPlayer(prev => {
        let newX = prev.x;
        if (keys['ArrowLeft'] && newX > 0) newX -= 5;
        if (keys['ArrowRight'] && newX < gameWidth - 20) newX += 5;
        return { ...prev, x: newX };
      });

      setBullets(prev => prev
        .map(bullet => ({ ...bullet, y: bullet.y - 8 }))
        .filter(bullet => bullet.y > 0)
      );

      setEnemies(prev => {
        let newEnemies = prev
          .map(enemy => ({ ...enemy, y: enemy.y + 2 }))
          .filter(enemy => enemy.y < gameHeight);
        
        if (Math.random() < 0.02) {
          newEnemies.push({
            x: Math.random() * (gameWidth - 20),
            y: 0,
            id: Date.now()
          });
        }
        
        return newEnemies;
      });

      setBullets(prevBullets => {
        setEnemies(prevEnemies => {
          let newEnemies = [...prevEnemies];
          let newBullets = [...prevBullets];
          
          prevBullets.forEach(bullet => {
            const hitEnemyIndex = newEnemies.findIndex(enemy => 
              bullet.x < enemy.x + 20 && bullet.x + 5 > enemy.x &&
              bullet.y < enemy.y + 20 && bullet.y + 5 > enemy.y
            );
            
            if (hitEnemyIndex !== -1) {
              newEnemies.splice(hitEnemyIndex, 1);
              newBullets = newBullets.filter(b => b.id !== bullet.id);
              setScore(prev => prev + 10);
            }
          });
          
          const playerHit = newEnemies.some(enemy =>
            player.x < enemy.x + 20 && player.x + 20 > enemy.x &&
            player.y < enemy.y + 20 && player.y + 20 > enemy.y
          );
          
          if (playerHit) {
            setGameRunning(false);
          }
          
          return newEnemies;
        });
        
        return prevBullets;
      });
    }, 50);

    return () => clearInterval(gameLoop);
  }, [gameRunning, keys, player.x, player.y]);

  return (
    <div style={{ textAlign: 'center', padding: '20px' }}>
      <h2>Shooter Game</h2>
      <div style={{ marginBottom: '10px' }}>
        <span>Score: {score}</span>
        <button onClick={startGame} style={{ marginLeft: '20px', marginRight: '10px' }}>
          Start
        </button>
        <button onClick={resetGame}>Reset</button>
      </div>
      
      <div style={{
        width: `${gameWidth}px`,
        height: `${gameHeight}px`,
        border: '2px solid #333',
        position: 'relative',
        backgroundColor: '#001122',
        margin: '0 auto',
        overflow: 'hidden'
      }}>
        <div style={{
          position: 'absolute',
          left: `${player.x}px`,
          top: `${player.y}px`,
          width: '20px',
          height: '20px',
          backgroundColor: '#00ff00',
          borderRadius: '3px'
        }} />
        
        {bullets.map(bullet => (
          <div key={bullet.id} style={{
            position: 'absolute',
            left: `${bullet.x}px`,
            top: `${bullet.y}px`,
            width: '5px',
            height: '10px',
            backgroundColor: '#ffff00',
            borderRadius: '2px'
          }} />
        ))}
        
        {enemies.map(enemy => (
          <div key={enemy.id} style={{
            position: 'absolute',
            left: `${enemy.x}px`,
            top: `${enemy.y}px`,
            width: '20px',
            height: '20px',
            backgroundColor: '#ff0000',
            borderRadius: '3px'
          }} />
        ))}
        
        {!gameRunning && (
          <div style={{
            position: 'absolute',
            top: '50%',
            left: '50%',
            transform: 'translate(-50%, -50%)',
            color: 'white',
            fontSize: '18px',
            fontWeight: 'bold'
          }}>
            {score > 0 ? `Game Over! Final Score: ${score}` : 'Press Start to Play'}
          </div>
        )}
      </div>
      
      <div style={{ marginTop: '10px', fontSize: '14px' }}>
        Use ‚Üê ‚Üí arrows to move, SPACE to shoot
      </div>
    </div>
  );
};

export default GameZone;
----------------------------------------


================================================================================
GAME GENERATION: chess - 2025-08-09 13:33:32.818454
================================================================================
FULL CLAUDE GENERATED CODE:
----------------------------------------
import React, { useState, useRef, useEffect } from 'react';

const GameZone = ({ currentGame }) => {
  const initialBoard = [
    ['r', 'n', 'b', 'q', 'k', 'b', 'n', 'r'],
    ['p', 'p', 'p', 'p', 'p', 'p', 'p', 'p'],
    [null, null, null, null, null, null, null, null],
    [null, null, null, null, null, null, null, null],
    [null, null, null, null, null, null, null, null],
    [null, null, null, null, null, null, null, null],
    ['P', 'P', 'P', 'P', 'P', 'P', 'P', 'P'],
    ['R', 'N', 'B', 'Q', 'K', 'B', 'N', 'R']
  ];

  const [board, setBoard] = useState(initialBoard);
  const [selectedSquare, setSelectedSquare] = useState(null);
  const [currentPlayer, setCurrentPlayer] = useState('white');
  const [gameStatus, setGameStatus] = useState('playing');

  const pieceSymbols = {
    'K': '‚ôî', 'Q': '‚ôï', 'R': '‚ôñ', 'B': '‚ôó', 'N': '‚ôò', 'P': '‚ôô',
    'k': '‚ôö', 'q': '‚ôõ', 'r': '‚ôú', 'b': '‚ôù', 'n': '‚ôû', 'p': '‚ôü'
  };

  const isWhitePiece = (piece) => piece && piece === piece.toUpperCase();
  const isBlackPiece = (piece) => piece && piece === piece.toLowerCase();

  const isValidMove = (fromRow, fromCol, toRow, toCol, piece) => {
    if (toRow < 0 || toRow > 7 || toCol < 0 || toCol > 7) return false;
    
    const targetPiece = board[toRow][toCol];
    if (targetPiece && 
        ((isWhitePiece(piece) && isWhitePiece(targetPiece)) ||
         (isBlackPiece(piece) && isBlackPiece(targetPiece)))) {
      return false;
    }

    const rowDiff = Math.abs(toRow - fromRow);
    const colDiff = Math.abs(toCol - fromCol);

    switch (piece.toLowerCase()) {
      case 'p':
        const direction = isWhitePiece(piece) ? -1 : 1;
        const startRow = isWhitePiece(piece) ? 6 : 1;
        
        if (toCol === fromCol) {
          if (toRow === fromRow + direction && !targetPiece) return true;
          if (fromRow === startRow && toRow === fromRow + 2 * direction && !targetPiece) return true;
        } else if (Math.abs(toCol - fromCol) === 1 && toRow === fromRow + direction && targetPiece) {
          return true;
        }
        return false;

      case 'r':
        if (fromRow === toRow || fromCol === toCol) {
          const stepRow = fromRow === toRow ? 0 : (toRow > fromRow ? 1 : -1);
          const stepCol = fromCol === toCol ? 0 : (toCol > fromCol ? 1 : -1);
          for (let i = 1; i < Math.max(rowDiff, colDiff); i++) {
            if (board[fromRow + i * stepRow][fromCol + i * stepCol]) return false;
          }
          return true;
        }
        return false;

      case 'n':
        return (rowDiff === 2 && colDiff === 1) || (rowDiff === 1 && colDiff === 2);

      case 'b':
        if (rowDiff === colDiff) {
          const stepRow = toRow > fromRow ? 1 : -1;
          const stepCol = toCol > fromCol ? 1 : -1;
          for (let i = 1; i < rowDiff; i++) {
            if (board[fromRow + i * stepRow][fromCol + i * stepCol]) return false;
          }
          return true;
        }
        return false;

      case 'q':
        if (fromRow === toRow || fromCol === toCol || rowDiff === colDiff) {
          const stepRow = fromRow === toRow ? 0 : (toRow > fromRow ? 1 : -1);
          const stepCol = fromCol === toCol ? 0 : (toCol > fromCol ? 1 : -1);
          for (let i = 1; i < Math.max(rowDiff, colDiff); i++) {
            if (board[fromRow + i * stepRow][fromCol + i * stepCol]) return false;
          }
          return true;
        }
        return false;

      case 'k':
        return rowDiff <= 1 && colDiff <= 1 && (rowDiff + colDiff > 0);

      default:
        return false;
    }
  };

  const handleSquareClick = (row, col) => {
    if (gameStatus !== 'playing') return;

    if (selectedSquare) {
      const [fromRow, fromCol] = selectedSquare;
      const piece = board[fromRow][fromCol];
      
      if (row === fromRow && col === fromCol) {
        setSelectedSquare(null);
        return;
      }

      if (piece && 
          ((currentPlayer === 'white' && isWhitePiece(piece)) ||
           (currentPlayer === 'black' && isBlackPiece(piece))) &&
          isValidMove(fromRow, fromCol, row, col, piece)) {
        
        const newBoard = board.map(r => [...r]);
        const capturedPiece = newBoard[row][col];
        newBoard[row][col] = piece;
        newBoard[fromRow][fromCol] = null;
        
        setBoard(newBoard);
        setSelectedSquare(null);
        setCurrentPlayer(currentPlayer === 'white' ? 'black' : 'white');

        if (capturedPiece && capturedPiece.toLowerCase() === 'k') {
          setGameStatus(`${currentPlayer} wins!`);
        }
      } else {
        setSelectedSquare(null);
      }
    } else {
      const piece = board[row][col];
      if (piece && 
          ((currentPlayer === 'white' && isWhitePiece(piece)) ||
           (currentPlayer === 'black' && isBlackPiece(piece)))) {
        setSelectedSquare([row, col]);
      }
    }
  };

  const resetGame = () => {
    setBoard(initialBoard.map(row => [...row]));
    setSelectedSquare(null);
    setCurrentPlayer('white');
    setGameStatus('playing');
  };

  return (
    <div style={{ 
      display: 'flex', 
      flexDirection: 'column', 
      alignItems: 'center', 
      padding: '20px',
      fontFamily: 'Arial, sans-serif'
    }}>
      <h2 style={{ margin: '0 0 10px 0', color: '#333' }}>Chess Game</h2>
      
      <div style={{ 
        marginBottom: '10px', 
        fontSize: '16px',
        fontWeight: 'bold'
      }}>
        {gameStatus === 'playing' ? `Current Player: ${currentPlayer}` : gameStatus}
      </div>

      <div style={{
        display: 'grid',
        gridTemplate
----------------------------------------


================================================================================
GAME GENERATION: flappy bird - 2025-08-09 13:34:58.374086
================================================================================
FULL CLAUDE GENERATED CODE:
----------------------------------------
import React, { useState, useEffect, useRef, useCallback } from 'react';

const GameZone = ({ currentGame }) => {
  const canvasRef = useRef(null);
  const gameLoopRef = useRef(null);
  const [score, setScore] = useState(0);
  const [gameState, setGameState] = useState('waiting');
  const [bird, setBird] = useState({ y: 150, velocity: 0 });
  const [pipes, setPipes] = useState([]);

  const CANVAS_WIDTH = 400;
  const CANVAS_HEIGHT = 300;
  const BIRD_SIZE = 20;
  const PIPE_WIDTH = 50;
  const PIPE_GAP = 100;
  const GRAVITY = 0.5;
  const JUMP_STRENGTH = -8;
  const PIPE_SPEED = 2;

  const resetGame = useCallback(() => {
    setBird({ y: 150, velocity: 0 });
    setPipes([]);
    setScore(0);
    setGameState('waiting');
  }, []);

  const startGame = useCallback(() => {
    setGameState('playing');
    setBird(prev => ({ ...prev, velocity: JUMP_STRENGTH }));
  }, []);

  const jump = useCallback(() => {
    if (gameState === 'playing') {
      setBird(prev => ({ ...prev, velocity: JUMP_STRENGTH }));
    } else if (gameState === 'waiting') {
      startGame();
    }
  }, [gameState, startGame]);

  const checkCollision = useCallback((birdY, pipes) => {
    if (birdY < 0 || birdY + BIRD_SIZE > CANVAS_HEIGHT) {
      return true;
    }

    const birdX = 50;
    for (let pipe of pipes) {
      if (birdX + BIRD_SIZE > pipe.x && birdX < pipe.x + PIPE_WIDTH) {
        if (birdY < pipe.topHeight || birdY + BIRD_SIZE > pipe.topHeight + PIPE_GAP) {
          return true;
        }
      }
    }
    return false;
  }, []);

  const updateGame = useCallback(() => {
    if (gameState !== 'playing') return;

    setBird(prev => {
      const newY = prev.y + prev.velocity;
      const newVelocity = prev.velocity + GRAVITY;
      return { y: newY, velocity: newVelocity };
    });

    setPipes(prev => {
      let newPipes = prev.map(pipe => ({ ...pipe, x: pipe.x - PIPE_SPEED }))
                        .filter(pipe => pipe.x + PIPE_WIDTH > 0);

      if (newPipes.length === 0 || newPipes[newPipes.length - 1].x < CANVAS_WIDTH - 200) {
        const topHeight = Math.random() * (CANVAS_HEIGHT - PIPE_GAP - 40) + 20;
        newPipes.push({
          x: CANVAS_WIDTH,
          topHeight: topHeight,
          scored: false
        });
      }

      newPipes.forEach(pipe => {
        if (!pipe.scored && pipe.x + PIPE_WIDTH < 50) {
          pipe.scored = true;
          setScore(s => s + 1);
        }
      });

      return newPipes;
    });
  }, [gameState]);

  useEffect(() => {
    const handleKeyPress = (e) => {
      if (e.code === 'Space') {
        e.preventDefault();
        jump();
      }
    };

    window.addEventListener('keydown', handleKeyPress);
    return () => window.removeEventListener('keydown', handleKeyPress);
  }, [jump]);

  useEffect(() => {
    if (gameState === 'playing') {
      if (checkCollision(bird.y, pipes)) {
        setGameState('gameOver');
        return;
      }
    }
  }, [bird.y, pipes, gameState, checkCollision]);

  useEffect(() => {
    if (gameState === 'playing') {
      gameLoopRef.current = setInterval(updateGame, 16);
    } else {
      if (gameLoopRef.current) {
        clearInterval(gameLoopRef.current);
      }
    }

    return () => {
      if (gameLoopRef.current) {
        clearInterval(gameLoopRef.current);
      }
    };
  }, [gameState, updateGame]);

  useEffect(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;

    const ctx = canvas.getContext('2d');
    ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

    ctx.fillStyle = '#87CEEB';
    ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

    pipes.forEach(pipe => {
      ctx.fillStyle = '#32CD32';
      ctx.fillRect(pipe.x, 0, PIPE_WIDTH, pipe.topHeight);
      ctx.fillRect(pipe.x, pipe.topHeight + PIPE_GAP, PIPE_WIDTH, CANVAS_HEIGHT - pipe.topHeight - PIPE_GAP);
    });

    ctx.fillStyle = '#FFD700';
    ctx.fillRect(50 - BIRD_SIZE/2, bird.y, BIRD_SIZE, BIRD_SIZE);

    ctx.fillStyle = '#000';
    ctx.font = '20px Arial';
    ctx.fillText(`Score: ${score}`, 10, 30);

    if (gameState === 'waiting') {
      ctx.fillStyle = 'rgba(0,0,0,0.7)';
      ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
      ctx.fillStyle = '#FFF';
      ctx.font = '24px Arial';
      ctx.textAlign = 'center';
      ctx.fillText('Click or Press Space to Start', CANVAS_WIDTH/2, CANVAS_HEIGHT/2);
      ctx.textAlign = 'left';
    }

    if (gameState === 'gameOver') {
      ctx.fillStyle = 'rgba(255,0,0,0.7)';
      ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
      ctx.fillStyle = '#FFF';
      ctx.font = '24px Arial';
      ctx.textAlign = 'center';
      ctx.fillText('Game Over!', CANVAS_WIDTH/2, CANVAS_HEIGHT/2 - 20);
      ctx.fillText(`Final Score: ${score}`, CANVAS_WIDTH/2, CANVAS_HEIGHT/2 + 20);
      ctx.textAlign = 'left';
    }
  }, [bird, pipes, score, gameState]);

  return (
    <div style={{ 
      display: 'flex', 
      flexDirection: 'column', 
      alignItems: 'center', 
      padding: '20px',
      fontFamily: 'Arial, sans-serif'
    }}>
      <h2 style={{ margin: '0 0 20px 0', color: '#333' }}>Flappy Bird</h2>
      
      <canvas
        ref={canvasRef}
        width={CANVAS_WIDTH}
        height={CANVAS_HEIGHT}
        onClick={jump}
        style={{ 
          border: '2px solid #333',
          cursor: 'pointer',
          display: 'block'
        }}
      />
      
      <div style={{ marginTop: '20px' }}>
        <button
          onClick={resetGame}
          style={{
            padding: '10px 20px',
            fontSize: '16px',
            backgroundColor: '#4CAF50',
            color: 'white',
            border: 'none',
            borderRadius: '5px',
            cursor: 'pointer',
            marginRight: '10px'
          }}
----------------------------------------


================================================================================
GAME GENERATION: pacmanbutmakethespacebarbarelymakeujump - 2025-08-09 13:46:31.135871
================================================================================
FULL CLAUDE GENERATED CODE:
----------------------------------------
import React, { useState, useEffect, useRef, useCallback } from 'react';

const GameZone = ({ currentGame }) => {
  const canvasRef = useRef(null);
  const [gameState, setGameState] = useState('playing');
  const [score, setScore] = useState(0);
  const [player, setPlayer] = useState({ x: 50, y: 250, velY: 0, onGround: true });
  const [dots, setDots] = useState([]);
  const [ghosts, setGhosts] = useState([]);

  const initializeGame = useCallback(() => {
    const newDots = [];
    for (let i = 0; i < 20; i++) {
      newDots.push({
        x: 100 + i * 15,
        y: 260,
        collected: false
      });
    }
    
    const newGhosts = [
      { x: 200, y: 240, dx: 1 },
      { x: 300, y: 240, dx: -1 }
    ];

    setDots(newDots);
    setGhosts(newGhosts);
    setPlayer({ x: 50, y: 250, velY: 0, onGround: true });
    setScore(0);
    setGameState('playing');
  }, []);

  useEffect(() => {
    initializeGame();
  }, [initializeGame]);

  useEffect(() => {
    const handleKeyPress = (e) => {
      if (e.code === 'Space' && player.onGround) {
        e.preventDefault();
        setPlayer(prev => ({ ...prev, velY: -8, onGround: false }));
      }
    };

    window.addEventListener('keydown', handleKeyPress);
    return () => window.removeEventListener('keydown', handleKeyPress);
  }, [player.onGround]);

  useEffect(() => {
    if (gameState !== 'playing') return;

    const gameLoop = setInterval(() => {
      setPlayer(prev => {
        let newY = prev.y + prev.velY;
        let newVelY = prev.velY + 0.5;
        let newOnGround = prev.onGround;

        if (newY >= 250) {
          newY = 250;
          newVelY = 0;
          newOnGround = true;
        } else {
          newOnGround = false;
        }

        return { ...prev, y: newY, velY: newVelY, onGround: newOnGround };
      });

      setGhosts(prev => prev.map(ghost => {
        let newX = ghost.x + ghost.dx;
        let newDx = ghost.dx;

        if (newX <= 80 || newX >= 350) {
          newDx = -ghost.dx;
          newX = ghost.x + newDx;
        }

        return { ...ghost, x: newX, dx: newDx };
      }));

      setDots(prev => {
        const newDots = prev.map(dot => {
          if (!dot.collected && 
              Math.abs(dot.x - player.x) < 15 && 
              Math.abs(dot.y - player.y) < 15) {
            setScore(s => s + 10);
            return { ...dot, collected: true };
          }
          return dot;
        });
        return newDots;
      });

      ghosts.forEach(ghost => {
        if (Math.abs(ghost.x - player.x) < 20 && Math.abs(ghost.y - player.y) < 20) {
          setGameState('gameOver');
        }
      });

      if (dots.every(dot => dot.collected)) {
        setGameState('won');
      }
    }, 16);

    return () => clearInterval(gameLoop);
  }, [gameState, player, ghosts, dots]);

  useEffect(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;

    const ctx = canvas.getContext('2d');
    ctx.clearRect(0, 0, 400, 300);

    ctx.fillStyle = '#000';
    ctx.fillRect(0, 0, 400, 300);

    ctx.fillStyle = '#0f0';
    ctx.fillRect(0, 270, 400, 30);

    ctx.fillStyle = '#ff0';
    ctx.beginPath();
    ctx.arc(player.x, player.y, 10, 0.2 * Math.PI, 1.8 * Math.PI);
    ctx.lineTo(player.x, player.y);
    ctx.fill();

    dots.forEach(dot => {
      if (!dot.collected) {
        ctx.fillStyle = '#ff0';
        ctx.beginPath();
        ctx.arc(dot.x, dot.y, 3, 0, 2 * Math.PI);
        ctx.fill();
      }
    });

    ghosts.forEach(ghost => {
      ctx.fillStyle = '#f0f';
      ctx.fillRect(ghost.x - 10, ghost.y - 10, 20, 20);
      ctx.fillStyle = '#fff';
      ctx.fillRect(ghost.x - 6, ghost.y - 8, 4, 4);
      ctx.fillRect(ghost.x + 2, ghost.y - 8, 4, 4);
    });
  }, [player, dots, ghosts]);

  return (
    <div style={{ display: 'flex', flexDirection: 'column', alignItems: 'center', padding: '20px' }}>
      <h2 style={{ margin: '0 0 10px 0', color: '#333' }}>Pac-Jump</h2>
      <div style={{ marginBottom: '10px', fontSize: '18px', fontWeight: 'bold' }}>
        Score: {score}
      </div>
      <canvas
        ref={canvasRef}
        width={400}
        height={300}
        style={{ border: '2px solid #333', backgroundColor: '#000' }}
      />
      <div style={{ marginTop: '10px', textAlign: 'center' }}>
        <div style={{ marginBottom: '10px', fontSize: '14px' }}>
          Press SPACEBAR to barely jump! Collect dots, avoid ghosts!
        </div>
        {gameState === 'gameOver' && (
          <div style={{ color: 'red', fontWeight: 'bold', marginBottom: '10px' }}>
            Game Over! Ghost got you!
          </div>
        )}
        {gameState === 'won' && (
          <div style={{ color: 'green', fontWeight: 'bold', marginBottom: '10px' }}>
            You Won! All dots collected!
          </div>
        )}
        <button
          onClick={initializeGame}
          style={{
            padding: '10px 20px',
            fontSize: '16px',
            backgroundColor: '#4CAF50',
            color: 'white',
            border: 'none',
            borderRadius: '5px',
            cursor: 'pointer'
          }}
        >
          {gameState === 'playing' ? 'Restart' : 'Play Again'}
        </button>
      </div>
    </div>
  );
};

export default GameZone;
----------------------------------------


================================================================================
GAME GENERATION: boxinggame - 2025-08-09 13:47:17.378117
================================================================================
FULL CLAUDE GENERATED CODE:
----------------------------------------
import React, { useState, useEffect, useCallback } from 'react';

const GameZone = ({ currentGame }) => {
  const [playerHealth, setPlayerHealth] = useState(100);
  const [opponentHealth, setOpponentHealth] = useState(100);
  const [playerStamina, setPlayerStamina] = useState(100);
  const [gameState, setGameState] = useState('ready'); // ready, fighting, gameOver
  const [message, setMessage] = useState('Press Fight to start!');
  const [round, setRound] = useState(1);
  const [playerWins, setPlayerWins] = useState(0);
  const [opponentWins, setOpponentWins] = useState(0);
  const [isPlayerTurn, setIsPlayerTurn] = useState(true);
  const [actionCooldown, setActionCooldown] = useState(false);

  const resetGame = useCallback(() => {
    setPlayerHealth(100);
    setOpponentHealth(100);
    setPlayerStamina(100);
    setGameState('ready');
    setMessage('Press Fight to start!');
    setRound(1);
    setIsPlayerTurn(true);
    setActionCooldown(false);
  }, []);

  const resetMatch = useCallback(() => {
    setPlayerHealth(100);
    setOpponentHealth(100);
    setPlayerStamina(100);
    setGameState('ready');
    setMessage('Press Fight to start next round!');
    setIsPlayerTurn(true);
    setActionCooldown(false);
  }, []);

  const getDamage = (min, max) => Math.floor(Math.random() * (max - min + 1)) + min;

  const playerAttack = (attackType) => {
    if (gameState !== 'fighting' || !isPlayerTurn || actionCooldown || playerStamina < 10) return;

    setActionCooldown(true);
    let damage = 0;
    let staminaCost = 0;

    switch (attackType) {
      case 'jab':
        damage = getDamage(8, 15);
        staminaCost = 10;
        break;
      case 'hook':
        damage = getDamage(12, 20);
        staminaCost = 20;
        break;
      case 'uppercut':
        damage = getDamage(15, 25);
        staminaCost = 30;
        break;
      default:
        return;
    }

    setPlayerStamina(prev => Math.max(0, prev - staminaCost));
    setOpponentHealth(prev => Math.max(0, prev - damage));
    setMessage(`You hit with a ${attackType} for ${damage} damage!`);
    setIsPlayerTurn(false);

    setTimeout(() => {
      setActionCooldown(false);
    }, 800);
  };

  const defend = () => {
    if (gameState !== 'fighting' || !isPlayerTurn || actionCooldown) return;

    setActionCooldown(true);
    setPlayerStamina(prev => Math.min(100, prev + 15));
    setMessage('You defend and recover stamina!');
    setIsPlayerTurn(false);

    setTimeout(() => {
      setActionCooldown(false);
    }, 800);
  };

  const startFight = () => {
    if (gameState === 'ready') {
      setGameState('fighting');
      setMessage('Fight!');
      setIsPlayerTurn(true);
    }
  };

  useEffect(() => {
    if (gameState === 'fighting' && !isPlayerTurn && !actionCooldown) {
      const opponentAttack = () => {
        const attacks = ['jab', 'hook', 'uppercut'];
        const attack = attacks[Math.floor(Math.random() * attacks.length)];
        let damage = 0;

        switch (attack) {
          case 'jab':
            damage = getDamage(6, 12);
            break;
          case 'hook':
            damage = getDamage(10, 16);
            break;
          case 'uppercut':
            damage = getDamage(12, 20);
            break;
        }

        setPlayerHealth(prev => Math.max(0, prev - damage));
        setMessage(`Opponent hits you with a ${attack} for ${damage} damage!`);
        setIsPlayerTurn(true);
      };

      const timer = setTimeout(opponentAttack, 1200);
      return () => clearTimeout(timer);
    }
  }, [isPlayerTurn, gameState, actionCooldown]);

  useEffect(() => {
    if (playerHealth <= 0 || opponentHealth <= 0) {
      setGameState('gameOver');
      if (playerHealth <= 0) {
        setOpponentWins(prev => prev + 1);
        setMessage('You lose this round!');
      } else {
        setPlayerWins(prev => prev + 1);
        setMessage('You win this round!');
      }
      setRound(prev => prev + 1);
    }
  }, [playerHealth, opponentHealth]);

  useEffect(() => {
    if (playerStamina < 100 && gameState === 'fighting') {
      const staminaTimer = setInterval(() => {
        setPlayerStamina(prev => Math.min(100, prev + 2));
      }, 1000);
      return () => clearInterval(staminaTimer);
    }
  }, [playerStamina, gameState]);

  const getHealthBarColor = (health) => {
    if (health > 60) return '#4CAF50';
    if (health > 30) return '#FFC107';
    return '#F44336';
  };

  return (
    <div style={{
      display: 'flex',
      flexDirection: 'column',
      alignItems: 'center',
      padding: '20px',
      fontFamily: 'Arial, sans-serif',
      backgroundColor: '#1a1a1a',
      color: 'white',
      minHeight: '100vh'
    }}>
      <h1 style={{ marginBottom: '20px', color: '#FFD700' }}>Boxing Game</h1>
      
      <div style={{
        display: 'flex',
        justifyContent: 'space-between',
        width: '400px',
        marginBottom: '20px'
      }}>
        <div style={{ textAlign: 'center' }}>
          <h3>You</h3>
          <div>Wins: {playerWins}</div>
        </div>
        <div style={{ textAlign: 'center' }}>
          <h3>Round {round}</h3>
        </div>
        <div style={{ textAlign: 'center' }}>
          <h3>Opponent</h3>
          <div>Wins: {opponentWins}</div>
        </div>
      </div>

      <div style={{
        width: '400px',
        height: '300px',
        border: '3px solid #333',
        borderRadius: '10px',
        backgroundColor: '#2a2a2a',
        display: 'flex',
        flexDirection: 'column',
        justifyContent: 'space-between',
        padding: '20px',
        marginBottom: '20px'
      }}>
        <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
          <div style={{ textAlign: 'center' }}>
            <div style={{ fontSize: '60px', marginBottom: '10px' }}>ü•ä</div>
            <div>YOU</div>
            <div style={{
              width: '80px',
              height: '10px',
              backgroundColor: '#333',
              borderRadius: '5px',
              overflow: 'hidden',
              margin: '5px auto'
            }}>
              <div style={{
                width: `
----------------------------------------


================================================================================
GAME GENERATION: Space Runner - 2025-08-09 13:50:37.586564
================================================================================
FULL CLAUDE GENERATED CODE:
----------------------------------------
import React, { useState, useEffect, useCallback } from 'react';

const GameZone = ({ currentGame }) => {
  const [gameState, setGameState] = useState('menu');
  const [player, setPlayer] = useState({ x: 50, y: 150 });
  const [obstacles, setObstacles] = useState([]);
  const [score, setScore] = useState(0);
  const [gameSpeed, setGameSpeed] = useState(2);

  const resetGame = useCallback(() => {
    setPlayer({ x: 50, y: 150 });
    setObstacles([]);
    setScore(0);
    setGameSpeed(2);
    setGameState('playing');
  }, []);

  const gameOver = useCallback(() => {
    setGameState('gameOver');
  }, []);

  useEffect(() => {
    if (gameState !== 'playing') return;

    const gameLoop = setInterval(() => {
      setObstacles(prev => {
        const newObstacles = prev
          .map(obs => ({ ...obs, x: obs.x - gameSpeed }))
          .filter(obs => obs.x > -20);

        if (Math.random() < 0.02) {
          newObstacles.push({
            x: 400,
            y: Math.random() * 200 + 50,
            width: 20,
            height: 40
          });
        }

        const collision = newObstacles.some(obs => 
          player.x < obs.x + obs.width &&
          player.x + 20 > obs.x &&
          player.y < obs.y + obs.height &&
          player.y + 20 > obs.y
        );

        if (collision) {
          gameOver();
        }

        return newObstacles;
      });

      setScore(prev => prev + 1);
      setGameSpeed(prev => prev + 0.001);
    }, 50);

    return () => clearInterval(gameLoop);
  }, [gameState, player, gameSpeed, gameOver]);

  useEffect(() => {
    if (gameState !== 'playing') return;

    const handleKeyPress = (e) => {
      if (e.key === 'ArrowUp') {
        setPlayer(prev => ({ ...prev, y: Math.max(0, prev.y - 15) }));
      } else if (e.key === 'ArrowDown') {
        setPlayer(prev => ({ ...prev, y: Math.min(280, prev.y + 15) }));
      }
    };

    window.addEventListener('keydown', handleKeyPress);
    return () => window.removeEventListener('keydown', handleKeyPress);
  }, [gameState]);

  const containerStyle = {
    width: '400px',
    height: '300px',
    border: '2px solid #333',
    position: 'relative',
    backgroundColor: '#001122',
    overflow: 'hidden',
    margin: '20px auto',
    fontFamily: 'Arial, sans-serif'
  };

  const playerStyle = {
    position: 'absolute',
    left: `${player.x}px`,
    top: `${player.y}px`,
    width: '20px',
    height: '20px',
    backgroundColor: '#00ff00',
    borderRadius: '50%',
    transition: 'top 0.1s ease'
  };

  const obstacleStyle = (obs) => ({
    position: 'absolute',
    left: `${obs.x}px`,
    top: `${obs.y}px`,
    width: `${obs.width}px`,
    height: `${obs.height}px`,
    backgroundColor: '#ff0000'
  });

  const overlayStyle = {
    position: 'absolute',
    top: 0,
    left: 0,
    width: '100%',
    height: '100%',
    backgroundColor: 'rgba(0,0,0,0.8)',
    display: 'flex',
    flexDirection: 'column',
    justifyContent: 'center',
    alignItems: 'center',
    color: 'white',
    textAlign: 'center'
  };

  const buttonStyle = {
    padding: '10px 20px',
    fontSize: '16px',
    backgroundColor: '#0066cc',
    color: 'white',
    border: 'none',
    borderRadius: '5px',
    cursor: 'pointer',
    margin: '5px'
  };

  const scoreStyle = {
    position: 'absolute',
    top: '10px',
    right: '10px',
    color: 'white',
    fontSize: '16px',
    fontWeight: 'bold'
  };

  if (gameState === 'menu') {
    return (
      <div style={containerStyle}>
        <div style={overlayStyle}>
          <h2>Space Runner</h2>
          <p>Use arrow keys to avoid obstacles!</p>
          <button style={buttonStyle} onClick={resetGame}>
            Start Game
          </button>
        </div>
      </div>
    );
  }

  if (gameState === 'gameOver') {
    return (
      <div style={containerStyle}>
        <div style={overlayStyle}>
          <h2>Game Over!</h2>
          <p>Final Score: {score}</p>
          <button style={buttonStyle} onClick={resetGame}>
            Play Again
          </button>
          <button style={buttonStyle} onClick={() => setGameState('menu')}>
            Main Menu
          </button>
        </div>
      </div>
    );
  }

  return (
    <div style={containerStyle}>
      <div style={scoreStyle}>Score: {score}</div>
      <div style={playerStyle}></div>
      {obstacles.map((obs, index) => (
        <div key={index} style={obstacleStyle(obs)}></div>
      ))}
    </div>
  );
};

export default GameZone;
----------------------------------------


================================================================================
GAME GENERATION: Space Runner - 2025-08-09 13:50:41.000205
================================================================================
FULL CLAUDE GENERATED CODE:
----------------------------------------
import React, { useState, useEffect, useCallback, useRef } from 'react';

const GameZone = ({ currentGame }) => {
  const [gameState, setGameState] = useState('playing');
  const [score, setScore] = useState(0);
  const [playerY, setPlayerY] = useState(150);
  const [obstacles, setObstacles] = useState([]);
  const [stars, setStars] = useState([]);
  const gameLoopRef = useRef();
  const keysRef = useRef({ up: false, down: false });

  const GAME_WIDTH = 400;
  const GAME_HEIGHT = 300;
  const PLAYER_SIZE = 20;
  const OBSTACLE_WIDTH = 15;
  const OBSTACLE_HEIGHT = 40;
  const PLAYER_SPEED = 3;
  const OBSTACLE_SPEED = 2;

  const initializeGame = useCallback(() => {
    setGameState('playing');
    setScore(0);
    setPlayerY(150);
    setObstacles([]);
    setStars(Array.from({ length: 20 }, (_, i) => ({
      id: i,
      x: Math.random() * GAME_WIDTH,
      y: Math.random() * GAME_HEIGHT,
      size: Math.random() * 2 + 1
    })));
  }, []);

  const checkCollision = useCallback((player, obstacle) => {
    return player.x < obstacle.x + obstacle.width &&
           player.x + player.width > obstacle.x &&
           player.y < obstacle.y + obstacle.height &&
           player.y + player.height > obstacle.y;
  }, []);

  const gameLoop = useCallback(() => {
    if (gameState !== 'playing') return;

    setPlayerY(prevY => {
      let newY = prevY;
      if (keysRef.current.up && newY > 0) newY -= PLAYER_SPEED;
      if (keysRef.current.down && newY < GAME_HEIGHT - PLAYER_SIZE) newY += PLAYER_SPEED;
      return newY;
    });

    setObstacles(prevObstacles => {
      let newObstacles = prevObstacles.map(obs => ({
        ...obs,
        x: obs.x - OBSTACLE_SPEED
      })).filter(obs => obs.x > -OBSTACLE_WIDTH);

      if (Math.random() < 0.02) {
        newObstacles.push({
          id: Date.now(),
          x: GAME_WIDTH,
          y: Math.random() * (GAME_HEIGHT - OBSTACLE_HEIGHT),
          width: OBSTACLE_WIDTH,
          height: OBSTACLE_HEIGHT
        });
      }

      return newObstacles;
    });

    setStars(prevStars => 
      prevStars.map(star => ({
        ...star,
        x: star.x - 0.5 < 0 ? GAME_WIDTH : star.x - 0.5
      }))
    );

    setScore(prevScore => prevScore + 1);
  }, [gameState]);

  useEffect(() => {
    if (gameState === 'playing') {
      const player = { x: 20, y: playerY, width: PLAYER_SIZE, height: PLAYER_SIZE };
      
      for (let obstacle of obstacles) {
        if (checkCollision(player, obstacle)) {
          setGameState('gameOver');
          break;
        }
      }
    }
  }, [playerY, obstacles, gameState, checkCollision]);

  useEffect(() => {
    const handleKeyDown = (e) => {
      if (e.code === 'ArrowUp' || e.code === 'KeyW') {
        keysRef.current.up = true;
        e.preventDefault();
      }
      if (e.code === 'ArrowDown' || e.code === 'KeyS') {
        keysRef.current.down = true;
        e.preventDefault();
      }
    };

    const handleKeyUp = (e) => {
      if (e.code === 'ArrowUp' || e.code === 'KeyW') {
        keysRef.current.up = false;
      }
      if (e.code === 'ArrowDown' || e.code === 'KeyS') {
        keysRef.current.down = false;
      }
    };

    window.addEventListener('keydown', handleKeyDown);
    window.addEventListener('keyup', handleKeyUp);

    return () => {
      window.removeEventListener('keydown', handleKeyDown);
      window.removeEventListener('keyup', handleKeyUp);
    };
  }, []);

  useEffect(() => {
    initializeGame();
  }, [initializeGame]);

  useEffect(() => {
    if (gameState === 'playing') {
      gameLoopRef.current = setInterval(gameLoop, 16);
    } else {
      clearInterval(gameLoopRef.current);
    }

    return () => clearInterval(gameLoopRef.current);
  }, [gameState, gameLoop]);

  return (
    <div style={{
      display: 'flex',
      flexDirection: 'column',
      alignItems: 'center',
      padding: '20px',
      fontFamily: 'Arial, sans-serif'
    }}>
      <h2 style={{ margin: '0 0 10px 0', color: '#fff' }}>Space Runner</h2>
      
      <div style={{
        display: 'flex',
        justifyContent: 'space-between',
        width: `${GAME_WIDTH}px`,
        marginBottom: '10px',
        color: '#fff'
      }}>
        <div>Score: {score}</div>
        <button 
          onClick={initializeGame}
          style={{
            padding: '5px 15px',
            backgroundColor: '#4CAF50',
            color: 'white',
            border: 'none',
            borderRadius: '3px',
            cursor: 'pointer'
          }}
        >
          Restart
        </button>
      </div>

      <div style={{
        position: 'relative',
        width: `${GAME_WIDTH}px`,
        height: `${GAME_HEIGHT}px`,
        backgroundColor: '#000',
        border: '2px solid #333',
        overflow: 'hidden'
      }}>
        {stars.map(star => (
          <div
            key={star.id}
            style={{
              position: 'absolute',
              left: `${star.x}px`,
              top: `${star.y}px`,
              width: `${star.size}px`,
              height: `${star.size}px`,
              backgroundColor: '#fff',
              borderRadius: '50%'
            }}
          />
        ))}

        <div style={{
          position: 'absolute',
          left: '20px',
          top: `${playerY}px`,
          width: `${PLAYER_SIZE}px`,
          height: `${PLAYER_SIZE}px`,
          backgroundColor: '#00ff00',
          clipPath: 'polygon(0% 50%, 100% 0%, 80% 50%, 100% 100%)'
        }} />

        {obstacles.map(obstacle => (
          <div
            key={obstacle.id}
            style={{
              position: 'absolute',
              left: `${obstacle.x}px`,
              top: `${obstacle.y}px`,
              width: `${obstacle.width}px`,
              height: `${obstacle.height}px`,
              backgroundColor: '#ff4444'
            }}
          />
        ))}

        {gameState === 'gameOver' && (
          <div style={{
            position: 'absolute',
            top: '50%',
            left: '50%',
            transform: 'translate(-50%, -50%)',
            backgroundColor: 'rgba(0, 0, 0, 0.8)',
            color: '#fff',
            
----------------------------------------


================================================================================
GAME GENERATION: Jungle Jump - 2025-08-09 13:51:02.021997
================================================================================
FULL CLAUDE GENERATED CODE:
----------------------------------------
import React, { useState, useEffect, useCallback } from 'react';

const GameZone = ({ currentGame }) => {
  const [gameState, setGameState] = useState('menu');
  const [playerY, setPlayerY] = useState(250);
  const [playerVelocity, setPlayerVelocity] = useState(0);
  const [platforms, setPlatforms] = useState([]);
  const [score, setScore] = useState(0);
  const [gameSpeed, setGameSpeed] = useState(2);

  const GRAVITY = 0.8;
  const JUMP_FORCE = -15;
  const PLAYER_SIZE = 20;
  const GROUND_Y = 270;

  const initializePlatforms = useCallback(() => {
    const initialPlatforms = [];
    for (let i = 0; i < 5; i++) {
      initialPlatforms.push({
        x: 500 + i * 200,
        y: Math.random() * 150 + 100,
        width: 80,
        height: 20,
        id: i
      });
    }
    return initialPlatforms;
  }, []);

  const resetGame = useCallback(() => {
    setPlayerY(250);
    setPlayerVelocity(0);
    setPlatforms(initializePlatforms());
    setScore(0);
    setGameSpeed(2);
    setGameState('playing');
  }, [initializePlatforms]);

  const startGame = () => {
    resetGame();
  };

  const jump = useCallback(() => {
    if (gameState === 'playing') {
      setPlayerVelocity(JUMP_FORCE);
    }
  }, [gameState]);

  useEffect(() => {
    const handleKeyPress = (e) => {
      if (e.code === 'Space' || e.code === 'ArrowUp') {
        e.preventDefault();
        jump();
      }
    };

    window.addEventListener('keydown', handleKeyPress);
    return () => window.removeEventListener('keydown', handleKeyPress);
  }, [jump]);

  useEffect(() => {
    if (gameState !== 'playing') return;

    const gameLoop = setInterval(() => {
      setPlayerY(prevY => {
        let newY = prevY + playerVelocity;
        
        if (newY >= GROUND_Y) {
          newY = GROUND_Y;
          setPlayerVelocity(0);
        }
        
        return newY;
      });

      setPlayerVelocity(prevVel => prevVel + GRAVITY);

      setPlatforms(prevPlatforms => {
        const newPlatforms = prevPlatforms.map(platform => ({
          ...platform,
          x: platform.x - gameSpeed
        })).filter(platform => platform.x > -100);

        if (newPlatforms.length < 5) {
          const lastPlatform = newPlatforms[newPlatforms.length - 1];
          const newX = lastPlatform ? lastPlatform.x + 200 : 500;
          newPlatforms.push({
            x: newX,
            y: Math.random() * 150 + 100,
            width: 80,
            height: 20,
            id: Date.now()
          });
        }

        return newPlatforms;
      });

      setScore(prevScore => prevScore + 1);
      
      if (score > 0 && score % 500 === 0) {
        setGameSpeed(prevSpeed => prevSpeed + 0.5);
      }
    }, 16);

    return () => clearInterval(gameLoop);
  }, [gameState, playerVelocity, gameSpeed, score]);

  useEffect(() => {
    if (gameState !== 'playing') return;

    platforms.forEach(platform => {
      if (
        50 < platform.x + platform.width &&
        50 + PLAYER_SIZE > platform.x &&
        playerY < platform.y + platform.height &&
        playerY + PLAYER_SIZE > platform.y &&
        playerVelocity > 0
      ) {
        setPlayerY(platform.y - PLAYER_SIZE);
        setPlayerVelocity(JUMP_FORCE * 0.8);
      }
    });

    if (playerY > 300) {
      setGameState('gameOver');
    }
  }, [playerY, platforms, playerVelocity, gameState]);

  if (gameState === 'menu') {
    return (
      <div style={{
        width: '400px',
        height: '300px',
        backgroundColor: '#87CEEB',
        display: 'flex',
        flexDirection: 'column',
        justifyContent: 'center',
        alignItems: 'center',
        fontFamily: 'Arial, sans-serif',
        position: 'relative'
      }}>
        <h1 style={{ color: '#2F4F2F', marginBottom: '20px' }}>üêí Jungle Jump</h1>
        <p style={{ color: '#2F4F2F', marginBottom: '20px', textAlign: 'center' }}>
          Press SPACE or ‚Üë to jump on platforms!<br />
          Avoid falling to the ground!
        </p>
        <button
          onClick={startGame}
          style={{
            padding: '10px 20px',
            fontSize: '18px',
            backgroundColor: '#32CD32',
            color: 'white',
            border: 'none',
            borderRadius: '5px',
            cursor: 'pointer'
          }}
        >
          Start Game
        </button>
      </div>
    );
  }

  if (gameState === 'gameOver') {
    return (
      <div style={{
        width: '400px',
        height: '300px',
        backgroundColor: '#87CEEB',
        display: 'flex',
        flexDirection: 'column',
        justifyContent: 'center',
        alignItems: 'center',
        fontFamily: 'Arial, sans-serif'
      }}>
        <h1 style={{ color: '#DC143C', marginBottom: '20px' }}>Game Over!</h1>
        <p style={{ color: '#2F4F2F', marginBottom: '20px' }}>Score: {score}</p>
        <button
          onClick={resetGame}
          style={{
            padding: '10px 20px',
            fontSize: '18px',
            backgroundColor: '#32CD32',
            color: 'white',
            border: 'none',
            borderRadius: '5px',
            cursor: 'pointer'
          }}
        >
          Play Again
        </button>
      </div>
    );
  }

  return (
    <div 
      style={{
        width: '400px',
        height: '300px',
        backgroundColor: '#87CEEB',
        position: 'relative',
        overflow: 'hidden',
        fontFamily: 'Arial, sans-serif'
      }}
      onClick={jump}
    >
      <div style={{
        position: 'absolute',
        top: '10px',
        left: '10px',
        color: '#2F4F2F',
        fontSize: '16px',
        fontWeight: 'bold'
      }}>
        Score: {score}
      </div>

      <div style={{
        position: 'absolute',
        top: '10px',
        right: '10px',
        color: '#2F4F2F',
        fontSize: '12px'
      }}>
        SPACE/‚Üë to Jump
      </div>

      <div
        style={{
          position: 'absolute',
          left: '50px',
          top: `${playerY}px`,
          width: `${PLAYER_SIZE}px`,
          height: `${PLAYER_SIZE}px`,
          backgroundColor: '#8B4513',
          borderRadius: '50%
----------------------------------------


================================================================================
GAME GENERATION: Jungle Jump - 2025-08-09 13:51:07.033367
================================================================================
FULL CLAUDE GENERATED CODE:
----------------------------------------
import React, { useState, useEffect, useCallback } from 'react';

const GameZone = ({ currentGame }) => {
  const [gameState, setGameState] = useState('playing');
  const [score, setScore] = useState(0);
  const [playerY, setPlayerY] = useState(200);
  const [playerVelY, setPlayerVelY] = useState(0);
  const [obstacles, setObstacles] = useState([]);
  const [gameTime, setGameTime] = useState(0);
  const [keys, setKeys] = useState({});

  const GRAVITY = 0.8;
  const JUMP_FORCE = -15;
  const GROUND_Y = 250;
  const PLAYER_SIZE = 30;
  const OBSTACLE_WIDTH = 20;
  const OBSTACLE_HEIGHT = 40;
  const GAME_WIDTH = 400;
  const GAME_HEIGHT = 300;

  const resetGame = useCallback(() => {
    setGameState('playing');
    setScore(0);
    setPlayerY(200);
    setPlayerVelY(0);
    setObstacles([]);
    setGameTime(0);
  }, []);

  const jump = useCallback(() => {
    if (playerY >= GROUND_Y - PLAYER_SIZE) {
      setPlayerVelY(JUMP_FORCE);
    }
  }, [playerY]);

  useEffect(() => {
    const handleKeyDown = (e) => {
      setKeys(prev => ({ ...prev, [e.code]: true }));
      if (e.code === 'Space' || e.code === 'ArrowUp') {
        e.preventDefault();
        jump();
      }
    };

    const handleKeyUp = (e) => {
      setKeys(prev => ({ ...prev, [e.code]: false }));
    };

    window.addEventListener('keydown', handleKeyDown);
    window.addEventListener('keyup', handleKeyUp);

    return () => {
      window.removeEventListener('keydown', handleKeyDown);
      window.removeEventListener('keyup', handleKeyUp);
    };
  }, [jump]);

  useEffect(() => {
    if (gameState !== 'playing') return;

    const gameLoop = setInterval(() => {
      setGameTime(prev => prev + 1);

      setPlayerY(prevY => {
        const newY = prevY + playerVelY;
        return Math.min(newY, GROUND_Y - PLAYER_SIZE);
      });

      setPlayerVelY(prevVel => {
        if (playerY >= GROUND_Y - PLAYER_SIZE && prevVel > 0) {
          return 0;
        }
        return prevVel + GRAVITY;
      });

      setObstacles(prevObstacles => {
        let newObstacles = prevObstacles
          .map(obs => ({ ...obs, x: obs.x - 3 }))
          .filter(obs => obs.x > -OBSTACLE_WIDTH);

        if (Math.random() < 0.02) {
          newObstacles.push({
            x: GAME_WIDTH,
            y: GROUND_Y - OBSTACLE_HEIGHT,
            width: OBSTACLE_WIDTH,
            height: OBSTACLE_HEIGHT
          });
        }

        const playerLeft = 50;
        const playerRight = playerLeft + PLAYER_SIZE;
        const playerTop = playerY;
        const playerBottom = playerY + PLAYER_SIZE;

        for (let obs of newObstacles) {
          if (playerRight > obs.x && 
              playerLeft < obs.x + obs.width && 
              playerBottom > obs.y && 
              playerTop < obs.y + obs.height) {
            setGameState('gameOver');
            break;
          }
        }

        return newObstacles;
      });

      setScore(prev => prev + 1);
    }, 16);

    return () => clearInterval(gameLoop);
  }, [gameState, playerY, playerVelY]);

  return (
    <div style={{
      display: 'flex',
      flexDirection: 'column',
      alignItems: 'center',
      padding: '20px',
      fontFamily: 'Arial, sans-serif'
    }}>
      <h2 style={{ margin: '0 0 10px 0', color: '#2d5a27' }}>Jungle Jump</h2>
      
      <div style={{ marginBottom: '10px', fontSize: '18px', fontWeight: 'bold' }}>
        Score: {score}
      </div>

      <div style={{
        position: 'relative',
        width: GAME_WIDTH,
        height: GAME_HEIGHT,
        backgroundColor: '#87CEEB',
        border: '3px solid #2d5a27',
        overflow: 'hidden'
      }}>
        <div style={{
          position: 'absolute',
          bottom: 0,
          width: '100%',
          height: '50px',
          backgroundColor: '#228B22'
        }} />

        <div style={{
          position: 'absolute',
          left: '50px',
          top: `${playerY}px`,
          width: `${PLAYER_SIZE}px`,
          height: `${PLAYER_SIZE}px`,
          backgroundColor: '#8B4513',
          borderRadius: '50%',
          border: '2px solid #654321'
        }} />

        {obstacles.map((obs, index) => (
          <div key={index} style={{
            position: 'absolute',
            left: `${obs.x}px`,
            top: `${obs.y}px`,
            width: `${obs.width}px`,
            height: `${obs.height}px`,
            backgroundColor: '#8B4513',
            border: '1px solid #654321'
          }} />
        ))}

        {gameState === 'gameOver' && (
          <div style={{
            position: 'absolute',
            top: '50%',
            left: '50%',
            transform: 'translate(-50%, -50%)',
            backgroundColor: 'rgba(0,0,0,0.8)',
            color: 'white',
            padding: '20px',
            borderRadius: '10px',
            textAlign: 'center'
          }}>
            <h3 style={{ margin: '0 0 10px 0' }}>Game Over!</h3>
            <p style={{ margin: '0 0 15px 0' }}>Final Score: {score}</p>
            <button onClick={resetGame} style={{
              padding: '10px 20px',
              fontSize: '16px',
              backgroundColor: '#228B22',
              color: 'white',
              border: 'none',
              borderRadius: '5px',
              cursor: 'pointer'
            }}>
              Play Again
            </button>
          </div>
        )}
      </div>

      <div style={{ marginTop: '10px', textAlign: 'center', fontSize: '14px' }}>
        <p>Press SPACE or UP ARROW to jump!</p>
        <button onClick={resetGame} style={{
          padding: '8px 16px',
          fontSize: '14px',
          backgroundColor: '#2d5a27',
          color: 'white',
          border: 'none',
          borderRadius: '5px',
          cursor: 'pointer',
          marginTop: '5px'
        }}>
          Restart Game
        </button>
      </div>
    </div>
  );
};

export default GameZone;
----------------------------------------


================================================================================
GAME GENERATION: Space Runner - 2025-08-09 13:51:30.882798
================================================================================
FULL CLAUDE GENERATED CODE:
----------------------------------------
import React, { useState, useEffect, useCallback } from 'react';

const GameZone = ({ currentGame }) => {
  const [gameState, setGameState] = useState('playing');
  const [score, setScore] = useState(0);
  const [playerY, setPlayerY] = useState(150);
  const [obstacles, setObstacles] = useState([]);
  const [gameSpeed, setGameSpeed] = useState(2);

  const resetGame = useCallback(() => {
    setGameState('playing');
    setScore(0);
    setPlayerY(150);
    setObstacles([]);
    setGameSpeed(2);
  }, []);

  useEffect(() => {
    if (gameState !== 'playing') return;

    const gameLoop = setInterval(() => {
      setObstacles(prev => {
        let newObstacles = prev.map(obs => ({
          ...obs,
          x: obs.x - gameSpeed
        })).filter(obs => obs.x > -50);

        if (Math.random() < 0.02) {
          newObstacles.push({
            x: 450,
            y: Math.random() * 200 + 50,
            width: 30,
            height: 30
          });
        }

        const collision = newObstacles.some(obs => 
          obs.x < 70 && obs.x > 20 && 
          obs.y < playerY + 30 && obs.y + obs.height > playerY
        );

        if (collision) {
          setGameState('gameOver');
        }

        return newObstacles;
      });

      setScore(prev => prev + 1);
      setGameSpeed(prev => prev + 0.001);
    }, 50);

    return () => clearInterval(gameLoop);
  }, [gameState, playerY, gameSpeed]);

  useEffect(() => {
    const handleKeyPress = (e) => {
      if (gameState !== 'playing') return;
      
      if (e.key === 'ArrowUp' || e.key === ' ') {
        setPlayerY(prev => Math.max(0, prev - 40));
      }
      if (e.key === 'ArrowDown') {
        setPlayerY(prev => Math.min(270, prev + 40));
      }
    };

    window.addEventListener('keydown', handleKeyPress);
    return () => window.removeEventListener('keydown', handleKeyPress);
  }, [gameState]);

  return (
    <div style={{
      width: '400px',
      height: '300px',
      border: '2px solid #333',
      position: 'relative',
      backgroundColor: '#001122',
      overflow: 'hidden',
      margin: '20px auto'
    }}>
      <div style={{
        position: 'absolute',
        top: '10px',
        left: '10px',
        color: '#fff',
        fontSize: '16px',
        fontFamily: 'monospace'
      }}>
        Score: {score}
      </div>

      <div style={{
        position: 'absolute',
        left: '50px',
        top: `${playerY}px`,
        width: '20px',
        height: '30px',
        backgroundColor: '#00ff00',
        clipPath: 'polygon(0% 50%, 100% 0%, 80% 50%, 100% 100%)'
      }} />

      {obstacles.map((obs, index) => (
        <div
          key={index}
          style={{
            position: 'absolute',
            left: `${obs.x}px`,
            top: `${obs.y}px`,
            width: `${obs.width}px`,
            height: `${obs.height}px`,
            backgroundColor: '#ff4444',
            borderRadius: '4px'
          }}
        />
      ))}

      {gameState === 'gameOver' && (
        <div style={{
          position: 'absolute',
          top: '50%',
          left: '50%',
          transform: 'translate(-50%, -50%)',
          backgroundColor: 'rgba(0,0,0,0.8)',
          color: '#fff',
          padding: '20px',
          borderRadius: '10px',
          textAlign: 'center',
          fontFamily: 'monospace'
        }}>
          <div style={{ fontSize: '18px', marginBottom: '10px' }}>
            Game Over!
          </div>
          <div style={{ marginBottom: '15px' }}>
            Final Score: {score}
          </div>
          <button
            onClick={resetGame}
            style={{
              padding: '8px 16px',
              backgroundColor: '#00ff00',
              border: 'none',
              borderRadius: '4px',
              cursor: 'pointer',
              fontSize: '14px'
            }}
          >
            Play Again
          </button>
        </div>
      )}

      <div style={{
        position: 'absolute',
        bottom: '10px',
        left: '10px',
        color: '#888',
        fontSize: '12px',
        fontFamily: 'monospace'
      }}>
        Use ‚Üë‚Üì or SPACE to move
      </div>
    </div>
  );
};

export default GameZone;
----------------------------------------


================================================================================
GAME GENERATION: Space Runner - 2025-08-09 13:51:31.814208
================================================================================
FULL CLAUDE GENERATED CODE:
----------------------------------------
import React, { useState, useEffect, useRef, useCallback } from 'react';

const GameZone = ({ currentGame }) => {
  const canvasRef = useRef(null);
  const animationRef = useRef(null);
  const keysRef = useRef({});
  
  const [gameState, setGameState] = useState({
    player: { x: 50, y: 150, width: 20, height: 20 },
    obstacles: [],
    score: 0,
    gameOver: false,
    speed: 2
  });

  const resetGame = useCallback(() => {
    setGameState({
      player: { x: 50, y: 150, width: 20, height: 20 },
      obstacles: [],
      score: 0,
      gameOver: false,
      speed: 2
    });
  }, []);

  const generateObstacle = useCallback(() => {
    return {
      x: 400,
      y: Math.random() * 260 + 20,
      width: 15,
      height: Math.random() * 40 + 20,
      id: Date.now()
    };
  }, []);

  const checkCollision = useCallback((rect1, rect2) => {
    return rect1.x < rect2.x + rect2.width &&
           rect1.x + rect1.width > rect2.x &&
           rect1.y < rect2.y + rect2.height &&
           rect1.y + rect1.height > rect2.y;
  }, []);

  const gameLoop = useCallback(() => {
    setGameState(prevState => {
      if (prevState.gameOver) return prevState;

      const newState = { ...prevState };
      
      if (keysRef.current.ArrowUp && newState.player.y > 0) {
        newState.player.y -= 3;
      }
      if (keysRef.current.ArrowDown && newState.player.y < 280) {
        newState.player.y += 3;
      }

      newState.obstacles = newState.obstacles
        .map(obstacle => ({ ...obstacle, x: obstacle.x - newState.speed }))
        .filter(obstacle => obstacle.x > -obstacle.width);

      if (Math.random() < 0.02) {
        newState.obstacles.push(generateObstacle());
      }

      for (let obstacle of newState.obstacles) {
        if (checkCollision(newState.player, obstacle)) {
          newState.gameOver = true;
          break;
        }
      }

      newState.score += 1;
      if (newState.score % 500 === 0) {
        newState.speed += 0.5;
      }

      return newState;
    });
  }, [generateObstacle, checkCollision]);

  const draw = useCallback(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;
    
    const ctx = canvas.getContext('2d');
    ctx.fillStyle = '#000033';
    ctx.fillRect(0, 0, 400, 300);

    ctx.fillStyle = '#00ff00';
    ctx.fillRect(gameState.player.x, gameState.player.y, gameState.player.width, gameState.player.height);

    ctx.fillStyle = '#ff0000';
    gameState.obstacles.forEach(obstacle => {
      ctx.fillRect(obstacle.x, obstacle.y, obstacle.width, obstacle.height);
    });

    ctx.fillStyle = '#ffffff';
    ctx.font = '16px Arial';
    ctx.fillText(`Score: ${gameState.score}`, 10, 25);

    if (gameState.gameOver) {
      ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
      ctx.fillRect(0, 0, 400, 300);
      ctx.fillStyle = '#ffffff';
      ctx.font = '24px Arial';
      ctx.fillText('Game Over!', 140, 140);
      ctx.font = '16px Arial';
      ctx.fillText(`Final Score: ${gameState.score}`, 140, 170);
    }
  }, [gameState]);

  useEffect(() => {
    const handleKeyDown = (e) => {
      keysRef.current[e.code] = true;
    };

    const handleKeyUp = (e) => {
      keysRef.current[e.code] = false;
    };

    window.addEventListener('keydown', handleKeyDown);
    window.addEventListener('keyup', handleKeyUp);

    return () => {
      window.removeEventListener('keydown', handleKeyDown);
      window.removeEventListener('keyup', handleKeyUp);
    };
  }, []);

  useEffect(() => {
    const animate = () => {
      gameLoop();
      draw();
      animationRef.current = requestAnimationFrame(animate);
    };

    animationRef.current = requestAnimationFrame(animate);

    return () => {
      if (animationRef.current) {
        cancelAnimationFrame(animationRef.current);
      }
    };
  }, [gameLoop, draw]);

  return (
    <div style={{ 
      display: 'flex', 
      flexDirection: 'column', 
      alignItems: 'center', 
      padding: '20px',
      fontFamily: 'Arial, sans-serif'
    }}>
      <h2 style={{ margin: '0 0 10px 0', color: '#333' }}>Space Runner</h2>
      <canvas
        ref={canvasRef}
        width={400}
        height={300}
        style={{
          border: '2px solid #333',
          backgroundColor: '#000033'
        }}
      />
      <div style={{ marginTop: '10px' }}>
        <p style={{ margin: '5px 0', fontSize: '14px' }}>
          Use arrow keys to move up and down. Avoid the red obstacles!
        </p>
        <button
          onClick={resetGame}
          style={{
            padding: '8px 16px',
            fontSize: '14px',
            backgroundColor: '#4CAF50',
            color: 'white',
            border: 'none',
            borderRadius: '4px',
            cursor: 'pointer'
          }}
        >
          Restart Game
        </button>
      </div>
    </div>
  );
};

export default GameZone;
----------------------------------------


================================================================================
GAME GENERATION: Jungle Jump - 2025-08-09 13:51:54.993644
================================================================================
FULL CLAUDE GENERATED CODE:
----------------------------------------
import React, { useState, useEffect, useCallback } from 'react';

const GameZone = ({ currentGame }) => {
  const [playerY, setPlayerY] = useState(250);
  const [playerVelocity, setPlayerVelocity] = useState(0);
  const [obstacles, setObstacles] = useState([]);
  const [score, setScore] = useState(0);
  const [gameOver, setGameOver] = useState(false);
  const [gameStarted, setGameStarted] = useState(false);

  const GRAVITY = 0.5;
  const JUMP_FORCE = -12;
  const GROUND_Y = 250;
  const PLAYER_SIZE = 20;
  const OBSTACLE_WIDTH = 15;
  const OBSTACLE_HEIGHT = 40;

  const jump = useCallback(() => {
    if (!gameStarted) {
      setGameStarted(true);
      return;
    }
    if (!gameOver && playerY >= GROUND_Y - PLAYER_SIZE) {
      setPlayerVelocity(JUMP_FORCE);
    }
  }, [gameOver, playerY, gameStarted]);

  const resetGame = () => {
    setPlayerY(GROUND_Y);
    setPlayerVelocity(0);
    setObstacles([]);
    setScore(0);
    setGameOver(false);
    setGameStarted(false);
  };

  useEffect(() => {
    const handleKeyPress = (e) => {
      if (e.code === 'Space' || e.key === ' ') {
        e.preventDefault();
        jump();
      }
    };

    window.addEventListener('keydown', handleKeyPress);
    return () => window.removeEventListener('keydown', handleKeyPress);
  }, [jump]);

  useEffect(() => {
    if (!gameStarted || gameOver) return;

    const gameLoop = setInterval(() => {
      setPlayerVelocity(prev => prev + GRAVITY);
      
      setPlayerY(prev => {
        const newY = prev + playerVelocity;
        return Math.min(newY, GROUND_Y);
      });

      setObstacles(prev => {
        let newObstacles = prev.map(obs => ({ ...obs, x: obs.x - 3 }))
          .filter(obs => obs.x > -OBSTACLE_WIDTH);

        if (newObstacles.length === 0 || newObstacles[newObstacles.length - 1].x < 200) {
          newObstacles.push({ x: 400, y: GROUND_Y - OBSTACLE_HEIGHT });
        }

        return newObstacles;
      });

      setScore(prev => prev + 1);
    }, 16);

    return () => clearInterval(gameLoop);
  }, [gameStarted, gameOver, playerVelocity]);

  useEffect(() => {
    if (!gameStarted || gameOver) return;

    const checkCollision = () => {
      const playerX = 50;
      const playerBottom = playerY + PLAYER_SIZE;

      for (let obstacle of obstacles) {
        if (playerX + PLAYER_SIZE > obstacle.x && 
            playerX < obstacle.x + OBSTACLE_WIDTH &&
            playerBottom > obstacle.y) {
          setGameOver(true);
          break;
        }
      }
    };

    checkCollision();
  }, [playerY, obstacles, gameStarted, gameOver]);

  return (
    <div style={{
      display: 'flex',
      flexDirection: 'column',
      alignItems: 'center',
      padding: '20px',
      fontFamily: 'Arial, sans-serif'
    }}>
      <h2 style={{ margin: '0 0 10px 0', color: '#2d5016' }}>Jungle Jump</h2>
      
      <div style={{
        position: 'relative',
        width: '400px',
        height: '300px',
        border: '2px solid #2d5016',
        backgroundColor: '#87ceeb',
        overflow: 'hidden',
        cursor: 'pointer'
      }} onClick={jump}>
        
        <div style={{
          position: 'absolute',
          bottom: '0',
          width: '100%',
          height: '50px',
          backgroundColor: '#228b22'
        }} />

        <div style={{
          position: 'absolute',
          left: '50px',
          top: `${playerY}px`,
          width: `${PLAYER_SIZE}px`,
          height: `${PLAYER_SIZE}px`,
          backgroundColor: '#8b4513',
          borderRadius: '50%',
          border: '2px solid #654321'
        }} />

        {obstacles.map((obstacle, index) => (
          <div key={index} style={{
            position: 'absolute',
            left: `${obstacle.x}px`,
            top: `${obstacle.y}px`,
            width: `${OBSTACLE_WIDTH}px`,
            height: `${OBSTACLE_HEIGHT}px`,
            backgroundColor: '#006400',
            border: '1px solid #004d00'
          }} />
        ))}

        {!gameStarted && (
          <div style={{
            position: 'absolute',
            top: '50%',
            left: '50%',
            transform: 'translate(-50%, -50%)',
            textAlign: 'center',
            color: '#2d5016',
            fontSize: '18px',
            fontWeight: 'bold'
          }}>
            Click or Press Space to Start!
          </div>
        )}

        {gameOver && (
          <div style={{
            position: 'absolute',
            top: '50%',
            left: '50%',
            transform: 'translate(-50%, -50%)',
            textAlign: 'center',
            backgroundColor: 'rgba(255, 255, 255, 0.9)',
            padding: '20px',
            borderRadius: '10px',
            border: '2px solid #2d5016'
          }}>
            <div style={{ color: '#d32f2f', fontSize: '20px', fontWeight: 'bold' }}>
              Game Over!
            </div>
            <div style={{ color: '#2d5016', margin: '10px 0' }}>
              Final Score: {Math.floor(score / 10)}
            </div>
            <button onClick={resetGame} style={{
              padding: '10px 20px',
              fontSize: '16px',
              backgroundColor: '#4caf50',
              color: 'white',
              border: 'none',
              borderRadius: '5px',
              cursor: 'pointer'
            }}>
              Play Again
            </button>
          </div>
        )}
      </div>

      <div style={{
        marginTop: '10px',
        display: 'flex',
        gap: '20px',
        alignItems: 'center'
      }}>
        <div style={{ color: '#2d5016', fontWeight: 'bold' }}>
          Score: {Math.floor(score / 10)}
        </div>
        <button onClick={resetGame} style={{
          padding: '8px 16px',
          backgroundColor: '#ff9800',
          color: 'white',
          border: 'none',
          borderRadius: '4px',
          cursor: 'pointer'
        }}>
          Reset
        </button>
      </div>
      
      <div style={{
        marginTop: '10px',
        color: '#666',
        fontSize: '14px',
        textAlign: 'center'
      }}>
        Click the game area or press Space to jump over obstacles!
      </div>
    </div>
  );
};

export default GameZone;
----------------------------------------


================================================================================
GAME GENERATION: Jungle Jump - 2025-08-09 13:51:57.314328
================================================================================
FULL CLAUDE GENERATED CODE:
----------------------------------------
import React, { useState, useEffect, useRef } from 'react';

const GameZone = ({ currentGame }) => {
  const [playerY, setPlayerY] = useState(250);
  const [playerVelocity, setPlayerVelocity] = useState(0);
  const [obstacles, setObstacles] = useState([]);
  const [score, setScore] = useState(0);
  const [gameOver, setGameOver] = useState(false);
  const [gameStarted, setGameStarted] = useState(false);
  const gameLoopRef = useRef();

  const GRAVITY = 0.8;
  const JUMP_FORCE = -15;
  const PLAYER_SIZE = 30;
  const OBSTACLE_WIDTH = 20;
  const OBSTACLE_HEIGHT = 60;
  const GAME_WIDTH = 400;
  const GAME_HEIGHT = 300;
  const GROUND_Y = 280;

  useEffect(() => {
    if (gameStarted && !gameOver) {
      gameLoopRef.current = setInterval(() => {
        setPlayerY(prevY => {
          const newY = prevY + playerVelocity;
          return Math.min(newY, GROUND_Y - PLAYER_SIZE);
        });

        setPlayerVelocity(prevVel => {
          if (playerY >= GROUND_Y - PLAYER_SIZE) {
            return 0;
          }
          return prevVel + GRAVITY;
        });

        setObstacles(prevObstacles => {
          const newObstacles = prevObstacles
            .map(obs => ({ ...obs, x: obs.x - 3 }))
            .filter(obs => obs.x > -OBSTACLE_WIDTH);

          if (Math.random() < 0.015 && (newObstacles.length === 0 || newObstacles[newObstacles.length - 1].x < GAME_WIDTH - 150)) {
            newObstacles.push({
              x: GAME_WIDTH,
              y: GROUND_Y - OBSTACLE_HEIGHT,
              width: OBSTACLE_WIDTH,
              height: OBSTACLE_HEIGHT
            });
          }

          return newObstacles;
        });

        setScore(prevScore => prevScore + 1);
      }, 1000 / 60);
    }

    return () => clearInterval(gameLoopRef.current);
  }, [gameStarted, gameOver, playerY, playerVelocity]);

  useEffect(() => {
    const checkCollision = () => {
      const playerX = 50;
      const playerBottom = playerY + PLAYER_SIZE;
      const playerRight = playerX + PLAYER_SIZE;

      for (let obstacle of obstacles) {
        if (
          playerRight > obstacle.x &&
          playerX < obstacle.x + obstacle.width &&
          playerBottom > obstacle.y &&
          playerY < obstacle.y + obstacle.height
        ) {
          setGameOver(true);
          setGameStarted(false);
          break;
        }
      }
    };

    if (gameStarted && !gameOver) {
      checkCollision();
    }
  }, [playerY, obstacles, gameStarted, gameOver]);

  const handleJump = () => {
    if (!gameStarted) {
      startGame();
      return;
    }
    
    if (gameOver) return;
    
    if (playerY >= GROUND_Y - PLAYER_SIZE) {
      setPlayerVelocity(JUMP_FORCE);
    }
  };

  const startGame = () => {
    setGameStarted(true);
    setGameOver(false);
    setScore(0);
    setPlayerY(250);
    setPlayerVelocity(0);
    setObstacles([]);
  };

  const resetGame = () => {
    setGameStarted(false);
    setGameOver(false);
    setScore(0);
    setPlayerY(250);
    setPlayerVelocity(0);
    setObstacles([]);
  };

  useEffect(() => {
    const handleKeyPress = (e) => {
      if (e.code === 'Space') {
        e.preventDefault();
        handleJump();
      }
    };

    window.addEventListener('keydown', handleKeyPress);
    return () => window.removeEventListener('keydown', handleKeyPress);
  }, [gameStarted, gameOver, playerY]);

  return (
    <div style={{
      display: 'flex',
      flexDirection: 'column',
      alignItems: 'center',
      padding: '20px',
      fontFamily: 'Arial, sans-serif'
    }}>
      <h2 style={{ margin: '0 0 10px 0', color: '#2d5016' }}>Jungle Jump</h2>
      
      <div style={{
        position: 'relative',
        width: GAME_WIDTH,
        height: GAME_HEIGHT,
        backgroundColor: '#87CEEB',
        border: '2px solid #2d5016',
        overflow: 'hidden',
        cursor: 'pointer'
      }} onClick={handleJump}>
        
        <div style={{
          position: 'absolute',
          bottom: 0,
          left: 0,
          width: '100%',
          height: '20px',
          backgroundColor: '#8B4513'
        }} />

        <div style={{
          position: 'absolute',
          left: '50px',
          top: `${playerY}px`,
          width: `${PLAYER_SIZE}px`,
          height: `${PLAYER_SIZE}px`,
          backgroundColor: '#FF6B35',
          borderRadius: '50%',
          border: '2px solid #FF4500'
        }} />

        {obstacles.map((obstacle, index) => (
          <div key={index} style={{
            position: 'absolute',
            left: `${obstacle.x}px`,
            top: `${obstacle.y}px`,
            width: `${obstacle.width}px`,
            height: `${obstacle.height}px`,
            backgroundColor: '#2d5016',
            border: '1px solid #1a2e0a'
          }} />
        ))}

        {!gameStarted && !gameOver && (
          <div style={{
            position: 'absolute',
            top: '50%',
            left: '50%',
            transform: 'translate(-50%, -50%)',
            backgroundColor: 'rgba(255, 255, 255, 0.9)',
            padding: '20px',
            borderRadius: '10px',
            textAlign: 'center'
          }}>
            <div style={{ fontSize: '18px', marginBottom: '10px' }}>Jungle Jump</div>
            <div style={{ fontSize: '14px', marginBottom: '15px' }}>Click or press SPACE to jump over obstacles!</div>
            <button onClick={startGame} style={{
              padding: '10px 20px',
              fontSize: '16px',
              backgroundColor: '#2d5016',
              color: 'white',
              border: 'none',
              borderRadius: '5px',
              cursor: 'pointer'
            }}>
              Start Game
            </button>
          </div>
        )}

        {gameOver && (
          <div style={{
            position: 'absolute',
            top: '50%',
            left: '50%',
            transform: 'translate(-50%, -50%)',
            backgroundColor: 'rgba(255, 255, 255, 0.9)',
            padding: '20px',
            borderRadius: '10px',
            textAlign: 'center'
          }}>
            <div style={{ fontSize: '18px', marginBottom: '10px', color: '#d32f2f' }}>Game Over!</div>
            <div style={{ fontSize: '16px', marginBottom: '15px' }}>Score: {Math.floor(score / 10)}</div>
            <button onClick={resetGame} style={{
              padding: '10
----------------------------------------


================================================================================
GAME GENERATION: Space Runner - 2025-08-09 13:52:18.612061
================================================================================
FULL CLAUDE GENERATED CODE:
----------------------------------------
import React, { useState, useEffect, useRef, useCallback } from 'react';

const GameZone = ({ currentGame }) => {
  const canvasRef = useRef(null);
  const gameLoopRef = useRef(null);
  const keysRef = useRef({});
  
  const [gameState, setGameState] = useState({
    player: { x: 50, y: 150, width: 20, height: 20 },
    obstacles: [],
    score: 0,
    gameOver: false,
    speed: 2
  });

  const resetGame = useCallback(() => {
    setGameState({
      player: { x: 50, y: 150, width: 20, height: 20 },
      obstacles: [],
      score: 0,
      gameOver: false,
      speed: 2
    });
  }, []);

  const checkCollision = (rect1, rect2) => {
    return rect1.x < rect2.x + rect2.width &&
           rect1.x + rect1.width > rect2.x &&
           rect1.y < rect2.y + rect2.height &&
           rect1.y + rect1.height > rect2.y;
  };

  const gameLoop = useCallback(() => {
    setGameState(prevState => {
      if (prevState.gameOver) return prevState;

      const newState = { ...prevState };
      
      // Move player
      if (keysRef.current['ArrowUp'] && newState.player.y > 0) {
        newState.player.y -= 3;
      }
      if (keysRef.current['ArrowDown'] && newState.player.y < 280) {
        newState.player.y += 3;
      }

      // Move obstacles
      newState.obstacles = newState.obstacles.map(obs => ({
        ...obs,
        x: obs.x - newState.speed
      })).filter(obs => obs.x > -50);

      // Add new obstacles
      if (Math.random() < 0.02) {
        newState.obstacles.push({
          x: 400,
          y: Math.random() * 250,
          width: 30,
          height: 30
        });
      }

      // Check collisions
      for (let obs of newState.obstacles) {
        if (checkCollision(newState.player, obs)) {
          newState.gameOver = true;
          break;
        }
      }

      // Update score and speed
      newState.score += 1;
      if (newState.score % 500 === 0) {
        newState.speed += 0.5;
      }

      return newState;
    });
  }, []);

  useEffect(() => {
    const handleKeyDown = (e) => {
      keysRef.current[e.key] = true;
    };

    const handleKeyUp = (e) => {
      keysRef.current[e.key] = false;
    };

    window.addEventListener('keydown', handleKeyDown);
    window.addEventListener('keyup', handleKeyUp);

    return () => {
      window.removeEventListener('keydown', handleKeyDown);
      window.removeEventListener('keyup', handleKeyUp);
    };
  }, []);

  useEffect(() => {
    if (!gameState.gameOver) {
      gameLoopRef.current = setInterval(gameLoop, 16);
    } else {
      clearInterval(gameLoopRef.current);
    }

    return () => clearInterval(gameLoopRef.current);
  }, [gameLoop, gameState.gameOver]);

  useEffect(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;

    const ctx = canvas.getContext('2d');
    ctx.clearRect(0, 0, 400, 300);

    // Draw background
    ctx.fillStyle = '#000';
    ctx.fillRect(0, 0, 400, 300);

    // Draw stars
    ctx.fillStyle = '#fff';
    for (let i = 0; i < 50; i++) {
      const x = (i * 37) % 400;
      const y = (i * 23) % 300;
      ctx.fillRect(x, y, 1, 1);
    }

    // Draw player
    ctx.fillStyle = '#0f0';
    ctx.fillRect(gameState.player.x, gameState.player.y, gameState.player.width, gameState.player.height);

    // Draw obstacles
    ctx.fillStyle = '#f00';
    gameState.obstacles.forEach(obs => {
      ctx.fillRect(obs.x, obs.y, obs.width, obs.height);
    });

  }, [gameState]);

  return (
    <div style={{ 
      display: 'flex', 
      flexDirection: 'column', 
      alignItems: 'center', 
      padding: '20px',
      fontFamily: 'Arial, sans-serif'
    }}>
      <h2 style={{ margin: '0 0 10px 0', color: '#333' }}>Space Runner</h2>
      
      <div style={{ marginBottom: '10px', fontSize: '18px', fontWeight: 'bold' }}>
        Score: {gameState.score}
      </div>

      <canvas
        ref={canvasRef}
        width={400}
        height={300}
        style={{
          border: '2px solid #333',
          backgroundColor: '#000'
        }}
      />

      <div style={{ marginTop: '10px', textAlign: 'center' }}>
        <div style={{ marginBottom: '10px', fontSize: '14px' }}>
          Use ‚Üë‚Üì arrow keys to move
        </div>
        
        {gameState.gameOver && (
          <div style={{ 
            backgroundColor: '#f44', 
            color: 'white', 
            padding: '10px', 
            borderRadius: '5px',
            marginBottom: '10px'
          }}>
            Game Over! Final Score: {gameState.score}
          </div>
        )}

        <button
          onClick={resetGame}
          style={{
            padding: '10px 20px',
            fontSize: '16px',
            backgroundColor: '#4CAF50',
            color: 'white',
            border: 'none',
            borderRadius: '5px',
            cursor: 'pointer'
          }}
        >
          {gameState.gameOver ? 'Play Again' : 'Restart'}
        </button>
      </div>
    </div>
  );
};

export default GameZone;
----------------------------------------


================================================================================
GAME GENERATION: Space Runner - 2025-08-09 13:52:22.199218
================================================================================
FULL CLAUDE GENERATED CODE:
----------------------------------------
import React, { useState, useEffect, useRef, useCallback } from 'react';

const GameZone = ({ currentGame }) => {
  const canvasRef = useRef(null);
  const animationRef = useRef(null);
  const gameStateRef = useRef({
    player: { x: 50, y: 150, width: 20, height: 15 },
    obstacles: [],
    stars: [],
    score: 0,
    speed: 2,
    gameOver: false,
    keys: {}
  });

  const [score, setScore] = useState(0);
  const [gameOver, setGameOver] = useState(false);

  const initGame = useCallback(() => {
    const state = gameStateRef.current;
    state.player = { x: 50, y: 150, width: 20, height: 15 };
    state.obstacles = [];
    state.stars = [];
    state.score = 0;
    state.speed = 2;
    state.gameOver = false;
    setScore(0);
    setGameOver(false);
  }, []);

  const generateObstacle = useCallback(() => {
    const state = gameStateRef.current;
    if (Math.random() < 0.02) {
      state.obstacles.push({
        x: 400,
        y: Math.random() * 250 + 25,
        width: 15,
        height: 15
      });
    }
  }, []);

  const generateStar = useCallback(() => {
    const state = gameStateRef.current;
    if (Math.random() < 0.01) {
      state.stars.push({
        x: 400,
        y: Math.random() * 280 + 10,
        width: 8,
        height: 8
      });
    }
  }, []);

  const updateGame = useCallback(() => {
    const state = gameStateRef.current;
    const canvas = canvasRef.current;
    if (!canvas || state.gameOver) return;

    if (state.keys['ArrowUp'] && state.player.y > 0) {
      state.player.y -= 3;
    }
    if (state.keys['ArrowDown'] && state.player.y < 285) {
      state.player.y += 3;
    }

    generateObstacle();
    generateStar();

    state.obstacles = state.obstacles.filter(obstacle => {
      obstacle.x -= state.speed;
      if (obstacle.x < state.player.x + state.player.width &&
          obstacle.x + obstacle.width > state.player.x &&
          obstacle.y < state.player.y + state.player.height &&
          obstacle.y + obstacle.height > state.player.y) {
        state.gameOver = true;
        setGameOver(true);
        return false;
      }
      return obstacle.x > -obstacle.width;
    });

    state.stars = state.stars.filter(star => {
      star.x -= state.speed;
      if (star.x < state.player.x + state.player.width &&
          star.x + star.width > state.player.x &&
          star.y < state.player.y + state.player.height &&
          star.y + star.height > state.player.y) {
        state.score += 10;
        setScore(state.score);
        return false;
      }
      return star.x > -star.width;
    });

    state.score += 1;
    if (state.score % 500 === 0) {
      state.speed += 0.5;
    }
    setScore(state.score);
  }, [generateObstacle, generateStar]);

  const draw = useCallback(() => {
    const canvas = canvasRef.current;
    const ctx = canvas?.getContext('2d');
    if (!ctx) return;

    const state = gameStateRef.current;

    ctx.fillStyle = '#000011';
    ctx.fillRect(0, 0, 400, 300);

    ctx.fillStyle = '#00ff00';
    ctx.fillRect(state.player.x, state.player.y, state.player.width, state.player.height);

    ctx.fillStyle = '#ff0000';
    state.obstacles.forEach(obstacle => {
      ctx.fillRect(obstacle.x, obstacle.y, obstacle.width, obstacle.height);
    });

    ctx.fillStyle = '#ffff00';
    state.stars.forEach(star => {
      ctx.fillRect(star.x, star.y, star.width, star.height);
    });
  }, []);

  const gameLoop = useCallback(() => {
    updateGame();
    draw();
    if (!gameStateRef.current.gameOver) {
      animationRef.current = requestAnimationFrame(gameLoop);
    }
  }, [updateGame, draw]);

  const handleKeyDown = useCallback((e) => {
    gameStateRef.current.keys[e.key] = true;
  }, []);

  const handleKeyUp = useCallback((e) => {
    gameStateRef.current.keys[e.key] = false;
  }, []);

  useEffect(() => {
    initGame();
    
    window.addEventListener('keydown', handleKeyDown);
    window.addEventListener('keyup', handleKeyUp);

    animationRef.current = requestAnimationFrame(gameLoop);

    return () => {
      window.removeEventListener('keydown', handleKeyDown);
      window.removeEventListener('keyup', handleKeyUp);
      if (animationRef.current) {
        cancelAnimationFrame(animationRef.current);
      }
    };
  }, [initGame, handleKeyDown, handleKeyUp, gameLoop]);

  const restart = () => {
    if (animationRef.current) {
      cancelAnimationFrame(animationRef.current);
    }
    initGame();
    animationRef.current = requestAnimationFrame(gameLoop);
  };

  return (
    <div style={{ display: 'flex', flexDirection: 'column', alignItems: 'center', padding: '20px' }}>
      <h2 style={{ color: '#333', margin: '10px 0' }}>Space Runner</h2>
      <div style={{ marginBottom: '10px' }}>
        <span style={{ fontSize: '18px', fontWeight: 'bold', marginRight: '20px' }}>Score: {score}</span>
        <button 
          onClick={restart}
          style={{
            padding: '8px 16px',
            fontSize: '14px',
            backgroundColor: '#007bff',
            color: 'white',
            border: 'none',
            borderRadius: '4px',
            cursor: 'pointer'
          }}
        >
          Restart
        </button>
      </div>
      <canvas
        ref={canvasRef}
        width={400}
        height={300}
        style={{
          border: '2px solid #333',
          backgroundColor: '#000011'
        }}
      />
      <div style={{ marginTop: '10px', textAlign: 'center', fontSize: '14px', color: '#666' }}>
        Use arrow keys to move up/down. Avoid red obstacles, collect yellow stars!
      </div>
      {gameOver && (
        <div style={{
          position: 'absolute',
          top: '50%',
          left: '50%',
          transform: 'translate(-50%, -50%)',
          backgroundColor: 'rgba(0,0,0,0.8)',
          color: 'white',
          padding: '20px',
          borderRadius: '10px',
          textAlign: 'center'
        }}>
          <h3>Game Over!</h3>
          <p>Final Score: {score}</p>
          <button 
            onClick={restart}
            style={{
              padding: '10px 20px',
              fontSize: '16px',
              backgroundColor: '#28a745',
              color: 'white',
              border: '
----------------------------------------


================================================================================
GAME GENERATION: Jungle Jump - 2025-08-09 13:52:44.523337
================================================================================
FULL CLAUDE GENERATED CODE:
----------------------------------------
import React, { useState, useEffect, useRef } from 'react';

const GameZone = ({ currentGame }) => {
  const canvasRef = useRef(null);
  const [gameState, setGameState] = useState('playing');
  const [score, setScore] = useState(0);
  const [gameStarted, setGameStarted] = useState(false);
  
  const gameRef = useRef({
    player: { x: 50, y: 200, width: 30, height: 30, velocityY: 0, onGround: false },
    platforms: [
      { x: 0, y: 250, width: 100, height: 20 },
      { x: 150, y: 200, width: 80, height: 20 },
      { x: 280, y: 150, width: 80, height: 20 },
      { x: 400, y: 100, width: 80, height: 20 },
      { x: 550, y: 180, width: 80, height: 20 },
      { x: 700, y: 220, width: 80, height: 20 }
    ],
    camera: { x: 0 },
    keys: {},
    gravity: 0.5,
    jumpPower: -12,
    speed: 3
  });

  const resetGame = () => {
    const game = gameRef.current;
    game.player = { x: 50, y: 200, width: 30, height: 30, velocityY: 0, onGround: false };
    game.camera = { x: 0 };
    setScore(0);
    setGameState('playing');
    setGameStarted(true);
  };

  useEffect(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;
    
    const ctx = canvas.getContext('2d');
    const game = gameRef.current;

    const handleKeyDown = (e) => {
      game.keys[e.code] = true;
      if (e.code === 'Space' || e.code === 'ArrowUp') {
        e.preventDefault();
      }
    };

    const handleKeyUp = (e) => {
      game.keys[e.code] = false;
    };

    window.addEventListener('keydown', handleKeyDown);
    window.addEventListener('keyup', handleKeyUp);

    const gameLoop = () => {
      if (!gameStarted || gameState !== 'playing') return;

      // Update player
      const player = game.player;
      
      // Horizontal movement
      if (game.keys['ArrowLeft'] || game.keys['KeyA']) {
        player.x -= game.speed;
      }
      if (game.keys['ArrowRight'] || game.keys['KeyD']) {
        player.x += game.speed;
      }

      // Jumping
      if ((game.keys['Space'] || game.keys['ArrowUp']) && player.onGround) {
        player.velocityY = game.jumpPower;
        player.onGround = false;
      }

      // Apply gravity
      player.velocityY += game.gravity;
      player.y += player.velocityY;

      // Platform collision
      player.onGround = false;
      game.platforms.forEach(platform => {
        if (player.x < platform.x + platform.width &&
            player.x + player.width > platform.x &&
            player.y < platform.y + platform.height &&
            player.y + player.height > platform.y) {
          
          if (player.velocityY > 0 && player.y < platform.y) {
            player.y = platform.y - player.height;
            player.velocityY = 0;
            player.onGround = true;
          }
        }
      });

      // Camera follow
      game.camera.x = player.x - 200;
      if (game.camera.x < 0) game.camera.x = 0;

      // Update score based on distance
      const newScore = Math.floor(Math.max(0, player.x - 50) / 10);
      setScore(newScore);

      // Game over conditions
      if (player.y > 300) {
        setGameState('gameOver');
      }

      // Clear canvas
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // Draw background
      ctx.fillStyle = '#87CEEB';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // Draw jungle background elements
      ctx.fillStyle = '#228B22';
      for (let i = 0; i < 10; i++) {
        const treeX = i * 80 - game.camera.x;
        if (treeX > -50 && treeX < canvas.width + 50) {
          ctx.fillRect(treeX, 0, 30, canvas.height);
        }
      }

      // Draw platforms
      ctx.fillStyle = '#8B4513';
      game.platforms.forEach(platform => {
        const platformX = platform.x - game.camera.x;
        if (platformX > -platform.width && platformX < canvas.width) {
          ctx.fillRect(platformX, platform.y, platform.width, platform.height);
          
          // Add leaves on platforms
          ctx.fillStyle = '#32CD32';
          ctx.fillRect(platformX, platform.y - 5, platform.width, 5);
          ctx.fillStyle = '#8B4513';
        }
      });

      // Draw player
      ctx.fillStyle = player.onGround ? '#FF6B35' : '#FF4500';
      ctx.fillRect(player.x - game.camera.x, player.y, player.width, player.height);
      
      // Player face
      ctx.fillStyle = '#000';
      ctx.fillRect(player.x - game.camera.x + 5, player.y + 5, 3, 3);
      ctx.fillRect(player.x - game.camera.x + 15, player.y + 5, 3, 3);
    };

    const interval = setInterval(gameLoop, 16);

    return () => {
      clearInterval(interval);
      window.removeEventListener('keydown', handleKeyDown);
      window.removeEventListener('keyup', handleKeyUp);
    };
  }, [gameStarted, gameState]);

  return (
    <div style={{ 
      display: 'flex', 
      flexDirection: 'column', 
      alignItems: 'center', 
      padding: '20px',
      fontFamily: 'Arial, sans-serif'
    }}>
      <h2 style={{ margin: '0 0 10px 0', color: '#2E8B57' }}>Jungle Jump</h2>
      
      <div style={{ marginBottom: '10px', fontSize: '18px', fontWeight: 'bold' }}>
        Score: {score}
      </div>

      <canvas
        ref={canvasRef}
        width={400}
        height={300}
        style={{
          border: '2px solid #2E8B57',
          backgroundColor: '#87CEEB',
          marginBottom: '10px'
        }}
      />

      <div style={{ textAlign: 'center', marginBottom: '10px' }}>
        {!gameStarted && (
          <div>
            <p>Jump through the jungle platforms!</p>
            <p>Use ARROW KEYS or WASD to move, SPACE or UP to jump</p>
          </div>
        )}
        
        {gameState === 'gameOver' && (
          <div style={{ color: '#D2691E', fontSize: '18px', fontWeight: 'bold' }}>
            Game Over! Final Score: {score}
          </div>
        )}
      </div>

      <button
        onClick={resetGame}
        style={{
          padding: '10px 20px',
          
----------------------------------------


================================================================================
GAME GENERATION: Jungle Jump - 2025-08-09 13:52:45.357675
================================================================================
FULL CLAUDE GENERATED CODE:
----------------------------------------
import React, { useState, useEffect, useCallback } from 'react';

const GameZone = ({ currentGame }) => {
  const [player, setPlayer] = useState({ x: 50, y: 200, width: 30, height: 30, velocityY: 0, onGround: false });
  const [platforms, setPlatforms] = useState([
    { x: 0, y: 250, width: 100, height: 20 },
    { x: 150, y: 200, width: 80, height: 20 },
    { x: 280, y: 150, width: 80, height: 20 },
    { x: 200, y: 100, width: 100, height: 20 },
    { x: 350, y: 50, width: 50, height: 20 }
  ]);
  const [score, setScore] = useState(0);
  const [gameRunning, setGameRunning] = useState(true);
  const [keys, setKeys] = useState({});

  const GRAVITY = 0.5;
  const JUMP_FORCE = -12;
  const MOVE_SPEED = 3;
  const GAME_WIDTH = 400;
  const GAME_HEIGHT = 300;

  const handleKeyDown = useCallback((e) => {
    setKeys(prev => ({ ...prev, [e.key]: true }));
  }, []);

  const handleKeyUp = useCallback((e) => {
    setKeys(prev => ({ ...prev, [e.key]: false }));
  }, []);

  useEffect(() => {
    window.addEventListener('keydown', handleKeyDown);
    window.addEventListener('keyup', handleKeyUp);
    return () => {
      window.removeEventListener('keydown', handleKeyDown);
      window.removeEventListener('keyup', handleKeyUp);
    };
  }, [handleKeyDown, handleKeyUp]);

  const checkCollision = (rect1, rect2) => {
    return rect1.x < rect2.x + rect2.width &&
           rect1.x + rect1.width > rect2.x &&
           rect1.y < rect2.y + rect2.height &&
           rect1.y + rect1.height > rect2.y;
  };

  const resetGame = () => {
    setPlayer({ x: 50, y: 200, width: 30, height: 30, velocityY: 0, onGround: false });
    setScore(0);
    setGameRunning(true);
  };

  useEffect(() => {
    if (!gameRunning) return;

    const gameLoop = setInterval(() => {
      setPlayer(prevPlayer => {
        let newPlayer = { ...prevPlayer };

        // Handle input
        if (keys['ArrowLeft'] || keys['a']) {
          newPlayer.x = Math.max(0, newPlayer.x - MOVE_SPEED);
        }
        if (keys['ArrowRight'] || keys['d']) {
          newPlayer.x = Math.min(GAME_WIDTH - newPlayer.width, newPlayer.x + MOVE_SPEED);
        }
        if ((keys['ArrowUp'] || keys[' '] || keys['w']) && newPlayer.onGround) {
          newPlayer.velocityY = JUMP_FORCE;
          newPlayer.onGround = false;
        }

        // Apply gravity
        newPlayer.velocityY += GRAVITY;
        newPlayer.y += newPlayer.velocityY;

        // Check platform collisions
        newPlayer.onGround = false;
        platforms.forEach(platform => {
          if (checkCollision(newPlayer, platform)) {
            if (newPlayer.velocityY > 0 && newPlayer.y < platform.y) {
              newPlayer.y = platform.y - newPlayer.height;
              newPlayer.velocityY = 0;
              newPlayer.onGround = true;
              
              // Score for landing on higher platforms
              const platformHeight = GAME_HEIGHT - platform.y;
              if (platformHeight > 50) {
                setScore(prev => prev + Math.floor(platformHeight / 10));
              }
            }
          }
        });

        // Check if player fell off screen
        if (newPlayer.y > GAME_HEIGHT) {
          setGameRunning(false);
        }

        return newPlayer;
      });
    }, 1000 / 60);

    return () => clearInterval(gameLoop);
  }, [gameRunning, keys, platforms]);

  return (
    <div style={{ 
      display: 'flex', 
      flexDirection: 'column', 
      alignItems: 'center', 
      padding: '20px',
      fontFamily: 'Arial, sans-serif'
    }}>
      <h2 style={{ margin: '0 0 10px 0', color: '#2c5530' }}>Jungle Jump</h2>
      
      <div style={{ marginBottom: '10px' }}>
        <span style={{ marginRight: '20px', fontWeight: 'bold' }}>Score: {score}</span>
        <button 
          onClick={resetGame}
          style={{
            padding: '5px 15px',
            backgroundColor: '#4CAF50',
            color: 'white',
            border: 'none',
            borderRadius: '5px',
            cursor: 'pointer'
          }}
        >
          Reset Game
        </button>
      </div>

      <div 
        style={{
          position: 'relative',
          width: GAME_WIDTH,
          height: GAME_HEIGHT,
          backgroundColor: '#87CEEB',
          border: '2px solid #2c5530',
          overflow: 'hidden'
        }}
      >
        {/* Platforms */}
        {platforms.map((platform, index) => (
          <div
            key={index}
            style={{
              position: 'absolute',
              left: platform.x,
              top: platform.y,
              width: platform.width,
              height: platform.height,
              backgroundColor: '#8B4513',
              border: '1px solid #654321'
            }}
          />
        ))}

        {/* Player */}
        <div
          style={{
            position: 'absolute',
            left: player.x,
            top: player.y,
            width: player.width,
            height: player.height,
            backgroundColor: '#FF6B35',
            border: '2px solid #D2691E',
            borderRadius: '5px'
          }}
        />

        {/* Game Over overlay */}
        {!gameRunning && (
          <div
            style={{
              position: 'absolute',
              top: 0,
              left: 0,
              right: 0,
              bottom: 0,
              backgroundColor: 'rgba(0,0,0,0.7)',
              display: 'flex',
              flexDirection: 'column',
              justifyContent: 'center',
              alignItems: 'center',
              color: 'white'
            }}
          >
            <h3 style={{ margin: '0 0 10px 0' }}>Game Over!</h3>
            <p style={{ margin: '0 0 15px 0' }}>Final Score: {score}</p>
            <button 
              onClick={resetGame}
              style={{
                padding: '10px 20px',
                backgroundColor: '#4CAF50',
                color: 'white',
                border: 'none',
                borderRadius: '5px',
                cursor: 'pointer',
                fontSize: '16px'
              }}
            >
              Play Again
            </button>
          </div>
        )}
      </div>

      <div style={{ marginTop: '10px', fontSize: '12px', textAlign: 'center' }}>
        <p>Use Arrow Keys or WASD to move and jump</p>
        <p>Jump on higher platforms to score more points!</p>
      </div>
    </div>
  );
};

export
----------------------------------------


================================================================================
GAME GENERATION: Space Runner - 2025-08-09 14:07:58.236654
================================================================================
FULL CLAUDE GENERATED CODE:
----------------------------------------
import React, { useState, useEffect, useCallback } from 'react';

const GameZone = ({ currentGame }) => {
  const [gameState, setGameState] = useState('playing');
  const [score, setScore] = useState(0);
  const [playerY, setPlayerY] = useState(150);
  const [obstacles, setObstacles] = useState([]);
  const [gameSpeed, setGameSpeed] = useState(2);

  const resetGame = useCallback(() => {
    setGameState('playing');
    setScore(0);
    setPlayerY(150);
    setObstacles([]);
    setGameSpeed(2);
  }, []);

  useEffect(() => {
    if (gameState !== 'playing') return;

    const gameLoop = setInterval(() => {
      setObstacles(prev => {
        const newObstacles = prev
          .map(obs => ({ ...obs, x: obs.x - gameSpeed }))
          .filter(obs => obs.x > -50);

        if (Math.random() < 0.02) {
          newObstacles.push({
            x: 450,
            y: Math.random() * 200 + 50,
            width: 30,
            height: 30
          });
        }

        return newObstacles;
      });

      setScore(prev => prev + 1);
      setGameSpeed(prev => prev + 0.001);
    }, 16);

    return () => clearInterval(gameLoop);
  }, [gameState, gameSpeed]);

  useEffect(() => {
    const handleKeyPress = (e) => {
      if (gameState !== 'playing') return;
      
      if (e.key === 'ArrowUp' && playerY > 10) {
        setPlayerY(prev => prev - 15);
      } else if (e.key === 'ArrowDown' && playerY < 260) {
        setPlayerY(prev => prev + 15);
      }
    };

    window.addEventListener('keydown', handleKeyPress);
    return () => window.removeEventListener('keydown', handleKeyPress);
  }, [gameState, playerY]);

  useEffect(() => {
    if (gameState !== 'playing') return;

    const playerRect = { x: 50, y: playerY, width: 30, height: 30 };
    
    for (let obstacle of obstacles) {
      if (
        playerRect.x < obstacle.x + obstacle.width &&
        playerRect.x + playerRect.width > obstacle.x &&
        playerRect.y < obstacle.y + obstacle.height &&
        playerRect.y + playerRect.height > obstacle.y
      ) {
        setGameState('gameOver');
        break;
      }
    }
  }, [obstacles, playerY, gameState]);

  return (
    <div style={{
      display: 'flex',
      flexDirection: 'column',
      alignItems: 'center',
      padding: '20px',
      fontFamily: 'Arial, sans-serif'
    }}>
      <h2 style={{ margin: '0 0 10px 0', color: '#333' }}>Space Runner</h2>
      
      <div style={{
        display: 'flex',
        justifyContent: 'space-between',
        width: '400px',
        marginBottom: '10px'
      }}>
        <div style={{ fontSize: '18px', fontWeight: 'bold' }}>Score: {score}</div>
        <button
          onClick={resetGame}
          style={{
            padding: '5px 15px',
            backgroundColor: '#4CAF50',
            color: 'white',
            border: 'none',
            borderRadius: '4px',
            cursor: 'pointer',
            fontSize: '14px'
          }}
        >
          Restart
        </button>
      </div>

      <div style={{
        position: 'relative',
        width: '400px',
        height: '300px',
        backgroundColor: '#000020',
        border: '2px solid #333',
        overflow: 'hidden'
      }}>
        <div style={{
          position: 'absolute',
          left: '50px',
          top: `${playerY}px`,
          width: '30px',
          height: '30px',
          backgroundColor: '#00FF00',
          borderRadius: '50%',
          transition: 'top 0.1s ease'
        }} />

        {obstacles.map((obstacle, index) => (
          <div
            key={index}
            style={{
              position: 'absolute',
              left: `${obstacle.x}px`,
              top: `${obstacle.y}px`,
              width: `${obstacle.width}px`,
              height: `${obstacle.height}px`,
              backgroundColor: '#FF4444',
              borderRadius: '4px'
            }}
          />
        ))}

        {gameState === 'gameOver' && (
          <div style={{
            position: 'absolute',
            top: '50%',
            left: '50%',
            transform: 'translate(-50%, -50%)',
            backgroundColor: 'rgba(0, 0, 0, 0.8)',
            color: 'white',
            padding: '20px',
            borderRadius: '8px',
            textAlign: 'center'
          }}>
            <h3 style={{ margin: '0 0 10px 0' }}>Game Over!</h3>
            <p style={{ margin: '0 0 15px 0' }}>Final Score: {score}</p>
            <button
              onClick={resetGame}
              style={{
                padding: '10px 20px',
                backgroundColor: '#4CAF50',
                color: 'white',
                border: 'none',
                borderRadius: '4px',
                cursor: 'pointer',
                fontSize: '16px'
              }}
            >
              Play Again
            </button>
          </div>
        )}
      </div>

      <div style={{
        marginTop: '10px',
        fontSize: '14px',
        color: '#666',
        textAlign: 'center'
      }}>
        Use ‚Üë and ‚Üì arrow keys to move
      </div>
    </div>
  );
};

export default GameZone;
----------------------------------------


================================================================================
GAME GENERATION: Gravity Bounce: Guide a bouncing ball through rotating maze platforms by reversing gravity. - 2025-08-09 14:08:17.993930
================================================================================
FULL CLAUDE GENERATED CODE:
----------------------------------------
import React, { useState, useEffect, useRef } from 'react';

const GameZone = ({ currentGame }) => {
  const canvasRef = useRef(null);
  const animationRef = useRef(null);
  const [gameState, setGameState] = useState('playing');
  const [score, setScore] = useState(0);

  const gameData = useRef({
    ball: { x: 50, y: 50, vx: 0, vy: 0, radius: 8 },
    gravity: 0.3,
    gravityDirection: 1,
    platforms: [
      { x: 100, y: 150, width: 80, height: 10, rotation: 0, rotSpeed: 0.02 },
      { x: 250, y: 100, width: 60, height: 10, rotation: 0, rotSpeed: -0.015 },
      { x: 150, y: 220, width: 70, height: 10, rotation: 0, rotSpeed: 0.025 },
      { x: 320, y: 180, width: 50, height: 10, rotation: 0, rotSpeed: -0.03 }
    ],
    goal: { x: 350, y: 250, width: 30, height: 30 },
    keys: {}
  });

  useEffect(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;

    const ctx = canvas.getContext('2d');
    const game = gameData.current;

    const handleKeyDown = (e) => {
      game.keys[e.key] = true;
      if (e.key === ' ') {
        e.preventDefault();
        game.gravityDirection *= -1;
      }
    };

    const handleKeyUp = (e) => {
      game.keys[e.key] = false;
    };

    window.addEventListener('keydown', handleKeyDown);
    window.addEventListener('keyup', handleKeyUp);

    const gameLoop = () => {
      if (gameState !== 'playing') return;

      // Update ball physics
      const ball = game.ball;
      
      // Apply gravity
      ball.vy += game.gravity * game.gravityDirection;
      
      // Apply horizontal movement
      if (game.keys['ArrowLeft']) ball.vx -= 0.2;
      if (game.keys['ArrowRight']) ball.vx += 0.2;
      
      // Friction
      ball.vx *= 0.98;
      
      // Update position
      ball.x += ball.vx;
      ball.y += ball.vy;

      // Boundary collision
      if (ball.x - ball.radius <= 0 || ball.x + ball.radius >= canvas.width) {
        ball.vx *= -0.7;
        ball.x = Math.max(ball.radius, Math.min(canvas.width - ball.radius, ball.x));
      }
      if (ball.y - ball.radius <= 0 || ball.y + ball.radius >= canvas.height) {
        ball.vy *= -0.7;
        ball.y = Math.max(ball.radius, Math.min(canvas.height - ball.radius, ball.y));
      }

      // Update platforms
      game.platforms.forEach(platform => {
        platform.rotation += platform.rotSpeed;
      });

      // Platform collision
      game.platforms.forEach(platform => {
        const dx = ball.x - platform.x;
        const dy = ball.y - platform.y;
        
        // Rotate point to platform's local space
        const cos = Math.cos(-platform.rotation);
        const sin = Math.sin(-platform.rotation);
        const localX = dx * cos - dy * sin;
        const localY = dx * sin + dy * cos;
        
        if (Math.abs(localX) < platform.width / 2 + ball.radius && 
            Math.abs(localY) < platform.height / 2 + ball.radius) {
          
          if (Math.abs(localY) > Math.abs(localX)) {
            ball.vy = localY > 0 ? Math.abs(ball.vy) : -Math.abs(ball.vy);
            ball.vy *= 0.8;
            ball.y = platform.y + (localY > 0 ? platform.height / 2 + ball.radius : -platform.height / 2 - ball.radius);
          } else {
            ball.vx *= -0.7;
            ball.x = platform.x + (localX > 0 ? platform.width / 2 + ball.radius : -platform.width / 2 - ball.radius);
          }
        }
      });

      // Goal collision
      const goal = game.goal;
      if (ball.x + ball.radius > goal.x && ball.x - ball.radius < goal.x + goal.width &&
          ball.y + ball.radius > goal.y && ball.y - ball.radius < goal.y + goal.height) {
        setScore(prev => prev + 1);
        resetBall();
      }

      // Render
      ctx.fillStyle = '#1a1a2e';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // Draw platforms
      game.platforms.forEach(platform => {
        ctx.save();
        ctx.translate(platform.x, platform.y);
        ctx.rotate(platform.rotation);
        ctx.fillStyle = '#16213e';
        ctx.fillRect(-platform.width / 2, -platform.height / 2, platform.width, platform.height);
        ctx.strokeStyle = '#0f3460';
        ctx.lineWidth = 2;
        ctx.strokeRect(-platform.width / 2, -platform.height / 2, platform.width, platform.height);
        ctx.restore();
      });

      // Draw goal
      ctx.fillStyle = '#e94560';
      ctx.fillRect(goal.x, goal.y, goal.width, goal.height);

      // Draw ball
      ctx.fillStyle = '#f39c12';
      ctx.beginPath();
      ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
      ctx.fill();

      // Draw gravity indicator
      ctx.fillStyle = game.gravityDirection > 0 ? '#e74c3c' : '#3498db';
      ctx.font = '16px Arial';
      ctx.fillText(game.gravityDirection > 0 ? '‚Üì' : '‚Üë', 10, 25);

      animationRef.current = requestAnimationFrame(gameLoop);
    };

    gameLoop();

    return () => {
      window.removeEventListener('keydown', handleKeyDown);
      window.removeEventListener('keyup', handleKeyUp);
      if (animationRef.current) {
        cancelAnimationFrame(animationRef.current);
      }
    };
  }, [gameState]);

  const resetBall = () => {
    gameData.current.ball = { x: 50, y: 50, vx: 0, vy: 0, radius: 8 };
  };

  const resetGame = () => {
    setScore(0);
    setGameState('playing');
    resetBall();
    gameData.current.gravityDirection = 1;
  };

  return (
    <div style={{ textAlign: 'center', padding: '20px', backgroundColor: '#0f0f23', color: 'white', minHeight: '100vh' }}>
      <h2 style={{ margin: '0 0 10px 0', color: '#f39c12' }}>Gravity Bounce</h2>
      <div style={{ marginBottom: '10px' }}>
        <span style={{ marginRight: '20px' }}>Score: {score}</span>
        <button 
          onClick={resetGame}
          style={{
            padding: '8px 16px',
            backgroundColor: '#e94560',
----------------------------------------


================================================================================
GAME GENERATION: Bubble Bounce: Pop floating bubbles by drawing lines that reflect a bouncing ball before time runs out. - 2025-08-09 14:09:23.501850
================================================================================
FULL CLAUDE GENERATED CODE:
----------------------------------------
import React, { useState, useRef, useEffect, useCallback } from 'react';

const GameZone = ({ currentGame }) => {
  const canvasRef = useRef(null);
  const [gameState, setGameState] = useState('playing');
  const [score, setScore] = useState(0);
  const [timeLeft, setTimeLeft] = useState(30);
  const [ball, setBall] = useState({ x: 200, y: 250, vx: 3, vy: -3, radius: 8 });
  const [bubbles, setBubbles] = useState([]);
  const [lines, setLines] = useState([]);
  const [isDrawing, setIsDrawing] = useState(false);
  const [currentLine, setCurrentLine] = useState([]);

  const initializeGame = useCallback(() => {
    const newBubbles = [];
    for (let i = 0; i < 8; i++) {
      newBubbles.push({
        x: 50 + Math.random() * 300,
        y: 50 + Math.random() * 200,
        radius: 15 + Math.random() * 10,
        id: i
      });
    }
    setBubbles(newBubbles);
    setBall({ x: 200, y: 250, vx: 3, vy: -3, radius: 8 });
    setLines([]);
    setScore(0);
    setTimeLeft(30);
    setGameState('playing');
  }, []);

  useEffect(() => {
    initializeGame();
  }, [initializeGame]);

  useEffect(() => {
    if (gameState !== 'playing') return;

    const timer = setInterval(() => {
      setTimeLeft(prev => {
        if (prev <= 1) {
          setGameState('gameOver');
          return 0;
        }
        return prev - 1;
      });
    }, 1000);

    return () => clearInterval(timer);
  }, [gameState]);

  useEffect(() => {
    if (gameState !== 'playing') return;

    const gameLoop = setInterval(() => {
      setBall(prevBall => {
        let newBall = { ...prevBall };
        newBall.x += newBall.vx;
        newBall.y += newBall.vy;

        // Wall collisions
        if (newBall.x <= newBall.radius || newBall.x >= 400 - newBall.radius) {
          newBall.vx = -newBall.vx;
        }
        if (newBall.y <= newBall.radius || newBall.y >= 300 - newBall.radius) {
          newBall.vy = -newBall.vy;
        }

        // Line collisions
        lines.forEach(line => {
          if (line.length < 2) return;
          
          for (let i = 0; i < line.length - 1; i++) {
            const p1 = line[i];
            const p2 = line[i + 1];
            
            const dist = distanceToLineSegment(newBall.x, newBall.y, p1.x, p1.y, p2.x, p2.y);
            
            if (dist < newBall.radius) {
              // Simple reflection
              const dx = p2.x - p1.x;
              const dy = p2.y - p1.y;
              const len = Math.sqrt(dx * dx + dy * dy);
              const nx = -dy / len;
              const ny = dx / len;
              
              const dot = newBall.vx * nx + newBall.vy * ny;
              newBall.vx -= 2 * dot * nx;
              newBall.vy -= 2 * dot * ny;
            }
          }
        });

        // Bubble collisions
        setBubbles(prevBubbles => {
          return prevBubbles.filter(bubble => {
            const dx = newBall.x - bubble.x;
            const dy = newBall.y - bubble.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            if (distance < newBall.radius + bubble.radius) {
              setScore(prev => prev + 10);
              return false;
            }
            return true;
          });
        });

        return newBall;
      });
    }, 16);

    return () => clearInterval(gameLoop);
  }, [gameState, lines]);

  useEffect(() => {
    if (bubbles.length === 0 && gameState === 'playing') {
      setGameState('won');
    }
  }, [bubbles.length, gameState]);

  const distanceToLineSegment = (px, py, x1, y1, x2, y2) => {
    const dx = x2 - x1;
    const dy = y2 - y1;
    const length = Math.sqrt(dx * dx + dy * dy);
    
    if (length === 0) return Math.sqrt((px - x1) * (px - x1) + (py - y1) * (py - y1));
    
    const t = Math.max(0, Math.min(1, ((px - x1) * dx + (py - y1) * dy) / (length * length)));
    const projX = x1 + t * dx;
    const projY = y1 + t * dy;
    
    return Math.sqrt((px - projX) * (px - projX) + (py - projY) * (py - projY));
  };

  useEffect(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;

    const ctx = canvas.getContext('2d');
    ctx.clearRect(0, 0, 400, 300);

    // Draw bubbles
    bubbles.forEach(bubble => {
      ctx.beginPath();
      ctx.arc(bubble.x, bubble.y, bubble.radius, 0, Math.PI * 2);
      ctx.fillStyle = 'rgba(100, 200, 255, 0.7)';
      ctx.fill();
      ctx.strokeStyle = 'rgba(50, 150, 255, 1)';
      ctx.stroke();
    });

    // Draw ball
    ctx.beginPath();
    ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
    ctx.fillStyle = '#ff4444';
    ctx.fill();

    // Draw lines
    ctx.strokeStyle = '#333';
    ctx.lineWidth = 3;
    lines.forEach(line => {
      if (line.length < 2) return;
      ctx.beginPath();
      ctx.moveTo(line[0].x, line[0].y);
      for (let i = 1; i < line.length; i++) {
        ctx.lineTo(line[i].x, line[i].y);
      }
      ctx.stroke();
    });

    // Draw current line being drawn
    if (currentLine.length > 1) {
      ctx.strokeStyle = '#666';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(currentLine[0].x, currentLine[0].y);
      for (let i = 1; i < currentLine.length; i++) {
        ctx.lineTo(currentLine[i].x, currentLine[i].y);
      }
      ctx.stroke();
    }
  });

  const handleMouseDown = (e) => {
    if (gameState !== 'playing') return;
    
    const rect = canvasRef.current.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    
    setIsDrawing(true);
    setCurrentLine([{ x, y }]);
  };

  const handleMouseMove = (e) => {
    if (!
----------------------------------------


================================================================================
GAME GENERATION: Color Matcher: Match falling colored blocks with same-colored zones at the bottom by sliding left/right before they land. - 2025-08-09 14:10:05.472111
================================================================================
FULL CLAUDE GENERATED CODE:
----------------------------------------
import React, { useState, useEffect, useRef } from 'react';

const GameZone = ({ currentGame }) => {
  const canvasRef = useRef(null);
  const [gameState, setGameState] = useState('playing');
  const [score, setScore] = useState(0);
  const [blocks, setBlocks] = useState([]);
  const [playerX, setPlayerX] = useState(200);
  const [keys, setKeys] = useState({});

  const CANVAS_WIDTH = 400;
  const CANVAS_HEIGHT = 300;
  const ZONE_WIDTH = 80;
  const ZONE_HEIGHT = 30;
  const BLOCK_SIZE = 20;
  const COLORS = ['red', 'blue', 'green', 'yellow'];

  useEffect(() => {
    const canvas = canvasRef.current;
    const ctx = canvas.getContext('2d');

    const handleKeyDown = (e) => {
      setKeys(prev => ({ ...prev, [e.key]: true }));
    };

    const handleKeyUp = (e) => {
      setKeys(prev => ({ ...prev, [e.key]: false }));
    };

    window.addEventListener('keydown', handleKeyDown);
    window.addEventListener('keyup', handleKeyUp);

    return () => {
      window.removeEventListener('keydown', handleKeyDown);
      window.removeEventListener('keyup', handleKeyUp);
    };
  }, []);

  useEffect(() => {
    if (gameState !== 'playing') return;

    const gameLoop = setInterval(() => {
      setBlocks(prevBlocks => {
        const newBlocks = prevBlocks.map(block => ({
          ...block,
          y: block.y + 2
        }));

        const activeBlocks = newBlocks.filter(block => {
          if (block.y >= CANVAS_HEIGHT - ZONE_HEIGHT - BLOCK_SIZE) {
            const zoneIndex = Math.floor(block.x / (CANVAS_WIDTH / 4));
            const zoneColor = COLORS[zoneIndex];
            if (block.color === zoneColor) {
              setScore(prev => prev + 10);
              return false;
            } else {
              setGameState('gameOver');
              return false;
            }
          }
          return block.y < CANVAS_HEIGHT;
        });

        if (Math.random() < 0.02) {
          activeBlocks.push({
            x: Math.random() * (CANVAS_WIDTH - BLOCK_SIZE),
            y: 0,
            color: COLORS[Math.floor(Math.random() * COLORS.length)]
          });
        }

        return activeBlocks;
      });

      if (keys['ArrowLeft'] && playerX > 0) {
        setPlayerX(prev => Math.max(0, prev - 5));
      }
      if (keys['ArrowRight'] && playerX < CANVAS_WIDTH - BLOCK_SIZE) {
        setPlayerX(prev => Math.min(CANVAS_WIDTH - BLOCK_SIZE, prev + 5));
      }
    }, 50);

    return () => clearInterval(gameLoop);
  }, [gameState, keys, playerX]);

  useEffect(() => {
    const canvas = canvasRef.current;
    const ctx = canvas.getContext('2d');
    
    ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

    for (let i = 0; i < 4; i++) {
      ctx.fillStyle = COLORS[i];
      ctx.fillRect(i * (CANVAS_WIDTH / 4), CANVAS_HEIGHT - ZONE_HEIGHT, ZONE_WIDTH, ZONE_HEIGHT);
      
      ctx.fillStyle = 'white';
      ctx.font = '12px Arial';
      ctx.textAlign = 'center';
      ctx.fillText(COLORS[i].toUpperCase(), i * (CANVAS_WIDTH / 4) + ZONE_WIDTH / 2, CANVAS_HEIGHT - 10);
    }

    blocks.forEach(block => {
      ctx.fillStyle = block.color;
      ctx.fillRect(block.x, block.y, BLOCK_SIZE, BLOCK_SIZE);
    });

    ctx.fillStyle = 'black';
    ctx.font = '16px Arial';
    ctx.textAlign = 'left';
    ctx.fillText(`Score: ${score}`, 10, 20);

    if (gameState === 'gameOver') {
      ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
      ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
      ctx.fillStyle = 'white';
      ctx.font = '24px Arial';
      ctx.textAlign = 'center';
      ctx.fillText('Game Over!', CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2 - 20);
      ctx.fillText(`Final Score: ${score}`, CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2 + 10);
    }
  }, [blocks, score, gameState]);

  const resetGame = () => {
    setGameState('playing');
    setScore(0);
    setBlocks([]);
    setPlayerX(200);
    setKeys({});
  };

  return (
    <div style={{ 
      display: 'flex', 
      flexDirection: 'column', 
      alignItems: 'center', 
      padding: '20px',
      fontFamily: 'Arial, sans-serif'
    }}>
      <h2 style={{ margin: '0 0 10px 0', color: '#333' }}>Color Matcher</h2>
      <p style={{ margin: '0 0 10px 0', fontSize: '14px', color: '#666' }}>
        Use arrow keys to move. Match falling blocks with same-colored zones!
      </p>
      <canvas
        ref={canvasRef}
        width={CANVAS_WIDTH}
        height={CANVAS_HEIGHT}
        style={{
          border: '2px solid #333',
          backgroundColor: '#f0f0f0',
          marginBottom: '10px'
        }}
      />
      <button
        onClick={resetGame}
        style={{
          padding: '10px 20px',
          fontSize: '16px',
          backgroundColor: '#4CAF50',
          color: 'white',
          border: 'none',
          borderRadius: '5px',
          cursor: 'pointer'
        }}
        onMouseOver={(e) => e.target.style.backgroundColor = '#45a049'}
        onMouseOut={(e) => e.target.style.backgroundColor = '#4CAF50'}
      >
        {gameState === 'gameOver' ? 'Play Again' : 'Restart'}
      </button>
    </div>
  );
};

export default GameZone;
----------------------------------------


================================================================================
GAME GENERATION: Pixel Pogo: Bounce a square character between platforms while collecting stars and avoiding spikes. - 2025-08-09 14:11:12.290773
================================================================================
FULL CLAUDE GENERATED CODE:
----------------------------------------
import React, { useState, useEffect, useCallback } from 'react';

const GameZone = ({ currentGame }) => {
  const [player, setPlayer] = useState({ x: 200, y: 200, vx: 0, vy: 0, onGround: false });
  const [platforms] = useState([
    { x: 0, y: 280, width: 400, height: 20 },
    { x: 100, y: 220, width: 80, height: 15 },
    { x: 250, y: 180, width: 80, height: 15 },
    { x: 50, y: 120, width: 80, height: 15 },
    { x: 280, y: 80, width: 80, height: 15 }
  ]);
  const [stars, setStars] = useState([
    { x: 130, y: 190, collected: false },
    { x: 280, y: 150, collected: false },
    { x: 80, y: 90, collected: false },
    { x: 310, y: 50, collected: false }
  ]);
  const [spikes] = useState([
    { x: 200, y: 265, width: 20, height: 15 },
    { x: 160, y: 205, width: 20, height: 15 },
    { x: 20, y: 105, width: 20, height: 15 }
  ]);
  const [keys, setKeys] = useState({ left: false, right: false, space: false });
  const [score, setScore] = useState(0);
  const [gameOver, setGameOver] = useState(false);

  const GRAVITY = 0.5;
  const JUMP_FORCE = -12;
  const MOVE_SPEED = 3;
  const PLAYER_SIZE = 15;

  const checkCollision = useCallback((rect1, rect2) => {
    return rect1.x < rect2.x + rect2.width &&
           rect1.x + rect1.width > rect2.x &&
           rect1.y < rect2.y + rect2.height &&
           rect1.y + rect1.height > rect2.y;
  }, []);

  const resetGame = () => {
    setPlayer({ x: 200, y: 200, vx: 0, vy: 0, onGround: false });
    setStars([
      { x: 130, y: 190, collected: false },
      { x: 280, y: 150, collected: false },
      { x: 80, y: 90, collected: false },
      { x: 310, y: 50, collected: false }
    ]);
    setScore(0);
    setGameOver(false);
  };

  useEffect(() => {
    const handleKeyDown = (e) => {
      if (e.code === 'ArrowLeft') setKeys(prev => ({ ...prev, left: true }));
      if (e.code === 'ArrowRight') setKeys(prev => ({ ...prev, right: true }));
      if (e.code === 'Space') {
        e.preventDefault();
        setKeys(prev => ({ ...prev, space: true }));
      }
    };

    const handleKeyUp = (e) => {
      if (e.code === 'ArrowLeft') setKeys(prev => ({ ...prev, left: false }));
      if (e.code === 'ArrowRight') setKeys(prev => ({ ...prev, right: false }));
      if (e.code === 'Space') setKeys(prev => ({ ...prev, space: false }));
    };

    window.addEventListener('keydown', handleKeyDown);
    window.addEventListener('keyup', handleKeyUp);

    return () => {
      window.removeEventListener('keydown', handleKeyDown);
      window.removeEventListener('keyup', handleKeyUp);
    };
  }, []);

  useEffect(() => {
    if (gameOver) return;

    const gameLoop = setInterval(() => {
      setPlayer(prevPlayer => {
        let newPlayer = { ...prevPlayer };

        if (keys.left) newPlayer.vx = -MOVE_SPEED;
        else if (keys.right) newPlayer.vx = MOVE_SPEED;
        else newPlayer.vx = 0;

        if (keys.space && newPlayer.onGround) {
          newPlayer.vy = JUMP_FORCE;
          newPlayer.onGround = false;
        }

        newPlayer.vy += GRAVITY;
        newPlayer.x += newPlayer.vx;
        newPlayer.y += newPlayer.vy;

        if (newPlayer.x < 0) newPlayer.x = 0;
        if (newPlayer.x > 400 - PLAYER_SIZE) newPlayer.x = 400 - PLAYER_SIZE;

        newPlayer.onGround = false;

        platforms.forEach(platform => {
          const playerRect = { x: newPlayer.x, y: newPlayer.y, width: PLAYER_SIZE, height: PLAYER_SIZE };
          const platformRect = { x: platform.x, y: platform.y, width: platform.width, height: platform.height };

          if (checkCollision(playerRect, platformRect)) {
            if (newPlayer.vy > 0 && prevPlayer.y + PLAYER_SIZE <= platform.y) {
              newPlayer.y = platform.y - PLAYER_SIZE;
              newPlayer.vy = 0;
              newPlayer.onGround = true;
            }
          }
        });

        spikes.forEach(spike => {
          const playerRect = { x: newPlayer.x, y: newPlayer.y, width: PLAYER_SIZE, height: PLAYER_SIZE };
          const spikeRect = { x: spike.x, y: spike.y, width: spike.width, height: spike.height };

          if (checkCollision(playerRect, spikeRect)) {
            setGameOver(true);
          }
        });

        if (newPlayer.y > 300) {
          setGameOver(true);
        }

        return newPlayer;
      });

      setStars(prevStars => {
        return prevStars.map(star => {
          if (star.collected) return star;

          const playerRect = { x: player.x, y: player.y, width: PLAYER_SIZE, height: PLAYER_SIZE };
          const starRect = { x: star.x, y: star.y, width: 12, height: 12 };

          if (checkCollision(playerRect, starRect)) {
            setScore(prev => prev + 10);
            return { ...star, collected: true };
          }

          return star;
        });
      });
    }, 16);

    return () => clearInterval(gameLoop);
  }, [keys, player, platforms, spikes, checkCollision, gameOver]);

  return (
    <div style={{ 
      display: 'flex', 
      flexDirection: 'column', 
      alignItems: 'center', 
      padding: '20px',
      fontFamily: 'monospace'
    }}>
      <div style={{ marginBottom: '10px', fontSize: '18px', fontWeight: 'bold' }}>
        Pixel Pogo - Score: {score}
      </div>
      
      <div style={{
        position: 'relative',
        width: '400px',
        height: '300px',
        border: '2px solid #333',
        backgroundColor: '#87CEEB',
        overflow: 'hidden'
      }}>
        {platforms.map((platform, index) => (
          <div
            key={index}
            style={{
              position: 'absolute',
              left: `${platform.x}px`,
              top: `${platform.y}px`,
              width: `${platform.width}px`,
              height: `${platform.height}px`,
              backgroundColor: '#8B4513'
            }}
          />
        )
----------------------------------------


================================================================================
GAME GENERATION: safari - 2025-08-09 14:13:05.445488
================================================================================
FULL CLAUDE GENERATED CODE:
----------------------------------------
import React, { useState, useEffect, useCallback } from 'react';

const GameZone = ({ currentGame }) => {
  const [gameState, setGameState] = useState('playing');
  const [score, setScore] = useState(0);
  const [timeLeft, setTimeLeft] = useState(30);
  const [animals, setAnimals] = useState([]);
  const [nextAnimalId, setNextAnimalId] = useState(1);

  const animalTypes = [
    { type: 'lion', emoji: 'ü¶Å', points: 10, speed: 2 },
    { type: 'elephant', emoji: 'üêò', points: 15, speed: 1.5 },
    { type: 'zebra', emoji: 'ü¶ì', points: 8, speed: 3 },
    { type: 'giraffe', emoji: 'ü¶í', points: 12, speed: 2.5 }
  ];

  const spawnAnimal = useCallback(() => {
    const animalType = animalTypes[Math.floor(Math.random() * animalTypes.length)];
    const newAnimal = {
      id: nextAnimalId,
      ...animalType,
      x: Math.random() * 350,
      y: Math.random() * 250,
      direction: Math.random() * 2 * Math.PI
    };
    setAnimals(prev => [...prev, newAnimal]);
    setNextAnimalId(prev => prev + 1);
  }, [nextAnimalId]);

  const moveAnimals = useCallback(() => {
    setAnimals(prev => prev.map(animal => {
      let newX = animal.x + Math.cos(animal.direction) * animal.speed;
      let newY = animal.y + Math.sin(animal.direction) * animal.speed;
      let newDirection = animal.direction;

      if (newX < 0 || newX > 350) {
        newDirection = Math.PI - animal.direction;
        newX = Math.max(0, Math.min(350, newX));
      }
      if (newY < 0 || newY > 250) {
        newDirection = -animal.direction;
        newY = Math.max(0, Math.min(250, newY));
      }

      return {
        ...animal,
        x: newX,
        y: newY,
        direction: newDirection
      };
    }));
  }, []);

  const handleAnimalClick = (animalId) => {
    const animal = animals.find(a => a.id === animalId);
    if (animal) {
      setScore(prev => prev + animal.points);
      setAnimals(prev => prev.filter(a => a.id !== animalId));
    }
  };

  const resetGame = () => {
    setGameState('playing');
    setScore(0);
    setTimeLeft(30);
    setAnimals([]);
    setNextAnimalId(1);
  };

  useEffect(() => {
    if (gameState !== 'playing') return;

    const gameTimer = setInterval(() => {
      setTimeLeft(prev => {
        if (prev <= 1) {
          setGameState('gameOver');
          return 0;
        }
        return prev - 1;
      });
    }, 1000);

    return () => clearInterval(gameTimer);
  }, [gameState]);

  useEffect(() => {
    if (gameState !== 'playing') return;

    const spawnTimer = setInterval(spawnAnimal, 2000);
    return () => clearInterval(spawnTimer);
  }, [gameState, spawnAnimal]);

  useEffect(() => {
    if (gameState !== 'playing') return;

    const moveTimer = setInterval(moveAnimals, 100);
    return () => clearInterval(moveTimer);
  }, [gameState, moveAnimals]);

  useEffect(() => {
    spawnAnimal();
  }, []);

  return (
    <div style={{
      display: 'flex',
      flexDirection: 'column',
      alignItems: 'center',
      padding: '20px',
      fontFamily: 'Arial, sans-serif'
    }}>
      <h2 style={{ margin: '0 0 10px 0', color: '#8B4513' }}>Safari Hunt</h2>
      
      <div style={{
        display: 'flex',
        justifyContent: 'space-between',
        width: '400px',
        marginBottom: '10px',
        fontSize: '18px',
        fontWeight: 'bold'
      }}>
        <span style={{ color: '#228B22' }}>Score: {score}</span>
        <span style={{ color: '#DC143C' }}>Time: {timeLeft}s</span>
      </div>

      <div style={{
        width: '400px',
        height: '300px',
        border: '3px solid #8B4513',
        backgroundColor: '#F4A460',
        position: 'relative',
        overflow: 'hidden',
        borderRadius: '10px'
      }}>
        {animals.map(animal => (
          <div
            key={animal.id}
            onClick={() => handleAnimalClick(animal.id)}
            style={{
              position: 'absolute',
              left: `${animal.x}px`,
              top: `${animal.y}px`,
              fontSize: '24px',
              cursor: 'pointer',
              userSelect: 'none',
              transition: 'transform 0.1s',
              transform: 'scale(1)',
              zIndex: 1
            }}
            onMouseDown={(e) => {
              e.target.style.transform = 'scale(0.9)';
            }}
            onMouseUp={(e) => {
              e.target.style.transform = 'scale(1)';
            }}
          >
            {animal.emoji}
          </div>
        ))}

        {gameState === 'gameOver' && (
          <div style={{
            position: 'absolute',
            top: '50%',
            left: '50%',
            transform: 'translate(-50%, -50%)',
            backgroundColor: 'rgba(0, 0, 0, 0.8)',
            color: 'white',
            padding: '20px',
            borderRadius: '10px',
            textAlign: 'center',
            zIndex: 10
          }}>
            <h3 style={{ margin: '0 0 10px 0' }}>Game Over!</h3>
            <p style={{ margin: '0 0 15px 0' }}>Final Score: {score}</p>
            <button
              onClick={resetGame}
              style={{
                padding: '10px 20px',
                fontSize: '16px',
                backgroundColor: '#228B22',
                color: 'white',
                border: 'none',
                borderRadius: '5px',
                cursor: 'pointer'
              }}
            >
              Play Again
            </button>
          </div>
        )}
      </div>

      <div style={{
        marginTop: '15px',
        textAlign: 'center',
        color: '#8B4513'
      }}>
        <p style={{ margin: '5px 0', fontSize: '14px' }}>
          Click on the animals to score points!
        </p>
        <button
          onClick={resetGame}
          style={{
            padding: '8px 16px',
            fontSize: '14px',
            backgroundColor: '#DC143C',
            color: 'white',
            border: 'none',
            borderRadius: '5px',
            cursor: 'pointer',
            marginTop: '5px'
          }}
        >
          Restart Game
        </button>
      </div>
    </div>
  );
};

export default GameZone;
----------------------------------------


================================================================================
GAME GENERATION: Dot Dash: Guide a bouncing dot through a maze by drawing temporary line segments that disappear after a few seconds. - 2025-08-09 14:13:50.389479
================================================================================
FULL CLAUDE GENERATED CODE:
----------------------------------------
import React, { useState, useRef, useEffect, useCallback } from 'react';

const GameZone = ({ currentGame }) => {
  const canvasRef = useRef(null);
  const [gameState, setGameState] = useState('playing');
  const [score, setScore] = useState(0);
  const [lines, setLines] = useState([]);
  const [isDrawing, setIsDrawing] = useState(false);
  const [currentLine, setCurrentLine] = useState(null);
  
  const dotRef = useRef({ x: 50, y: 150, vx: 2, vy: 1 });
  const animationRef = useRef();

  const CANVAS_WIDTH = 400;
  const CANVAS_HEIGHT = 300;
  const DOT_RADIUS = 8;
  const LINE_DURATION = 3000;

  const maze = [
    { x: 100, y: 0, width: 20, height: 100 },
    { x: 200, y: 50, width: 20, height: 150 },
    { x: 300, y: 0, width: 20, height: 120 },
    { x: 0, y: 200, width: 150, height: 20 },
    { x: 250, y: 250, width: 150, height: 20 }
  ];

  const checkCollision = (x, y, radius) => {
    for (let wall of maze) {
      if (x + radius > wall.x && x - radius < wall.x + wall.width &&
          y + radius > wall.y && y - radius < wall.y + wall.height) {
        return true;
      }
    }
    return false;
  };

  const lineIntersectsCircle = (line, cx, cy, radius) => {
    const dx = line.endX - line.startX;
    const dy = line.endY - line.startY;
    const fx = line.startX - cx;
    const fy = line.startY - cy;

    const a = dx * dx + dy * dy;
    const b = 2 * (fx * dx + fy * dy);
    const c = (fx * fx + fy * fy) - radius * radius;

    const discriminant = b * b - 4 * a * c;
    if (discriminant < 0) return false;

    const discriminantSqrt = Math.sqrt(discriminant);
    const t1 = (-b - discriminantSqrt) / (2 * a);
    const t2 = (-b + discriminantSqrt) / (2 * a);

    return (t1 >= 0 && t1 <= 1) || (t2 >= 0 && t2 <= 1);
  };

  const gameLoop = useCallback(() => {
    if (gameState !== 'playing') return;

    const dot = dotRef.current;
    let newX = dot.x + dot.vx;
    let newY = dot.y + dot.vy;

    if (newX - DOT_RADIUS <= 0 || newX + DOT_RADIUS >= CANVAS_WIDTH) {
      dot.vx = -dot.vx;
      newX = dot.x + dot.vx;
    }
    if (newY - DOT_RADIUS <= 0 || newY + DOT_RADIUS >= CANVAS_HEIGHT) {
      dot.vy = -dot.vy;
      newY = dot.y + dot.vy;
    }

    if (checkCollision(newX, newY, DOT_RADIUS)) {
      dot.vx = -dot.vx;
      dot.vy = -dot.vy;
      newX = dot.x + dot.vx;
      newY = dot.y + dot.vy;
    }

    setLines(prevLines => {
      const currentTime = Date.now();
      const validLines = prevLines.filter(line => currentTime - line.timestamp < LINE_DURATION);
      
      for (let line of validLines) {
        if (lineIntersectsCircle(line, newX, newY, DOT_RADIUS)) {
          const dx = line.endX - line.startX;
          const dy = line.endY - line.startY;
          const length = Math.sqrt(dx * dx + dy * dy);
          if (length > 0) {
            const normalX = -dy / length;
            const normalY = dx / length;
            const dotProduct = dot.vx * normalX + dot.vy * normalY;
            dot.vx = dot.vx - 2 * dotProduct * normalX;
            dot.vy = dot.vy - 2 * dotProduct * normalY;
          }
          break;
        }
      }
      
      return validLines;
    });

    dot.x = newX;
    dot.y = newY;

    if (dot.x > CANVAS_WIDTH - 50 && dot.y > CANVAS_HEIGHT - 50) {
      setGameState('won');
      setScore(prev => prev + 100);
    }

    animationRef.current = requestAnimationFrame(gameLoop);
  }, [gameState]);

  useEffect(() => {
    if (gameState === 'playing') {
      animationRef.current = requestAnimationFrame(gameLoop);
    }
    return () => {
      if (animationRef.current) {
        cancelAnimationFrame(animationRef.current);
      }
    };
  }, [gameLoop, gameState]);

  useEffect(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;

    const ctx = canvas.getContext('2d');
    ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

    ctx.fillStyle = '#f0f0f0';
    ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

    ctx.fillStyle = '#333';
    maze.forEach(wall => {
      ctx.fillRect(wall.x, wall.y, wall.width, wall.height);
    });

    ctx.fillStyle = '#00ff00';
    ctx.fillRect(CANVAS_WIDTH - 50, CANVAS_HEIGHT - 50, 40, 40);

    const currentTime = Date.now();
    lines.forEach(line => {
      const age = currentTime - line.timestamp;
      const opacity = Math.max(0, 1 - age / LINE_DURATION);
      ctx.strokeStyle = `rgba(255, 0, 0, ${opacity})`;
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(line.startX, line.startY);
      ctx.lineTo(line.endX, line.endY);
      ctx.stroke();
    });

    if (currentLine) {
      ctx.strokeStyle = 'rgba(255, 0, 0, 0.5)';
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(currentLine.startX, currentLine.startY);
      ctx.lineTo(currentLine.endX, currentLine.endY);
      ctx.stroke();
    }

    const dot = dotRef.current;
    ctx.fillStyle = '#0066ff';
    ctx.beginPath();
    ctx.arc(dot.x, dot.y, DOT_RADIUS, 0, Math.PI * 2);
    ctx.fill();
  });

  const handleMouseDown = (e) => {
    if (gameState !== 'playing') return;
    const canvas = canvasRef.current;
    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    
    setIsDrawing(true);
    setCurrentLine({ startX: x, startY: y, endX: x, endY: y });
  };

  const handleMouseMove = (e
----------------------------------------


================================================================================
GAME GENERATION: Color Matcher: Match falling colored blocks by dragging and connecting same-colored pairs before they hit the bottom. - 2025-08-09 14:15:31.256522
================================================================================
FULL CLAUDE GENERATED CODE:
----------------------------------------
import React, { useState, useEffect, useCallback } from 'react';

const GameZone = ({ currentGame }) => {
  const [blocks, setBlocks] = useState([]);
  const [score, setScore] = useState(0);
  const [gameOver, setGameOver] = useState(false);
  const [selectedBlock, setSelectedBlock] = useState(null);
  const [gameStarted, setGameStarted] = useState(false);

  const colors = ['#ff6b6b', '#4ecdc4', '#45b7d1', '#96ceb4', '#ffeaa7'];
  const gameWidth = 400;
  const gameHeight = 300;

  const generateBlock = useCallback(() => {
    return {
      id: Math.random(),
      x: Math.random() * (gameWidth - 40),
      y: -40,
      color: colors[Math.floor(Math.random() * colors.length)],
      matched: false
    };
  }, []);

  const resetGame = () => {
    setBlocks([]);
    setScore(0);
    setGameOver(false);
    setSelectedBlock(null);
    setGameStarted(true);
  };

  useEffect(() => {
    if (!gameStarted || gameOver) return;

    const gameLoop = setInterval(() => {
      setBlocks(prevBlocks => {
        const newBlocks = prevBlocks.map(block => ({
          ...block,
          y: block.y + 1
        }));

        const activeBlocks = newBlocks.filter(block => !block.matched && block.y < gameHeight);
        const bottomBlocks = newBlocks.filter(block => block.y >= gameHeight && !block.matched);

        if (bottomBlocks.length > 0) {
          setGameOver(true);
          return newBlocks;
        }

        if (Math.random() < 0.02 && activeBlocks.length < 8) {
          activeBlocks.push(generateBlock());
        }

        return activeBlocks;
      });
    }, 50);

    return () => clearInterval(gameLoop);
  }, [gameStarted, gameOver, generateBlock]);

  const handleBlockClick = (block) => {
    if (block.matched) return;

    if (!selectedBlock) {
      setSelectedBlock(block);
    } else if (selectedBlock.id === block.id) {
      setSelectedBlock(null);
    } else if (selectedBlock.color === block.color) {
      setBlocks(prevBlocks => 
        prevBlocks.map(b => 
          b.id === selectedBlock.id || b.id === block.id 
            ? { ...b, matched: true }
            : b
        )
      );
      setScore(prev => prev + 10);
      setSelectedBlock(null);
      
      setTimeout(() => {
        setBlocks(prevBlocks => 
          prevBlocks.filter(b => b.id !== selectedBlock.id && b.id !== block.id)
        );
      }, 200);
    } else {
      setSelectedBlock(block);
    }
  };

  if (!gameStarted) {
    return (
      <div style={{
        width: gameWidth,
        height: gameHeight,
        border: '2px solid #333',
        display: 'flex',
        flexDirection: 'column',
        justifyContent: 'center',
        alignItems: 'center',
        backgroundColor: '#f0f0f0',
        fontFamily: 'Arial, sans-serif'
      }}>
        <h2 style={{ margin: '10px', textAlign: 'center' }}>Color Matcher</h2>
        <p style={{ margin: '10px', textAlign: 'center', fontSize: '14px' }}>
          Click same-colored blocks to match them before they hit the bottom!
        </p>
        <button
          onClick={resetGame}
          style={{
            padding: '10px 20px',
            fontSize: '16px',
            backgroundColor: '#4ecdc4',
            color: 'white',
            border: 'none',
            borderRadius: '5px',
            cursor: 'pointer'
          }}
        >
          Start Game
        </button>
      </div>
    );
  }

  return (
    <div style={{
      width: gameWidth,
      height: gameHeight + 60,
      border: '2px solid #333',
      position: 'relative',
      backgroundColor: '#f9f9f9',
      fontFamily: 'Arial, sans-serif'
    }}>
      <div style={{
        height: '40px',
        backgroundColor: '#333',
        color: 'white',
        display: 'flex',
        justifyContent: 'space-between',
        alignItems: 'center',
        padding: '0 10px'
      }}>
        <div>Score: {score}</div>
        <button
          onClick={resetGame}
          style={{
            padding: '5px 10px',
            backgroundColor: '#ff6b6b',
            color: 'white',
            border: 'none',
            borderRadius: '3px',
            cursor: 'pointer',
            fontSize: '12px'
          }}
        >
          Restart
        </button>
      </div>

      <div style={{
        width: gameWidth,
        height: gameHeight,
        position: 'relative',
        overflow: 'hidden',
        backgroundColor: '#e8e8e8'
      }}>
        {blocks.map(block => (
          <div
            key={block.id}
            onClick={() => handleBlockClick(block)}
            style={{
              position: 'absolute',
              left: block.x,
              top: block.y,
              width: '40px',
              height: '40px',
              backgroundColor: block.color,
              border: selectedBlock?.id === block.id ? '3px solid #333' : '2px solid #fff',
              borderRadius: '5px',
              cursor: 'pointer',
              opacity: block.matched ? 0.3 : 1,
              transition: 'opacity 0.2s',
              display: 'flex',
              alignItems: 'center',
              justifyContent: 'center',
              fontSize: '12px',
              fontWeight: 'bold',
              color: '#333'
            }}
          >
            {selectedBlock?.id === block.id ? '‚úì' : ''}
          </div>
        ))}
      </div>

      {gameOver && (
        <div style={{
          position: 'absolute',
          top: '50%',
          left: '50%',
          transform: 'translate(-50%, -50%)',
          backgroundColor: 'rgba(0,0,0,0.8)',
          color: 'white',
          padding: '20px',
          borderRadius: '10px',
          textAlign: 'center'
        }}>
          <h3>Game Over!</h3>
          <p>Final Score: {score}</p>
          <button
            onClick={resetGame}
            style={{
              padding: '10px 20px',
              backgroundColor: '#4ecdc4',
              color: 'white',
              border: 'none',
              borderRadius: '5px',
              cursor: 'pointer'
            }}
          >
            Play Again
          </button>
        </div>
      )}
    </div>
  );
};

export default GameZone;
----------------------------------------


================================================================================
GAME GENERATION: Neon Dodge: Weave through scrolling geometric obstacles as a glowing triangle while collecting power-ups that temporarily shrink your hitbox. - 2025-08-09 14:15:34.017764
================================================================================
FULL CLAUDE GENERATED CODE:
----------------------------------------
import React, { useState, useEffect, useRef, useCallback } from 'react';

const GameZone = ({ currentGame }) => {
  const canvasRef = useRef(null);
  const animationRef = useRef(null);
  const gameStateRef = useRef({
    player: { x: 50, y: 150, size: 12, shrunk: false, shrinkTimer: 0 },
    obstacles: [],
    powerUps: [],
    score: 0,
    gameRunning: false,
    gameOver: false,
    keys: {}
  });

  const [score, setScore] = useState(0);
  const [gameOver, setGameOver] = useState(false);
  const [gameRunning, setGameRunning] = useState(false);

  const CANVAS_WIDTH = 400;
  const CANVAS_HEIGHT = 300;
  const PLAYER_SPEED = 3;
  const OBSTACLE_SPEED = 2;
  const POWERUP_SPEED = 1.5;

  const resetGame = useCallback(() => {
    gameStateRef.current = {
      player: { x: 50, y: 150, size: 12, shrunk: false, shrinkTimer: 0 },
      obstacles: [],
      powerUps: [],
      score: 0,
      gameRunning: true,
      gameOver: false,
      keys: {}
    };
    setScore(0);
    setGameOver(false);
    setGameRunning(true);
  }, []);

  const startGame = useCallback(() => {
    resetGame();
  }, [resetGame]);

  const stopGame = useCallback(() => {
    gameStateRef.current.gameRunning = false;
    setGameRunning(false);
    setGameOver(true);
    if (animationRef.current) {
      cancelAnimationFrame(animationRef.current);
    }
  }, []);

  const spawnObstacle = useCallback(() => {
    const obstacle = {
      x: CANVAS_WIDTH,
      y: Math.random() * (CANVAS_HEIGHT - 40),
      width: 20 + Math.random() * 30,
      height: 20 + Math.random() * 30,
      color: `hsl(${Math.random() * 60 + 300}, 100%, 60%)`
    };
    gameStateRef.current.obstacles.push(obstacle);
  }, []);

  const spawnPowerUp = useCallback(() => {
    const powerUp = {
      x: CANVAS_WIDTH,
      y: Math.random() * (CANVAS_HEIGHT - 20),
      size: 8,
      color: '#00ff00'
    };
    gameStateRef.current.powerUps.push(powerUp);
  }, []);

  const checkCollision = useCallback((rect1, rect2) => {
    return rect1.x < rect2.x + rect2.width &&
           rect1.x + rect1.width > rect2.x &&
           rect1.y < rect2.y + rect2.height &&
           rect1.y + rect1.height > rect2.y;
  }, []);

  const updateGame = useCallback(() => {
    const state = gameStateRef.current;
    if (!state.gameRunning) return;

    const player = state.player;
    
    // Handle player movement
    if (state.keys['ArrowUp'] && player.y > 0) {
      player.y -= PLAYER_SPEED;
    }
    if (state.keys['ArrowDown'] && player.y < CANVAS_HEIGHT - player.size * 2) {
      player.y += PLAYER_SPEED;
    }
    if (state.keys['ArrowLeft'] && player.x > 0) {
      player.x -= PLAYER_SPEED;
    }
    if (state.keys['ArrowRight'] && player.x < CANVAS_WIDTH - player.size * 2) {
      player.x += PLAYER_SPEED;
    }

    // Update shrink timer
    if (player.shrunk) {
      player.shrinkTimer--;
      if (player.shrinkTimer <= 0) {
        player.shrunk = false;
        player.size = 12;
      }
    }

    // Spawn obstacles
    if (Math.random() < 0.02) {
      spawnObstacle();
    }

    // Spawn power-ups
    if (Math.random() < 0.005) {
      spawnPowerUp();
    }

    // Update obstacles
    state.obstacles = state.obstacles.filter(obstacle => {
      obstacle.x -= OBSTACLE_SPEED;
      return obstacle.x > -obstacle.width;
    });

    // Update power-ups
    state.powerUps = state.powerUps.filter(powerUp => {
      powerUp.x -= POWERUP_SPEED;
      return powerUp.x > -powerUp.size;
    });

    // Check obstacle collisions
    const playerRect = { x: player.x, y: player.y, width: player.size * 2, height: player.size * 2 };
    for (let obstacle of state.obstacles) {
      if (checkCollision(playerRect, obstacle)) {
        stopGame();
        return;
      }
    }

    // Check power-up collisions
    state.powerUps = state.powerUps.filter(powerUp => {
      const powerUpRect = { x: powerUp.x, y: powerUp.y, width: powerUp.size * 2, height: powerUp.size * 2 };
      if (checkCollision(playerRect, powerUpRect)) {
        player.shrunk = true;
        player.shrinkTimer = 300; // 5 seconds at 60fps
        player.size = 6;
        return false;
      }
      return true;
    });

    // Update score
    state.score += 1;
    setScore(state.score);
  }, [checkCollision, spawnObstacle, spawnPowerUp, stopGame]);

  const draw = useCallback(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;

    const ctx = canvas.getContext('2d');
    const state = gameStateRef.current;

    // Clear canvas with dark background
    ctx.fillStyle = '#000011';
    ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

    if (!state.gameRunning && !state.gameOver) return;

    // Draw player (glowing triangle)
    ctx.save();
    ctx.translate(state.player.x + state.player.size, state.player.y + state.player.size);
    
    // Glow effect
    ctx.shadowColor = state.player.shrunk ? '#00ff00' : '#00ffff';
    ctx.shadowBlur = 15;
    
    ctx.fillStyle = state.player.shrunk ? '#00ff00' : '#00ffff';
    ctx.beginPath();
    ctx.moveTo(state.player.size, 0);
    ctx.lineTo(-state.player.size, state.player.size);
    ctx.lineTo(-state.player.size, -state.player.size);
    ctx.closePath();
    ctx.fill();
    
    ctx.restore();

    // Draw obstacles
    state.obstacles.forEach(obstacle => {
      ctx.save();
      ctx.shadowColor = obstacle.color;
      ctx.shadowBlur = 10;
      ctx.fillStyle = obstacle.color;
      ctx.fillRect(obstacle.x, obstacle.y, obstacle.width, obstacle.height);
      ctx.restore();
    });

    // Draw power-ups
    state.powerUps.forEach(powerUp => {
      ctx.save();
      ctx.shadowColor = powerUp.color;
      ctx.shadowBlur = 8;
      ctx.fillStyle = powerUp.color;
      ctx.beginPath();
      ctx.arc(powerUp.x + powerUp.size, powerUp.y + powerUp.size, powerUp.
----------------------------------------


================================================================================
GAME GENERATION: Neon Bounce: Tap to bounce a glowing ball between moving platforms while avoiding deadly red barriers. - 2025-08-09 14:16:14.877479
================================================================================
FULL CLAUDE GENERATED CODE:
----------------------------------------
import React, { useState, useEffect, useRef, useCallback } from 'react';

const GameZone = ({ currentGame }) => {
  const canvasRef = useRef(null);
  const animationRef = useRef(null);
  const gameStateRef = useRef({
    ball: { x: 200, y: 150, vx: 0, vy: 0, radius: 8 },
    platforms: [
      { x: 50, y: 250, width: 80, height: 8, vx: 1 },
      { x: 270, y: 180, width: 80, height: 8, vx: -1 },
      { x: 150, y: 100, width: 80, height: 8, vx: 1.5 }
    ],
    barriers: [
      { x: 0, y: 80, width: 400, height: 4 },
      { x: 0, y: 280, width: 400, height: 4 }
    ],
    score: 0,
    gameOver: false,
    gravity: 0.3,
    bounceForce: -8
  });

  const [score, setScore] = useState(0);
  const [gameOver, setGameOver] = useState(false);

  const resetGame = useCallback(() => {
    gameStateRef.current = {
      ball: { x: 200, y: 150, vx: 0, vy: 0, radius: 8 },
      platforms: [
        { x: 50, y: 250, width: 80, height: 8, vx: 1 },
        { x: 270, y: 180, width: 80, height: 8, vx: -1 },
        { x: 150, y: 100, width: 80, height: 8, vx: 1.5 }
      ],
      barriers: [
        { x: 0, y: 80, width: 400, height: 4 },
        { x: 0, y: 280, width: 400, height: 4 }
      ],
      score: 0,
      gameOver: false,
      gravity: 0.3,
      bounceForce: -8
    };
    setScore(0);
    setGameOver(false);
  }, []);

  const handleTap = useCallback(() => {
    if (!gameStateRef.current.gameOver) {
      gameStateRef.current.ball.vy = gameStateRef.current.bounceForce;
    }
  }, []);

  const checkCollision = useCallback((rect1, rect2) => {
    return rect1.x < rect2.x + rect2.width &&
           rect1.x + rect1.width > rect2.x &&
           rect1.y < rect2.y + rect2.height &&
           rect1.y + rect1.height > rect2.y;
  }, []);

  const updateGame = useCallback(() => {
    const game = gameStateRef.current;
    
    if (game.gameOver) return;

    // Update ball physics
    game.ball.vy += game.gravity;
    game.ball.x += game.ball.vx;
    game.ball.y += game.ball.vy;

    // Update platforms
    game.platforms.forEach(platform => {
      platform.x += platform.vx;
      if (platform.x <= 0 || platform.x + platform.width >= 400) {
        platform.vx *= -1;
      }
    });

    // Check platform collisions
    game.platforms.forEach(platform => {
      const ballRect = {
        x: game.ball.x - game.ball.radius,
        y: game.ball.y - game.ball.radius,
        width: game.ball.radius * 2,
        height: game.ball.radius * 2
      };
      
      if (checkCollision(ballRect, platform) && game.ball.vy > 0) {
        game.ball.vy = game.bounceForce * 0.8;
        game.score += 10;
        setScore(game.score);
      }
    });

    // Check barrier collisions
    game.barriers.forEach(barrier => {
      const ballRect = {
        x: game.ball.x - game.ball.radius,
        y: game.ball.y - game.ball.radius,
        width: game.ball.radius * 2,
        height: game.ball.radius * 2
      };
      
      if (checkCollision(ballRect, barrier)) {
        game.gameOver = true;
        setGameOver(true);
      }
    });

    // Check bounds
    if (game.ball.x < 0 || game.ball.x > 400 || game.ball.y > 300) {
      game.gameOver = true;
      setGameOver(true);
    }
  }, [checkCollision]);

  const draw = useCallback(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;
    
    const ctx = canvas.getContext('2d');
    const game = gameStateRef.current;
    
    // Clear canvas
    ctx.fillStyle = '#000';
    ctx.fillRect(0, 0, 400, 300);
    
    // Draw ball with glow effect
    ctx.shadowColor = '#00ffff';
    ctx.shadowBlur = 20;
    ctx.fillStyle = '#00ffff';
    ctx.beginPath();
    ctx.arc(game.ball.x, game.ball.y, game.ball.radius, 0, Math.PI * 2);
    ctx.fill();
    
    // Reset shadow
    ctx.shadowBlur = 0;
    
    // Draw platforms with glow
    ctx.shadowColor = '#00ff00';
    ctx.shadowBlur = 10;
    ctx.fillStyle = '#00ff00';
    game.platforms.forEach(platform => {
      ctx.fillRect(platform.x, platform.y, platform.width, platform.height);
    });
    
    // Draw barriers
    ctx.shadowColor = '#ff0000';
    ctx.shadowBlur = 15;
    ctx.fillStyle = '#ff0000';
    game.barriers.forEach(barrier => {
      ctx.fillRect(barrier.x, barrier.y, barrier.width, barrier.height);
    });
    
    // Reset shadow
    ctx.shadowBlur = 0;
  }, []);

  const gameLoop = useCallback(() => {
    updateGame();
    draw();
    animationRef.current = requestAnimationFrame(gameLoop);
  }, [updateGame, draw]);

  useEffect(() => {
    const canvas = canvasRef.current;
    if (canvas) {
      canvas.width = 400;
      canvas.height = 300;
    }
    
    gameLoop();
    
    return () => {
      if (animationRef.current) {
        cancelAnimationFrame(animationRef.current);
      }
    };
  }, [gameLoop]);

  return (
    <div style={{ 
      display: 'flex', 
      flexDirection: 'column', 
      alignItems: 'center', 
      padding: '20px',
      backgroundColor: '#111',
      minHeight: '100vh',
      color: '#fff',
      fontFamily: 'Arial, sans-serif'
    }}>
      <h2 style={{ 
        margin: '0 0 10px 0', 
        color: '#00ffff',
        textShadow: '0 0 10px #00ffff'
      }}>
        Neon Bounce
      </h2>
      
      <div style={{ marginBottom: '10px', fontSize: '18px' }}>
        Score: {score}
      </div>
      
      <canvas
        ref={canvasRef}
        onClick={handleTap}
        style={{
          border: '2px solid #333',
          cursor: 'pointer',
          
----------------------------------------


================================================================================
GAME GENERATION: Lucky Racer: hold-and-release to dash through breakable walls in a neon city. - 2025-08-09 14:19:36.447822
================================================================================
FULL CLAUDE GENERATED CODE:
----------------------------------------
import React, { useState, useEffect, useRef } from 'react';

const GameZone = ({ currentGame }) => {
  const canvasRef = useRef(null);
  const [gameState, setGameState] = useState('playing');
  const [score, setScore] = useState(0);
  const [isCharging, setIsCharging] = useState(false);
  const [chargeLevel, setChargeLevel] = useState(0);
  
  const gameRef = useRef({
    player: { x: 50, y: 150, width: 20, height: 20, vx: 0, vy: 0, isDashing: false, dashTime: 0 },
    walls: [],
    particles: [],
    camera: { x: 0 },
    keys: {},
    lastTime: 0,
    wallSpawnTimer: 0
  });

  const resetGame = () => {
    setGameState('playing');
    setScore(0);
    setIsCharging(false);
    setChargeLevel(0);
    const game = gameRef.current;
    game.player = { x: 50, y: 150, width: 20, height: 20, vx: 0, vy: 0, isDashing: false, dashTime: 0 };
    game.walls = [];
    game.particles = [];
    game.camera = { x: 0 };
    game.wallSpawnTimer = 0;
    
    // Initial walls
    for (let i = 0; i < 10; i++) {
      game.walls.push({
        x: 200 + i * 100,
        y: Math.random() * 200 + 50,
        width: 30,
        height: 60,
        broken: false,
        health: 1
      });
    }
  };

  useEffect(() => {
    resetGame();
  }, []);

  useEffect(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;
    
    const ctx = canvas.getContext('2d');
    const game = gameRef.current;
    
    const handleKeyDown = (e) => {
      game.keys[e.code] = true;
      if (e.code === 'Space') {
        e.preventDefault();
        if (!game.player.isDashing) {
          setIsCharging(true);
        }
      }
    };
    
    const handleKeyUp = (e) => {
      game.keys[e.code] = false;
      if (e.code === 'Space') {
        e.preventDefault();
        if (isCharging && !game.player.isDashing) {
          // Start dash
          const dashPower = Math.min(chargeLevel / 60, 1);
          game.player.isDashing = true;
          game.player.dashTime = dashPower * 30;
          game.player.vx = dashPower * 15;
          game.player.vy = 0;
        }
        setIsCharging(false);
        setChargeLevel(0);
      }
    };

    window.addEventListener('keydown', handleKeyDown);
    window.addEventListener('keyup', handleKeyUp);

    const gameLoop = (currentTime) => {
      const deltaTime = currentTime - game.lastTime;
      game.lastTime = currentTime;
      
      if (gameState !== 'playing') return;
      
      // Update charge level
      if (isCharging && chargeLevel < 120) {
        setChargeLevel(prev => prev + 2);
      }
      
      // Update player
      const player = game.player;
      
      if (player.isDashing) {
        player.dashTime--;
        if (player.dashTime <= 0) {
          player.isDashing = false;
          player.vx *= 0.8;
        }
      } else {
        // Normal movement
        if (game.keys['ArrowUp'] && player.y > 0) player.vy = -3;
        else if (game.keys['ArrowDown'] && player.y < 280) player.vy = 3;
        else player.vy *= 0.9;
        
        player.vx *= 0.95;
      }
      
      player.x += player.vx;
      player.y += player.vy;
      
      // Keep player in bounds
      player.y = Math.max(0, Math.min(280, player.y));
      
      // Update camera
      game.camera.x = player.x - 100;
      
      // Spawn new walls
      game.wallSpawnTimer++;
      if (game.wallSpawnTimer > 120) {
        game.wallSpawnTimer = 0;
        game.walls.push({
          x: game.camera.x + 500,
          y: Math.random() * 200 + 50,
          width: 30,
          height: 60,
          broken: false,
          health: 1
        });
      }
      
      // Check wall collisions
      game.walls.forEach(wall => {
        if (!wall.broken && 
            player.x < wall.x + wall.width &&
            player.x + player.width > wall.x &&
            player.y < wall.y + wall.height &&
            player.y + player.height > wall.y) {
          
          if (player.isDashing && player.vx > 8) {
            // Break wall
            wall.broken = true;
            setScore(prev => prev + 10);
            
            // Create particles
            for (let i = 0; i < 8; i++) {
              game.particles.push({
                x: wall.x + wall.width/2,
                y: wall.y + wall.height/2,
                vx: (Math.random() - 0.5) * 8,
                vy: (Math.random() - 0.5) * 8,
                life: 30,
                color: `hsl(${Math.random() * 60 + 180}, 100%, 60%)`
              });
            }
          } else {
            // Stop player
            player.vx = 0;
            player.x = wall.x - player.width - 1;
          }
        }
      });
      
      // Update particles
      game.particles = game.particles.filter(particle => {
        particle.x += particle.vx;
        particle.y += particle.vy;
        particle.vx *= 0.95;
        particle.vy *= 0.95;
        particle.life--;
        return particle.life > 0;
      });
      
      // Remove old walls
      game.walls = game.walls.filter(wall => wall.x > game.camera.x - 100);
      
      // Render
      ctx.fillStyle = '#000020';
      ctx.fillRect(0, 0, 400, 300);
      
      // Grid background
      ctx.strokeStyle = '#00ffff20';
      ctx.lineWidth = 1;
      for (let x = -game.camera.x % 40; x < 400; x += 40) {
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, 300);
        ctx.stroke();
      }
      for (let y = 0; y < 300; y += 40) {
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(400, y);
        ctx.stroke();
      }
      
      // Render walls
      game.walls.forEach(wall => {
        if (wall.broken) return;
        
        const screenX = wall.x - game.camera.x;
        if (screenX > -50 && screenX < 450) {
          ctx.fillStyle = '#ff0080';
          ctx.fillRect(screenX, wall.y, wall.width, wall.height);
          
          // Neon glow
          ctx.shadowColor = '#ff0080';
----------------------------------------


================================================================================
GAME GENERATION: DotChase: Move white 20px circle with Arrow keys (speed: 5px/frame) to catch randomly-spawning red 10px dots (1 every 2sec) while avoiding black 15px circles that spawn every 3sec and move toward player at 3px/frame; score +1 per dot, lose on black circle collision. - 2025-08-09 14:20:23.199396
================================================================================
FULL CLAUDE GENERATED CODE:
----------------------------------------
import React, { useState, useEffect, useCallback } from 'react';

const GameZone = ({ currentGame }) => {
  const [gameState, setGameState] = useState('playing');
  const [score, setScore] = useState(0);
  const [player, setPlayer] = useState({ x: 200, y: 150 });
  const [dots, setDots] = useState([]);
  const [enemies, setEnemies] = useState([]);
  const [keys, setKeys] = useState({});

  const GAME_WIDTH = 400;
  const GAME_HEIGHT = 300;
  const PLAYER_SIZE = 20;
  const DOT_SIZE = 10;
  const ENEMY_SIZE = 15;
  const PLAYER_SPEED = 5;
  const ENEMY_SPEED = 3;

  const generateRandomPosition = () => ({
    x: Math.random() * (GAME_WIDTH - 20) + 10,
    y: Math.random() * (GAME_HEIGHT - 20) + 10
  });

  const checkCollision = (obj1, obj2, size1, size2) => {
    const dx = obj1.x - obj2.x;
    const dy = obj1.y - obj2.y;
    const distance = Math.sqrt(dx * dx + dy * dy);
    return distance < (size1 + size2) / 2;
  };

  const resetGame = () => {
    setGameState('playing');
    setScore(0);
    setPlayer({ x: 200, y: 150 });
    setDots([]);
    setEnemies([]);
  };

  const gameLoop = useCallback(() => {
    if (gameState !== 'playing') return;

    setPlayer(prev => {
      let newX = prev.x;
      let newY = prev.y;

      if (keys.ArrowUp) newY = Math.max(PLAYER_SIZE/2, prev.y - PLAYER_SPEED);
      if (keys.ArrowDown) newY = Math.min(GAME_HEIGHT - PLAYER_SIZE/2, prev.y + PLAYER_SPEED);
      if (keys.ArrowLeft) newX = Math.max(PLAYER_SIZE/2, prev.x - PLAYER_SPEED);
      if (keys.ArrowRight) newX = Math.min(GAME_WIDTH - PLAYER_SIZE/2, prev.x + PLAYER_SPEED);

      return { x: newX, y: newY };
    });

    setEnemies(prev => prev.map(enemy => {
      const dx = player.x - enemy.x;
      const dy = player.y - enemy.y;
      const distance = Math.sqrt(dx * dx + dy * dy);
      
      if (distance > 0) {
        return {
          x: enemy.x + (dx / distance) * ENEMY_SPEED,
          y: enemy.y + (dy / distance) * ENEMY_SPEED
        };
      }
      return enemy;
    }));

    setDots(prev => {
      const remainingDots = prev.filter(dot => {
        if (checkCollision(player, dot, PLAYER_SIZE, DOT_SIZE)) {
          setScore(s => s + 1);
          return false;
        }
        return true;
      });
      return remainingDots;
    });

    setEnemies(prev => {
      const hasCollision = prev.some(enemy => 
        checkCollision(player, enemy, PLAYER_SIZE, ENEMY_SIZE)
      );
      if (hasCollision) {
        setGameState('gameOver');
      }
      return prev;
    });
  }, [gameState, keys, player]);

  useEffect(() => {
    const interval = setInterval(gameLoop, 16);
    return () => clearInterval(interval);
  }, [gameLoop]);

  useEffect(() => {
    const dotInterval = setInterval(() => {
      if (gameState === 'playing') {
        setDots(prev => [...prev, generateRandomPosition()]);
      }
    }, 2000);

    const enemyInterval = setInterval(() => {
      if (gameState === 'playing') {
        setEnemies(prev => [...prev, generateRandomPosition()]);
      }
    }, 3000);

    return () => {
      clearInterval(dotInterval);
      clearInterval(enemyInterval);
    };
  }, [gameState]);

  useEffect(() => {
    const handleKeyDown = (e) => {
      setKeys(prev => ({ ...prev, [e.key]: true }));
    };

    const handleKeyUp = (e) => {
      setKeys(prev => ({ ...prev, [e.key]: false }));
    };

    window.addEventListener('keydown', handleKeyDown);
    window.addEventListener('keyup', handleKeyUp);

    return () => {
      window.removeEventListener('keydown', handleKeyDown);
      window.removeEventListener('keyup', handleKeyUp);
    };
  }, []);

  return (
    <div style={{ textAlign: 'center', padding: '20px' }}>
      <div style={{ marginBottom: '10px' }}>
        <div>Score: {score}</div>
        {gameState === 'gameOver' && (
          <div style={{ color: 'red', fontWeight: 'bold' }}>Game Over!</div>
        )}
      </div>
      
      <div
        style={{
          position: 'relative',
          width: GAME_WIDTH,
          height: GAME_HEIGHT,
          border: '2px solid #333',
          margin: '0 auto',
          backgroundColor: '#f0f0f0'
        }}
      >
        <div
          style={{
            position: 'absolute',
            left: player.x - PLAYER_SIZE/2,
            top: player.y - PLAYER_SIZE/2,
            width: PLAYER_SIZE,
            height: PLAYER_SIZE,
            backgroundColor: 'white',
            borderRadius: '50%',
            border: '1px solid #ccc'
          }}
        />
        
        {dots.map((dot, index) => (
          <div
            key={index}
            style={{
              position: 'absolute',
              left: dot.x - DOT_SIZE/2,
              top: dot.y - DOT_SIZE/2,
              width: DOT_SIZE,
              height: DOT_SIZE,
              backgroundColor: 'red',
              borderRadius: '50%'
            }}
          />
        ))}
        
        {enemies.map((enemy, index) => (
          <div
            key={index}
            style={{
              position: 'absolute',
              left: enemy.x - ENEMY_SIZE/2,
              top: enemy.y - ENEMY_SIZE/2,
              width: ENEMY_SIZE,
              height: ENEMY_SIZE,
              backgroundColor: 'black',
              borderRadius: '50%'
            }}
          />
        ))}
      </div>
      
      <div style={{ marginTop: '10px' }}>
        <button onClick={resetGame} style={{ padding: '8px 16px', fontSize: '16px' }}>
          {gameState === 'gameOver' ? 'Play Again' : 'Restart'}
        </button>
      </div>
      
      <div style={{ marginTop: '10px', fontSize: '12px', color: '#666' }}>
        Use Arrow Keys to move. Catch red dots, avoid black circles!
      </div>
    </div>
  );
};

export default GameZone;
----------------------------------------


================================================================================
GAME GENERATION: Lucky Glider: swipe to change lanes and avoid traffic on floating islands. - 2025-08-09 14:25:09.344616
================================================================================
FULL CLAUDE GENERATED CODE:
----------------------------------------
import React, { useState, useEffect, useRef, useCallback } from 'react';

const GameZone = ({ currentGame }) => {
  const canvasRef = useRef(null);
  const [gameState, setGameState] = useState('playing');
  const [score, setScore] = useState(0);
  const [playerLane, setPlayerLane] = useState(1);
  const [islands, setIslands] = useState([]);
  const [traffic, setTraffic] = useState([]);
  const [gameSpeed, setGameSpeed] = useState(2);

  const CANVAS_WIDTH = 400;
  const CANVAS_HEIGHT = 300;
  const LANES = 3;
  const LANE_WIDTH = CANVAS_WIDTH / LANES;
  const PLAYER_SIZE = 20;
  const TRAFFIC_SIZE = 15;
  const ISLAND_HEIGHT = 40;

  const resetGame = useCallback(() => {
    setGameState('playing');
    setScore(0);
    setPlayerLane(1);
    setIslands([
      { x: 0, y: 260, width: CANVAS_WIDTH, height: ISLAND_HEIGHT },
      { x: 0, y: 180, width: CANVAS_WIDTH, height: ISLAND_HEIGHT },
      { x: 0, y: 100, width: CANVAS_WIDTH, height: ISLAND_HEIGHT },
      { x: 0, y: 20, width: CANVAS_WIDTH, height: ISLAND_HEIGHT }
    ]);
    setTraffic([]);
    setGameSpeed(2);
  }, []);

  const handleSwipe = useCallback((direction) => {
    if (gameState !== 'playing') return;
    
    if (direction === 'left' && playerLane > 0) {
      setPlayerLane(prev => prev - 1);
    } else if (direction === 'right' && playerLane < LANES - 1) {
      setPlayerLane(prev => prev + 1);
    }
  }, [gameState, playerLane]);

  const handleKeyPress = useCallback((e) => {
    if (e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'A') {
      handleSwipe('left');
    } else if (e.key === 'ArrowRight' || e.key === 'd' || e.key === 'D') {
      handleSwipe('right');
    }
  }, [handleSwipe]);

  const handleTouch = useCallback((e) => {
    e.preventDefault();
    const touch = e.touches[0] || e.changedTouches[0];
    const rect = canvasRef.current.getBoundingClientRect();
    const x = touch.clientX - rect.left;
    
    if (x < CANVAS_WIDTH / 2) {
      handleSwipe('left');
    } else {
      handleSwipe('right');
    }
  }, [handleSwipe]);

  useEffect(() => {
    resetGame();
  }, [resetGame]);

  useEffect(() => {
    window.addEventListener('keydown', handleKeyPress);
    return () => window.removeEventListener('keydown', handleKeyPress);
  }, [handleKeyPress]);

  useEffect(() => {
    if (gameState !== 'playing') return;

    const gameLoop = setInterval(() => {
      setIslands(prev => prev.map(island => ({
        ...island,
        y: island.y + gameSpeed
      })).filter(island => island.y < CANVAS_HEIGHT + ISLAND_HEIGHT));

      setTraffic(prev => {
        let newTraffic = prev.map(car => ({
          ...car,
          y: car.y + gameSpeed
        })).filter(car => car.y < CANVAS_HEIGHT + TRAFFIC_SIZE);

        if (Math.random() < 0.03) {
          const lane = Math.floor(Math.random() * LANES);
          newTraffic.push({
            x: lane * LANE_WIDTH + LANE_WIDTH / 2 - TRAFFIC_SIZE / 2,
            y: -TRAFFIC_SIZE,
            lane: lane
          });
        }

        return newTraffic;
      });

      setScore(prev => prev + 1);
      setGameSpeed(prev => Math.min(prev + 0.005, 4));

      setTraffic(currentTraffic => {
        const playerX = playerLane * LANE_WIDTH + LANE_WIDTH / 2;
        const playerY = CANVAS_HEIGHT - 60;
        
        for (let car of currentTraffic) {
          const distance = Math.sqrt(
            Math.pow(car.x + TRAFFIC_SIZE / 2 - playerX, 2) + 
            Math.pow(car.y + TRAFFIC_SIZE / 2 - playerY, 2)
          );
          
          if (distance < (PLAYER_SIZE + TRAFFIC_SIZE) / 2) {
            setGameState('gameOver');
            break;
          }
        }
        
        return currentTraffic;
      });

      setIslands(currentIslands => {
        if (currentIslands.length < 4) {
          const newIslands = [...currentIslands];
          const lastIsland = newIslands[newIslands.length - 1];
          if (!lastIsland || lastIsland.y > -ISLAND_HEIGHT) {
            newIslands.push({
              x: 0,
              y: lastIsland ? lastIsland.y - 80 : -ISLAND_HEIGHT,
              width: CANVAS_WIDTH,
              height: ISLAND_HEIGHT
            });
          }
          return newIslands;
        }
        return currentIslands;
      });
    }, 16);

    return () => clearInterval(gameLoop);
  }, [gameState, gameSpeed, playerLane]);

  useEffect(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;

    const ctx = canvas.getContext('2d');
    ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

    ctx.fillStyle = '#87CEEB';
    ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

    islands.forEach(island => {
      ctx.fillStyle = '#90EE90';
      ctx.fillRect(island.x, island.y, island.width, island.height);
      
      ctx.fillStyle = '#228B22';
      ctx.fillRect(island.x, island.y, island.width, 5);
    });

    for (let i = 1; i < LANES; i++) {
      ctx.strokeStyle = '#FFFFFF';
      ctx.lineWidth = 2;
      ctx.setLineDash([10, 10]);
      ctx.beginPath();
      ctx.moveTo(i * LANE_WIDTH, 0);
      ctx.lineTo(i * LANE_WIDTH, CANVAS_HEIGHT);
      ctx.stroke();
      ctx.setLineDash([]);
    }

    traffic.forEach(car => {
      ctx.fillStyle = '#FF4444';
      ctx.fillRect(car.x, car.y, TRAFFIC_SIZE, TRAFFIC_SIZE);
    });

    const playerX = playerLane * LANE_WIDTH + LANE_WIDTH / 2 - PLAYER_SIZE / 2;
    const playerY = CANVAS_HEIGHT - 60;
    
    ctx.fillStyle = '#4169E1';
    ctx.beginPath();
    ctx.moveTo(playerX + PLAYER_SIZE / 2, playerY);
    ctx.lineTo(playerX, playerY + PLAYER_SIZE);
    ctx.lineTo(playerX + PLAYER_SIZE, playerY + PLAYER_SIZE);
    ctx.closePath();
    ctx.fill();

    ctx.fillStyle = '#FFFFFF';
    ctx.font = '16px Arial';
    ctx.fillText(`Score: ${score}`, 10, 25);
    
    if (gameState === 'gameOver') {
----------------------------------------


================================================================================
GAME GENERATION: DotChase: Move blue 20px circle with Arrow keys at 5px/step to collect green 10px dots (+1 point each) while avoiding red 15px circles that spawn every 2s and move at 3px/step toward player; game ends if touched by red circle or reaching 30 points. - 2025-08-09 14:26:01.315612
================================================================================
FULL CLAUDE GENERATED CODE:
----------------------------------------
import React, { useState, useEffect, useRef, useCallback } from 'react';

const GameZone = ({ currentGame }) => {
  const canvasRef = useRef(null);
  const gameLoopRef = useRef(null);
  const keysRef = useRef({});
  
  const [gameState, setGameState] = useState({
    player: { x: 200, y: 150 },
    dots: [],
    enemies: [],
    score: 0,
    gameOver: false,
    won: false
  });

  const CANVAS_WIDTH = 400;
  const CANVAS_HEIGHT = 300;
  const PLAYER_SIZE = 20;
  const DOT_SIZE = 10;
  const ENEMY_SIZE = 15;
  const PLAYER_SPEED = 5;
  const ENEMY_SPEED = 3;

  const resetGame = useCallback(() => {
    setGameState({
      player: { x: 200, y: 150 },
      dots: [
        { x: 50, y: 50 },
        { x: 350, y: 50 },
        { x: 50, y: 250 },
        { x: 350, y: 250 },
        { x: 200, y: 100 }
      ],
      enemies: [],
      score: 0,
      gameOver: false,
      won: false
    });
  }, []);

  const spawnDot = useCallback(() => {
    return {
      x: Math.random() * (CANVAS_WIDTH - DOT_SIZE),
      y: Math.random() * (CANVAS_HEIGHT - DOT_SIZE)
    };
  }, []);

  const spawnEnemy = useCallback(() => {
    const side = Math.floor(Math.random() * 4);
    let x, y;
    
    switch(side) {
      case 0: x = 0; y = Math.random() * CANVAS_HEIGHT; break;
      case 1: x = CANVAS_WIDTH; y = Math.random() * CANVAS_HEIGHT; break;
      case 2: x = Math.random() * CANVAS_WIDTH; y = 0; break;
      case 3: x = Math.random() * CANVAS_WIDTH; y = CANVAS_HEIGHT; break;
    }
    
    return { x, y };
  }, []);

  const checkCollision = useCallback((obj1, obj2, size1, size2) => {
    const dx = obj1.x - obj2.x;
    const dy = obj1.y - obj2.y;
    const distance = Math.sqrt(dx * dx + dy * dy);
    return distance < (size1 + size2) / 2;
  }, []);

  const updateGame = useCallback(() => {
    setGameState(prevState => {
      if (prevState.gameOver || prevState.won) return prevState;

      let newState = { ...prevState };
      
      // Move player
      let newX = newState.player.x;
      let newY = newState.player.y;
      
      if (keysRef.current.ArrowLeft) newX = Math.max(PLAYER_SIZE/2, newX - PLAYER_SPEED);
      if (keysRef.current.ArrowRight) newX = Math.min(CANVAS_WIDTH - PLAYER_SIZE/2, newX + PLAYER_SPEED);
      if (keysRef.current.ArrowUp) newY = Math.max(PLAYER_SIZE/2, newY - PLAYER_SPEED);
      if (keysRef.current.ArrowDown) newY = Math.min(CANVAS_HEIGHT - PLAYER_SIZE/2, newY + PLAYER_SPEED);
      
      newState.player = { x: newX, y: newY };

      // Move enemies toward player
      newState.enemies = newState.enemies.map(enemy => {
        const dx = newState.player.x - enemy.x;
        const dy = newState.player.y - enemy.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        if (distance > 0) {
          const moveX = (dx / distance) * ENEMY_SPEED;
          const moveY = (dy / distance) * ENEMY_SPEED;
          return {
            x: enemy.x + moveX,
            y: enemy.y + moveY
          };
        }
        return enemy;
      });

      // Check dot collection
      newState.dots = newState.dots.filter(dot => {
        if (checkCollision(newState.player, dot, PLAYER_SIZE, DOT_SIZE)) {
          newState.score++;
          return false;
        }
        return true;
      });

      // Spawn new dots if needed
      while (newState.dots.length < 3) {
        newState.dots.push(spawnDot());
      }

      // Check enemy collision
      for (let enemy of newState.enemies) {
        if (checkCollision(newState.player, enemy, PLAYER_SIZE, ENEMY_SIZE)) {
          newState.gameOver = true;
          break;
        }
      }

      // Check win condition
      if (newState.score >= 30) {
        newState.won = true;
      }

      return newState;
    });
  }, [checkCollision, spawnDot]);

  const draw = useCallback(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;
    
    const ctx = canvas.getContext('2d');
    ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

    // Draw player
    ctx.fillStyle = 'blue';
    ctx.beginPath();
    ctx.arc(gameState.player.x, gameState.player.y, PLAYER_SIZE/2, 0, 2 * Math.PI);
    ctx.fill();

    // Draw dots
    ctx.fillStyle = 'green';
    gameState.dots.forEach(dot => {
      ctx.beginPath();
      ctx.arc(dot.x + DOT_SIZE/2, dot.y + DOT_SIZE/2, DOT_SIZE/2, 0, 2 * Math.PI);
      ctx.fill();
    });

    // Draw enemies
    ctx.fillStyle = 'red';
    gameState.enemies.forEach(enemy => {
      ctx.beginPath();
      ctx.arc(enemy.x, enemy.y, ENEMY_SIZE/2, 0, 2 * Math.PI);
      ctx.fill();
    });
  }, [gameState]);

  useEffect(() => {
    resetGame();
  }, [resetGame]);

  useEffect(() => {
    const handleKeyDown = (e) => {
      if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key)) {
        e.preventDefault();
        keysRef.current[e.key] = true;
      }
    };

    const handleKeyUp = (e) => {
      keysRef.current[e.key] = false;
    };

    window.addEventListener('keydown', handleKeyDown);
    window.addEventListener('keyup', handleKeyUp);

    return () => {
      window.removeEventListener('keydown', handleKeyDown);
      window.removeEventListener('keyup', handleKeyUp);
    };
  }, []);

  useEffect(() => {
    if (!gameState.gameOver && !gameState.won) {
      gameLoopRef.current = setInterval(() => {
        updateGame();
      }, 1000 / 60);

      return () => {
        if (gameLoopRef.current) {
          clearInterval(gameLoopRef.current);
        }
      };
    }
  }, [gameState.gameOver, gameState.won, updateGame]);

  useEffect(() => {
    if (!gameState.gameOver && !gameState.won) {
      const enemySpawnInterval = setInterval(() => {
        setGameState(prevState => ({
----------------------------------------

